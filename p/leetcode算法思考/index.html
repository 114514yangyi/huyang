<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="算法题目汇总讲解">
<title>Leetcode算法思考</title>

<link rel='canonical' href='https://114514yangyi.github.io/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/'>

<link rel="stylesheet" href="/huyang/scss/style.min.d3155b48d3f5e651913a4712b8065e284fd3889f067f1ac6e6ec77400046eba5.css"><meta property='og:title' content="Leetcode算法思考">
<meta property='og:description' content="算法题目汇总讲解">
<meta property='og:url' content='https://114514yangyi.github.io/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/'>
<meta property='og:site_name' content='Hu Yang&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-05-18T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2020-10-09T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="Leetcode算法思考">
<meta name="twitter:description" content="算法题目汇总讲解">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/huyang/">
                
                    
                    
                    
                        
                        <img src="/huyang/img/logo-transparent_hu_2593eda3cf734d42.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/huyang">Hu Yang&#39;s Blog</a></h1>
            <h2 class="site-description">Blog</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://114514yangyi.github.io/huyang/'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='2416572689@qq.com'
                        target="_blank"
                        title="QQ"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/huyang/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/huyang/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/huyang/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/huyang/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/huyang/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://114514yangyi.github.io/huyang/" selected>English</option>
                                
                                    <option value="https://114514yangyi.github.io/huyang/zh-cn/" >中文</option>
                                
                                    <option value="https://114514yangyi.github.io/huyang/ar/" >عربي</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#树状数组">树状数组:</a></li>
    <li><a href="#upper_bound">upper_bound</a></li>
    <li><a href="#滑动窗口">滑动窗口</a></li>
    <li><a href="#珂朵莉树">珂朵莉树</a></li>
    <li><a href="#静态线段树4n">静态线段树(4N)</a></li>
    <li><a href="#动态开点线段树">动态开点线段树</a></li>
    <li><a href="#并查集">并查集</a></li>
    <li><a href="#位运算">位运算</a></li>
    <li><a href="#数据结构">数据结构</a></li>
    <li><a href="#单调栈">单调栈</a></li>
    <li><a href="#最大堆最小堆">最大堆/最小堆</a></li>
    <li><a href="#最短路径算法">最短路径算法</a>
      <ol>
        <li><a href="#dijkstra算法极简版">Dijkstra算法（极简版）</a></li>
      </ol>
    </li>
    <li><a href="#前缀和">前缀和</a></li>
    <li><a href="#大数求模">大数求模</a>
      <ol>
        <li><a href="#费马定理证明">费马定理证明</a></li>
        <li><a href="#扩展欧几里得">扩展欧几里得</a></li>
      </ol>
    </li>
    <li><a href="#动态规划的精益思想">动态规划的精益思想</a>
      <ol>
        <li><a href="#1-朴素-dfs--暴力递归">1. 朴素 DFS / 暴力递归</a></li>
        <li><a href="#2-记忆化搜索-memoized-dfs--top-down-dp">2. 记忆化搜索 (Memoized DFS / Top-Down DP)</a></li>
        <li><a href="#3-多维通常二维dp-数组-bottom-up-dp">3. 多维（通常二维）DP 数组 (Bottom-Up DP)</a></li>
        <li><a href="#4-dp-数组降维-空间优化">4. DP 数组降维 (空间优化)</a></li>
        <li><a href="#5-状态转移矩阵--矩阵快速幂">5. 状态转移矩阵 + 矩阵快速幂</a></li>
      </ol>
    </li>
    <li><a href="#dp变种">DP变种</a>
      <ol>
        <li><a href="#状态集dp">状态集DP</a></li>
        <li><a href="#状态机振荡dp">状态机（振荡）DP</a></li>
        <li><a href="#字符集动态规划-character-set-dp-方法与思路总结">字符集动态规划 (Character Set DP) 方法与思路总结</a>
          <ol>
            <li><a href="#1-核心思想">1. 核心思想</a></li>
            <li><a href="#2-通用方法步骤">2. 通用方法步骤</a></li>
            <li><a href="#3-适用场景">3. 适用场景</a></li>
          </ol>
        </li>
        <li><a href="#树形动态规划-tree-dp-方法与思路总结">树形动态规划 (Tree DP) 方法与思路总结</a>
          <ol>
            <li><a href="#1-核心思想-1">1. 核心思想</a></li>
            <li><a href="#2-通用方法步骤-1">2. 通用方法步骤</a></li>
            <li><a href="#3-适用场景-1">3. 适用场景</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#区间融合">区间融合</a></li>
    <li><a href="#查分数组性质">查分数组性质</a></li>
    <li><a href="#从环染色到递推思想">从环染色到递推思想</a></li>
  </ol>

  <ol>
    <li><a href="#1-问题定义与符号约定">1. 问题定义与符号约定</a></li>
    <li><a href="#2-辅助状态定义-路径染色">2. 辅助状态定义 (路径染色)</a></li>
    <li><a href="#3-递推关系的建立">3. 递推关系的建立</a>
      <ol>
        <li><a href="#31-b_i-的递推关系">3.1. $B_i$ 的递推关系</a></li>
        <li><a href="#32-c_i-的递推关系">3.2. $C_i$ 的递推关系</a></li>
      </ol>
    </li>
    <li><a href="#4-环染色方案数-s_n-的表达式">4. 环染色方案数 $S_n$ 的表达式</a></li>
    <li><a href="#5-s_n-与-c_n-的关系">5. $S_n$ 与 $C_n$ 的关系</a></li>
    <li><a href="#6-最终递推公式">6. 最终递推公式</a></li>
    <li><a href="#7-初始条件">7. 初始条件</a>
      <ol>
        <li><a href="#1传球问题">（1）传球问题</a></li>
        <li><a href="#2">(2)</a></li>
        <li><a href="#3全错位排列问题">(3)<a href="https://zhida.zhihu.com/search?content_id=192498207&amp;content_type=Article&amp;match_order=1&amp;q=%E5%85%A8%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDc4ODM5ODQsInEiOiLlhajplJnkvY3mjpLliJciLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxOTI0OTgyMDcsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.2I5z29BbhABKOFn9Kqf57yny_XRf1mQ9gVbyxHjtwg0&amp;zhida_source=entity">全错位排列</a>问题</a></li>
      </ol>
    </li>
    <li><a href="#二分查找在满足单调性条件的函数中寻找特定边界值">二分查找在满足单调性条件的函数中寻找特定边界值</a></li>
    <li><a href="#如何识别与解决贪心算法问题-">如何识别与解决贪心算法问题 🧐</a>
      <ol>
        <li><a href="#1-识别贪心问题"><strong>1. 识别贪心问题</strong></a></li>
        <li><a href="#2-构建贪心策略"><strong>2. 构建贪心策略</strong></a></li>
        <li><a href="#3-贪心算法配合堆的通用模板类似你的题目"><strong>3. 贪心算法配合堆的通用模板（类似你的题目）</strong></a></li>
        <li><a href="#为什么使用差分数组"><strong>为什么使用差分数组？🤔</strong></a></li>
      </ol>
    </li>
    <li><a href="#图的拓扑排序">图的拓扑排序</a>
      <ol>
        <li><a href="#dfs-拓扑排序算法">DFS 拓扑排序算法</a></li>
        <li><a href="#kahn-算法-基于入度">Kahn 算法 (基于入度)</a></li>
      </ol>
    </li>
    <li><a href="#组合数递推关系">组合数递推关系</a>
      <ol>
        <li><a href="#c-计算组合数代码">C++ 计算组合数代码</a></li>
      </ol>
    </li>
    <li><a href="#曼哈顿距离等价公式推导">曼哈顿距离等价公式推导</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/huyang/categories/%E7%AE%97%E6%B3%95/" style="background-color: #2a9d8f; color: #fff;">
                算法
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/">Leetcode算法思考</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            算法题目汇总讲解
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">May 18, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    44 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="算法">算法
</h1><h2 id="树状数组">树状数组:
</h2><p>讲解:树状数组:</p>
<p>【五分钟丝滑动画讲解 | 树状数组】 <a class="link" href="https://www.bilibili.com/video/BV1ce411u7qP/?share_source=copy_web&amp;vd_source=ab6f092f3525a4cf3eabb140987cdedf"  target="_blank" rel="noopener"
    >https://www.bilibili.com/video/BV1ce411u7qP/?share_source=copy_web&vd_source=ab6f092f3525a4cf3eabb140987cdedf</a></p>
<p>数据结构:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BIT</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于查询树状数组的前缀和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="kt">long</span> <span class="nf">pre</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span> <span class="o">+=</span> <span class="n">tree</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">idx</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新树状数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tree</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">idx</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  	<span class="kt">long</span> <span class="kt">long</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">idx</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>[!NOTE]</p>
<p><a class="link" href="https://leetcode.cn/problems/count-good-triplets-in-an-array/solutions/1277695/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd"  target="_blank" rel="noopener"
    >https://leetcode.cn/problems/count-good-triplets-in-an-array/solutions/1277695/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd</a>
使用转置将一个排列有序化,这样子就只用关注另一个排列即可;</p></blockquote>
<h2 id="upper_bound">upper_bound
</h2><p>一下所有的说明都是对于一个升序数组:</p>
<p>upper_bound:返回第一个大于 val 的迭代器;</p>
<p>lower_bound:返回第一个大于等于 val 的迭代器;</p>
<p>重载:</p>
<p><code>bool cpm(int val,int element){</code></p>
<p><code>return val&lt;element;</code></p>
<p><code>}</code></p>
<p>对于大于号的方式,表示的含义就反过来了:</p>
<p>upper_bound:返回第一个小于 val 的迭代器;</p>
<p>lower_bound:返回第一个小于等于 val 的迭代器;</p>
<h2 id="滑动窗口">滑动窗口
</h2><p>适用于对于子数组+维持一个子数组的状态</p>
<p>算法模版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ans</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">right</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">right</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="nl">update</span><span class="p">:</span><span class="err">窗口内信息</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="err">符合题意</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="err">更新状态</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="err">求解</span> <span class="n">ans</span> <span class="err">更新</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里还有另一种计算滑动窗口的方法:</p>
<p>就是使用 for 循环不断更新上界限 right,然后每次都计算下界限,并且将 res+=left-start</p>
<p>这种计算滑动窗口的模式适用于:计算在一个 nums 中拥有多少个满足的子数组数量.并且这种子数组时满足最小满足形态的,也就是假如一个子数组满足条件,那么再给他添加数字,子数组任然满足条件.</p>
<p>下面是模板:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="n">update</span> <span class="n">the</span> <span class="n">left</span> <span class="n">bound</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">res</span><span class="o">+=</span><span class="n">left</span><span class="o">-</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="珂朵莉树">珂朵莉树
</h2><p>用一颗平衡树维护不相交的区间，每次 add(left,right) 时，删除被该区间覆盖到的区间（部分覆盖也算），然后将被删除的区间与 [left,right] 合并成一个新的大区间（并集），插入平衡树中。</p>
<p>代码实现时，为方便找到第一个被 [left,right] 覆盖到的区间，我们可以用平衡树的 key 存区间右端点，value 存区间左端点。我们要找的就是第一个 key≥left 的区间。</p>
<p>好的，我们来总结一下基于 <code>std::map</code> 实现的区间合并与计数方法，这种方法有时被看作是<strong>珂朵莉树（Chtholly Tree / ODT - Old Driver Tree）</strong> 思想的一种简化应用，特别适用于只关心区间覆盖而不关心区间赋值（即将区间内元素设为某个特定值）的场景，例如 LeetCode 2276 这道题。</p>
<p><strong>核心思想</strong></p>
<p>利用有序数据结构（如 C++ 的 <code>std::map</code> 或 Java 的 <code>TreeMap</code>）来存储<strong>不相交</strong>的区间段。<code>map</code> 的键（key）存储区间的左端点，值（value）存储区间的右端点。同时维护一个变量 <code>cnt</code> 记录当前所有不相交区间覆盖的整数总数。</p>
<p>当需要添加一个新的区间 <code>[left, right]</code> 时：</p>
<ol>
<li>查找 <code>map</code> 中一个与 <code>[left, right]</code> <strong>相交</strong>的已有区间。</li>
<li>将这个相交的区间与 <code>[left, right]</code> <strong>合并</strong>成一个更大的新区间。</li>
<li>在合并过程中，从 <code>cnt</code> 中减去被合并掉的旧区间的长度，并将旧区间从 <code>map</code> 中删除。</li>
<li>再调用 add 来添加这个更大的区间.</li>
<li>最后，将合并后的最终大区间加入 <code>map</code>，并将其长度加到 <code>cnt</code> 中。</li>
</ol>
<p>算法的模版是:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">CountIntervals</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CountIntervals</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">begin</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">            <span class="n">it</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">&amp;&amp;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">&amp;&amp;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&gt;=</span><span class="n">left</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cnt</span><span class="o">-=</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">mp</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cnt</span><span class="o">+=</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mp</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="静态线段树4n">静态线段树(4N)
</h2><p>前置知识：线段树、动态开点线段树</p>
<p>完整的动态开点线段树模板见我的 算法竞赛模板库。</p>
<p>对于本题来说，线段树的每个节点可以保存对应范围的左右端点 l 和 r，以及范围内 add 过的整数个数 cnt。</p>
<p>代码实现时，无需记录 lazy tag，这是因为被覆盖的范围无需再次覆盖，因此若 cnt 等于范围的长度 r−l+1，则可直接返回。</p>
<p>作者：灵茶山艾府
链接：https://leetcode.cn/problems/count-integers-in-intervals/solutions/1495396/by-endlesscheng-clk2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Okay, 让我们来总结一下基础线段树的 C++ 算法模板，并阐述其核心思想。这个模板主要针对<strong>区间查询</strong>（如求和、最值）和<strong>单点更新</strong>。</p>
<p><strong>核心思想</strong></p>
<p>线段树的核心思想是 <strong>分治 (Divide and Conquer)</strong>。它将一个大区间（通常是一维数组的范围）递归地划分成两个规模大致相等的子区间，直到每个区间只包含一个元素（叶子节点）。然后，通过合并子区间的信息来得到父区间的信息。</p>
<ol>
<li><strong>结构</strong>: 它是一棵平衡的<strong>二叉树</strong>。
<ul>
<li><strong>根节点</strong>: 代表整个区间 <code>[1, N]</code>（或 <code>[0, N-1]</code>，取决于你的下标习惯）。</li>
<li><strong>内部节点</strong>: 代表一个子区间 <code>[L, R]</code>。它的左孩子代表区间 <code>[L, mid]</code>，右孩子代表区间 <code>[mid+1, R]</code>，其中 <code>mid = (L + R) / 2</code>。节点存储的是其代表区间 <code>[L, R]</code> 的某种<strong>聚合信息</strong>（例如，区间和、区间最大值、区间最小值）。</li>
<li><strong>叶子节点</strong>: 代表只包含单个元素的区间 <code>[i, i]</code>，其值通常就是原始数组中该位置的元素值。</li>
</ul>
</li>
<li><strong>预计算</strong>: 线段树通过 <code>build</code> 操作预先计算并存储每个节点（即每个子区间）的聚合信息。</li>
<li><strong>高效查询/更新</strong>:
<ul>
<li><strong>区间查询</strong>: 当查询区间 <code>[query_L, query_R]</code> 时，线段树利用预计算的信息。如果当前节点代表的区间 <code>[L, R]</code> 完全包含在查询区间内，则直接返回该节点的值，无需继续向下递归。如果部分重叠，则递归查询相关的子节点，并将结果合并。这使得查询可以在 O(logN) 时间内完成。</li>
<li><strong>单点更新</strong>: 当更新原始数组中某个位置 <code>index</code> 的值时，只需更新从包含该位置的叶子节点到根节点路径上的所有节点的值。这个路径的长度也是 O(logN)，因此更新操作也是 O(logN)。</li>
</ul>
</li>
</ol>
<p><strong>C++ 模板 (以区间求和为例)</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"> </span><span class="c1">// 包含 std::midpoint (C++20) 或用于计算中点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 long long 避免求和时整数溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 假设处理的原始数组下标从 1 开始，区间为 [1, N]
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果原始数组下标从 0 开始，区间为 [0, N-1]，需要稍微调整 build 和调用的初始范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="n">N_MAX</span> <span class="o">=</span> <span class="mi">100005</span><span class="p">;</span> <span class="c1">// 根据题目调整最大数组大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ll</span> <span class="n">tree</span><span class="p">[</span><span class="n">N_MAX</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>        <span class="c1">// 线段树数组，大小通常开到 4*N
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ll</span> <span class="n">original_array</span><span class="p">[</span><span class="n">N_MAX</span><span class="p">];</span>  <span class="c1">// 原始数组 (示例，通常从输入读取)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                     <span class="c1">// 原始数组的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// --- 核心函数 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// push_up: 用子节点信息更新父节点信息
</span></span></span><span class="line"><span class="cl"><span class="c1">// p: 当前节点（父节点）在 tree 数组中的索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">push_up</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于区间和，父节点的值等于左右子节点的值之和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">tree</span><span class="p">[</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是求最大值：tree[p] = max(tree[p * 2], tree[p * 2 + 1]);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果是求最小值：tree[p] = min(tree[p * 2], tree[p * 2 + 1]);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// build: 构建线段树
</span></span></span><span class="line"><span class="cl"><span class="c1">// p: 当前构建的节点在 tree 数组中的索引
</span></span></span><span class="line"><span class="cl"><span class="c1">// l, r: 当前节点代表的区间 [l, r] (在原始数组中的下标范围)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 到达叶子节点，其值等于原始数组对应位置的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_array</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 递归构建左右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// C++20: int mid = std::midpoint(l, r);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 防止 (l+r) 溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">build</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>       <span class="c1">// 构建左子树，节点索引为 2*p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">build</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="c1">// 构建右子树，节点索引为 2*p + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从子节点回溯时，用子节点信息更新当前节点信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">push_up</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// update: 单点更新
</span></span></span><span class="line"><span class="cl"><span class="c1">// p: 当前节点索引
</span></span></span><span class="line"><span class="cl"><span class="c1">// l, r: 当前节点代表的区间 [l, r]
</span></span></span><span class="line"><span class="cl"><span class="c1">// index: 需要更新的原始数组元素的下标
</span></span></span><span class="line"><span class="cl"><span class="c1">// value: 更新后的新值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">ll</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 找到叶子节点，更新其值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果需要，同时更新 original_array[index] = value;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 递归进入包含 index 的子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// C++20: int mid = std::midpoint(l, r);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// index 在左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">update</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// index 在右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">update</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 更新完子节点后，回溯更新当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">push_up</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// query: 区间查询
</span></span></span><span class="line"><span class="cl"><span class="c1">// p: 当前节点索引
</span></span></span><span class="line"><span class="cl"><span class="c1">// l, r: 当前节点代表的区间 [l, r]
</span></span></span><span class="line"><span class="cl"><span class="c1">// query_l, query_r: 需要查询的区间范围 [query_l, query_r]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ll</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">query_l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">query_r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Case 1: 当前节点代表的区间完全包含在查询区间内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">query_r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="c1">// 直接返回当前节点的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Case 2 &amp; 3: 部分重叠或无重叠（无重叠时下面判断会处理）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// C++20: int mid = std::midpoint(l, r);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ll</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始化结果 (对于求和是0, 求最小值是正无穷, 求最大值是负无穷)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果查询区间与左子区间有重叠，则递归查询左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">+=</span> <span class="n">query</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求最值：result = min/max(result, query(...));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果查询区间与右子区间有重叠，则递归查询右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">query_r</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span> <span class="o">+=</span> <span class="n">query</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求最值：result = min/max(result, query(...));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 返回合并后的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 使用示例 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">int main() {
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 假设 n 和 original_array 已经填充好
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cin &gt;&gt; n;
</span></span></span><span class="line"><span class="cl"><span class="cm">    for (int i = 1; i &lt;= n; ++i) {
</span></span></span><span class="line"><span class="cl"><span class="cm">        std::cin &gt;&gt; original_array[i];
</span></span></span><span class="line"><span class="cl"><span class="cm">    }
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 1. 构建线段树 (从根节点1开始，代表区间[1, n])
</span></span></span><span class="line"><span class="cl"><span class="cm">    build(1, 1, n);
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 2. 查询区间 [L, R] 的和
</span></span></span><span class="line"><span class="cl"><span class="cm">    int L = 2, R = 5;
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll sum_result = query(1, 1, n, L, R);
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;Sum of [&#34; &lt;&lt; L &lt;&lt; &#34;, &#34; &lt;&lt; R &lt;&lt; &#34;] is &#34; &lt;&lt; sum_result &lt;&lt; std::endl;
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 3. 更新位置 index 的值为 value
</span></span></span><span class="line"><span class="cl"><span class="cm">    int index_to_update = 3;
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll new_value = 10;
</span></span></span><span class="line"><span class="cl"><span class="cm">    update(1, 1, n, index_to_update, new_value);
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 4. 再次查询区间 [L, R] 的和
</span></span></span><span class="line"><span class="cl"><span class="cm">    sum_result = query(1, 1, n, L, R);
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;After update, sum of [&#34; &lt;&lt; L &lt;&lt; &#34;, &#34; &lt;&lt; R &lt;&lt; &#34;] is &#34; &lt;&lt; sum_result &lt;&lt; std::endl;
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    return 0;
</span></span></span><span class="line"><span class="cl"><span class="cm">}
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>说明与注意事项</strong></p>
<ol>
<li>
<p><strong>空间复杂度</strong>: O(N)，需要大约 4N 的空间来存储线段树数组 <code>tree</code>。这是因为满二叉树最后一层最多有 N 个叶子节点，总节点数大约是 2N−1，为了方便用 2p 和 2p+1 计算子节点索引，通常将数组开到 4N 以确保不会越界。</p>
</li>
<li>
<p>时间复杂度</p>
<p>:</p>
<ul>
<li><code>build</code>: O(N)</li>
<li><code>query</code>: O(logN)</li>
<li><code>update</code> (单点): O(logN)</li>
</ul>
</li>
<li>
<p><strong>下标</strong>: 模板假设原始数组和区间查询都使用<strong>1-based</strong>下标（从 1 开始）。如果使用 0-based（从 0 开始），<code>build</code> 的初始调用是 <code>build(1, 0, n-1)</code>，查询和更新的下标也要相应调整。叶子节点的条件是 <code>l == r</code>，其值是 <code>original_array[l]</code>（或 <code>original_array[r]</code>）。</p>
</li>
<li>
<p><strong>适应性</strong>: 这个模板非常通用。只需修改 <code>push_up</code> 函数中合并左右子节点信息的方式，以及 <code>query</code> 函数中合并左右子树查询结果和初始化 <code>result</code> 的方式，就可以适应不同的区间聚合操作（如求最大/最小值、区间异或和等）。</p>
</li>
<li>
<p><strong>区间更新</strong>: 这个基础模板不支持高效的<strong>区间更新</strong>（例如将区间 <code>[L, R]</code> 内所有元素增加 <code>v</code>）。要实现 O(logN)的区间更新，需要引入<strong>懒惰标记 (Lazy Propagation)</strong> 技术，这会使模板稍微复杂一些。</p>
</li>
<li>
<p><strong>数据类型</strong>: 注意使用 <code>long long</code> (或合适的类型) 来存储聚合结果（如 <code>tree</code> 数组），以防止计算过程中（特别是求和）发生整数溢出。</p>
</li>
</ol>
<h2 id="动态开点线段树">动态开点线段树
</h2><p>好的，我们来总结一下<strong>动态开点线段树</strong>的 C++ 算法模板及其核心思想。</p>
<p><strong>核心思想</strong></p>
<p>动态开点线段树是为了解决<strong>坐标范围极大</strong>（例如 1 到 109 甚至更大）但<strong>实际操作次数相对较少</strong>（例如 105 次更新和查询）的问题。</p>
<p>标准的静态线段树需要开一个大小与坐标范围成正比（约 4×Range) 的数组来存储树节点，当范围很大时，这会消耗巨大的内存，且大部分空间是浪费的（因为只有少量位置被实际访问或更新）。</p>
<p>动态开点线段树的核心思想是：<strong>不预先构建完整的树，而是在执行操作（更新或查询）需要访问某个节点时，如果该节点不存在，则动态地创建它</strong>。</p>
<ol>
<li><strong>节点表示</strong>: 不再使用数组下标隐式表示树结构，而是使用<strong>指针</strong>（或对象池中的索引）显式地连接父子节点。每个节点通常存储其代表区间的聚合值以及指向左右子节点的指针（初始为 <code>nullptr</code>）。</li>
<li><strong>按需创建</strong>: 只有当 <code>update</code> 或 <code>query</code> 操作递归到需要访问某个子节点，而该子节点的指针为 <code>nullptr</code> 时，才创建一个新的节点，并将其连接到父节点上。</li>
<li><strong>空间效率</strong>: 只会创建实际被访问或更新路径上的节点。空间复杂度与操作次数 M 和区间范围 R 的对数相关，通常为 O(MlogR)，远小于静态树的 O(R)。</li>
<li><strong>时间效率</strong>: 单次查询和更新的时间复杂度仍然是 O(logR)，与静态树类似，但可能因为指针访问和动态内存分配（如果不使用对象池）带来稍大的常数开销。</li>
</ol>
<p><strong>C++ 模板 (以区间求和、单点更新为例)</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"> </span><span class="c1">// 包含 std::midpoint (C++20)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用 long long 避免求和溢出，同时用于存储节点值和坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">ll</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 节点结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// 指向左子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// 指向右子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 节点存储的值 (例如区间和)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 可选：构造函数初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="p">()</span> <span class="o">:</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DynamicSegmentTree</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>           <span class="c1">// 树的根节点指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="n">range_l</span><span class="p">,</span> <span class="n">range_r</span><span class="p">;</span> <span class="c1">// 整个线段树能覆盖的最大范围 [range_l, range_r]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// --- 内部递归函数 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// push_up: 用子节点信息更新父节点信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// p: 当前节点指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_up</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 如果节点为空，则不操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 重置父节点值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 求最值等操作类似调整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// update_recursive: 递归执行单点更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// p_ref: 当前节点指针的引用 (因为可能需要创建新节点并修改指针)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// l, r: 当前节点代表的区间 [l, r]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// index: 需要更新的原始坐标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// val: 更新的增量 (或新值，取决于实现)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">update_recursive</span><span class="p">(</span><span class="n">Node</span> <span class="o">*&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">ll</span> <span class="n">l</span><span class="p">,</span> <span class="n">ll</span> <span class="n">r</span><span class="p">,</span> <span class="n">ll</span> <span class="n">index</span><span class="p">,</span> <span class="n">ll</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 如果节点不存在，动态创建
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span> <span class="c1">// 或者从对象池分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 到达叶子节点 (代表单个坐标)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// 或者 p-&gt;value = val，取决于更新是增量还是赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 递归更新子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// C++20: ll mid = std::midpoint(l, r);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ll</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 使用 ll 防止中点计算溢出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">update_recursive</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">update_recursive</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 回溯时更新当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">push_up</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// query_recursive: 递归执行区间查询
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// p: 当前节点指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// l, r: 当前节点代表的区间 [l, r]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// query_l, query_r: 需要查询的区间范围 [query_l, query_r]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="nf">query_recursive</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">ll</span> <span class="n">l</span><span class="p">,</span> <span class="n">ll</span> <span class="n">r</span><span class="p">,</span> <span class="n">ll</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">ll</span> <span class="n">query_r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 如果节点不存在，说明这部分区间没有被更新过，返回贡献为0 (或最值的单位元)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 求和的单位元是0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 当前区间完全包含在查询区间内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">query_r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 递归查询子节点并合并结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// C++20: ll mid = std::midpoint(l, r);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ll</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ll</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始化结果 (求和为0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">query_recursive</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">query_r</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">result</span> <span class="o">+=</span> <span class="n">query_recursive</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 可选: 递归删除节点，释放内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">destroy_tree</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">destroy_tree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">destroy_tree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造函数，指定线段树能覆盖的最大范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DynamicSegmentTree</span><span class="p">(</span><span class="n">ll</span> <span class="n">l</span><span class="p">,</span> <span class="n">ll</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">root</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">range_l</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">range_r</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 公共接口：单点更新
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// index: 更新的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// value: 更新的值 (增量或新值)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">ll</span> <span class="n">index</span><span class="p">,</span> <span class="n">ll</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">update_recursive</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">range_l</span><span class="p">,</span> <span class="n">range_r</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 公共接口：区间查询
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// query_l, query_r: 查询的区间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ll</span> <span class="nf">query</span><span class="p">(</span><span class="n">ll</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">ll</span> <span class="n">query_r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 可以加一些边界检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&gt;</span> <span class="n">query_r</span> <span class="o">||</span> <span class="n">query_l</span> <span class="o">&gt;</span> <span class="n">range_r</span> <span class="o">||</span> <span class="n">query_r</span> <span class="o">&lt;</span> <span class="n">range_l</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 无效查询返回0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">query_l</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">query_l</span><span class="p">,</span> <span class="n">range_l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">query_r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">query_r</span><span class="p">,</span> <span class="n">range_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">query_recursive</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">range_l</span><span class="p">,</span> <span class="n">range_r</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 可选: 析构函数，释放所有动态分配的节点内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">~</span><span class="n">DynamicSegmentTree</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// destroy_tree(root);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="c1">// 注意：如果使用对象池，析构逻辑会不同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 使用示例 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">int main() {
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 定义一个能处理坐标范围 [1, 10^9] 的动态开点线段树
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll min_coord = 1;
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll max_coord = 1000000000;
</span></span></span><span class="line"><span class="cl"><span class="cm">    DynamicSegmentTree dst(min_coord, max_coord);
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 更新点 100 的值为 5 (假设是增量更新)
</span></span></span><span class="line"><span class="cl"><span class="cm">    dst.update(100, 5);
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 更新点 200 的值为 10
</span></span></span><span class="line"><span class="cl"><span class="cm">    dst.update(200, 10);
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 更新点 10^9 的值为 7
</span></span></span><span class="line"><span class="cl"><span class="cm">    dst.update(max_coord, 7);
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 查询区间 [50, 250] 的和
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll sum1 = dst.query(50, 250);
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;Sum of [50, 250] is &#34; &lt;&lt; sum1 &lt;&lt; std::endl; // 应为 5 + 10 = 15
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 查询区间 [150, 10^9] 的和
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll sum2 = dst.query(150, max_coord);
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;Sum of [150, 10^9] is &#34; &lt;&lt; sum2 &lt;&lt; std::endl; // 应为 10 + 7 = 17
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    // 查询整个范围的和
</span></span></span><span class="line"><span class="cl"><span class="cm">    ll sum_total = dst.query(min_coord, max_coord);
</span></span></span><span class="line"><span class="cl"><span class="cm">     std::cout &lt;&lt; &#34;Sum of [&#34; &lt;&lt; min_coord &lt;&lt; &#34;, &#34; &lt;&lt; max_coord &lt;&lt; &#34;] is &#34; &lt;&lt; sum_total &lt;&lt; std::endl; // 应为 5 + 10 + 7 = 22
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    return 0;
</span></span></span><span class="line"><span class="cl"><span class="cm">}
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>区间最大值的动态开点线段树：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// 指向左子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// 指向右子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">lazy</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>        <span class="c1">// 节点存储的值 (例如区间和)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">boundry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">building</span><span class="p">:</span><span class="n">buildings</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">boundry</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">building</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">boundry</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">building</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">discrete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">b</span><span class="p">:</span><span class="n">boundry</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">discrete</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">=</span><span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="o">=</span><span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">building</span><span class="p">:</span><span class="n">buildings</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="n">discrete</span><span class="p">[</span><span class="n">building</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">discrete</span><span class="p">[</span><span class="n">building</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">update_interval</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">discrete</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">building</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pre_height</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">b</span><span class="p">:</span><span class="n">boundry</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="n">discrete</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">height</span><span class="o">=</span><span class="n">query</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">discrete</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">height</span><span class="o">!=</span><span class="n">pre_height</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">pre_height</span><span class="o">=</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">b</span><span class="p">,</span><span class="n">height</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">update_interval</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">curleft</span><span class="p">,</span><span class="kt">int</span> <span class="n">curright</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">=</span><span class="n">curleft</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">=</span><span class="n">curright</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">((</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">curleft</span><span class="o">&amp;&amp;</span><span class="n">r</span><span class="o">&gt;=</span><span class="n">curright</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">spread</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="n">curleft</span><span class="o">+</span><span class="p">(</span><span class="n">curright</span><span class="o">-</span><span class="n">curleft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">update_interval</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="n">curleft</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;</span><span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">update_interval</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">curright</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">spread</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">=</span><span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">)</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="o">=</span><span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">lazy</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">curleft</span><span class="p">,</span><span class="kt">int</span> <span class="n">curright</span><span class="p">,</span><span class="kt">int</span> <span class="n">idx</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">curleft</span><span class="o">==</span><span class="n">curright</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">spread</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="n">curleft</span><span class="o">+</span><span class="p">(</span><span class="n">curright</span><span class="o">-</span><span class="n">curleft</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">idx</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="n">curleft</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">curright</span><span class="p">,</span><span class="n">idx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>==在使用线段树的时候，所谓的区间并不只是代表着真实的数值阈值的区间，还有离散化后的区间值。这样子就可以将原先的跨度很大的区间变成一个跨度小的离散化区间问题。==</p>
<p><strong>说明与注意事项</strong></p>
<ol>
<li><strong>指针与内存管理</strong>: 使用裸指针 <code>new Node()</code> 需要注意内存泄漏。在实际应用或竞赛中，如果操作次数有限，可以不写析构函数（程序结束时内存会自动释放）。对于需要反复创建销毁或长时间运行的场景，<strong>内存池 (Node Pool)</strong> 是更好的选择，即预先分配一个大数组 <code>Node pool[MAX_NODES]</code> 和一个计数器 <code>node_count</code>，每次需要新节点时返回 <code>&amp;pool[node_count++]</code>，避免了 <code>new</code> 的开销和内存碎片，也简化了内存管理。</li>
<li><strong>递归参数</strong>: 递归函数需要传递当前节点代表的区间范围 <code>[l, r]</code>，因为节点本身不再隐式包含范围信息。</li>
<li><strong>空节点处理</strong>: 查询和更新函数必须正确处理遇到 <code>nullptr</code> 的情况，这代表该子区间从未被访问或更新过，其贡献通常是单位元（如求和为0，求最小值为无穷大）。</li>
<li><strong>坐标类型</strong>: 区间范围 <code>l, r</code> 以及 <code>index</code>, <code>query_l</code>, <code>query_r</code> 必须使用能容纳极大坐标范围的类型，通常是 <code>long long</code>。</li>
<li><strong>懒惰标记</strong>: 动态开点线段树同样可以支持<strong>区间更新</strong>和<strong>懒惰标记</strong>。实现方式与静态树类似，只是需要在递归下降创建节点时，同时考虑并下传懒惰标记。</li>
<li><strong>应用场景</strong>: 非常适合处理几何问题中的扫描线算法、维护值域信息等坐标范围很大但操作稀疏的场景。也常用于实现可持久化线段树（主席树）的基础结构。</li>
</ol>
<h2 id="并查集">并查集
</h2><p><strong>并查集 (Disjoint Set Union - DSU) 的核心理念</strong></p>
<p>并查集是一种用于处理<strong>不相交集合（Disjoint Sets）</strong> 的合并（Union）与查询（Find）问题的数据结构。想象一下，你有很多元素，一开始每个元素都独自属于一个集合。并查集主要支持两种操作：</p>
<ol>
<li><strong>Find (查找)</strong>：确定一个元素属于哪个集合。通常，每个集合都有一个唯一的“代表”（或者叫“根节点”）。<code>Find(x)</code> 操作就是找出元素 <code>x</code> 所在集合的代表。</li>
<li><strong>Union (合并)</strong>：将两个元素所在的集合合并成一个集合。如果元素 <code>x</code> 和 <code>y</code> 分别属于不同的集合，<code>Union(x, y)</code>操作会将这两个集合合并。</li>
</ol>
<p><strong>核心思想：用树形结构表示集合</strong></p>
<p>并查集的核心思想是用一个森林（多棵树）来表示这些集合。</p>
<ul>
<li><strong>每个集合是一棵树</strong>：树中的每个节点代表一个元素。</li>
<li><strong>树的根节点是集合的代表</strong>：同一个集合中的所有元素最终都属于以同一个根节点为代表的树。</li>
<li><strong>查找 (Find)</strong>：<code>Find(x)</code> 就是从元素 <code>x</code> 对应的节点开始，沿着父节点指针向上查找，直到找到根节点（即父节点是其自身的节点）。这个根节点就是 <code>x</code> 所在集合的代表。</li>
<li><strong>合并 (Union)</strong>：<code>Union(x, y)</code> 首先分别找到 <code>x</code> 和 <code>y</code> 的根节点 <code>rootX</code> 和 <code>rootY</code>。如果 <code>rootX</code> 和 <code>rootY</code> 不同（表示 <code>x</code> 和 <code>y</code> 不在同一个集合），就将其中一棵树的根节点指向另一棵树的根节点，从而将两棵树合并成一棵，也就是将两个集合合并成一个。例如，可以设置 <code>parent[rootX] = rootY</code>，表示将 <code>rootX</code> 代表的集合合并到 <code>rootY</code> 代表的集合中。</li>
</ul>
<p><strong>数据表示</strong></p>
<p>通常使用一个数组（例如 <code>parent</code> 或 <code>fa</code>）来存储这个森林结构：</p>
<ul>
<li><code>parent[i]</code> 存储元素 <code>i</code> 的父节点。</li>
<li>如果 <code>parent[i] == i</code>，则表示 <code>i</code> 是它所在集合（树）的根节点。</li>
</ul>
<p><strong>初始化</strong></p>
<p>一开始，每个元素都是一个独立的集合，所以每个元素都是它自己的根节点：</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for (int i = 0; i &lt; n; ++i) { // 假设有 n 个元素，索引从 0 到 n-1
</span></span><span class="line"><span class="cl">    parent[i] = i;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>优化</strong></p>
<p>朴素的实现方式在极端情况下可能导致树退化成链表，使得 <code>Find</code> 操作的时间复杂度达到 O(n)。为了提高效率，通常会采用两种重要的优化技巧：</p>
<ol>
<li>
<p><strong>路径压缩 (Path Compression)</strong>：</p>
<ul>
<li><strong>思想</strong>：在执行 <code>Find(x)</code> 操作，从 <code>x</code> 向上查找根节点的过程中，将路径上经过的所有节点都直接指向根节点。</li>
<li><strong>效果</strong>：大大减少树的高度，使得后续对这些节点的查找操作变得非常快（接近 O(1)）。</li>
<li><strong>实现</strong>：在 <code>Find</code> 函数的递归返回过程中，更新路径上节点的 <code>parent</code> 值。</li>
</ul>
</li>
<li>
<p><strong>按秩合并 (Union by Rank) 或 按大小合并 (Union by Size)</strong>：</p>
<ul>
<li>
<p>思想</p>
<p>：在执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Union(x, y)
</span></span></code></pre></td></tr></table>
</div>
</div><p>操作时，不是随意地将一棵树连接到另一棵树上，而是根据一些启发式规则来决定合并方向，以保持树的平衡，防止树的高度过高。</p>
<ul>
<li><strong>按秩合并</strong>：记录每棵树的“秩”（rank），通常是树的高度的一个上界。合并时，将秩较小的树的根节点指向秩较大的树的根节点。如果秩相同，则任选一个根节点指向另一个，并将后者的秩加 1。</li>
<li><strong>按大小合并</strong>：记录每个集合（以根节点为代表）的大小（包含的元素数量）。合并时，将元素数量较少的集合的根节点指向元素数量较多的集合的根节点，并更新后者的集合大小。</li>
</ul>
</li>
<li>
<p><strong>效果</strong>：有效地控制了树的高度或大小，与路径压缩结合使用效果更佳。实践中，“按大小合并”通常实现更简单且效果同样出色。</p>
</li>
</ul>
</li>
</ol>
<p><strong>时间复杂度</strong></p>
<p>同时使用路径压缩和按秩/大小合并优化后，并查集的 <code>Find</code> 和 <code>Union</code> 操作的<strong>均摊时间复杂度</strong>可以达到接近常数级别，严格来说是 O(α(n))，其中 α(n) 是反阿克曼函数。α(n) 的增长速度极其缓慢，对于所有实际可能的 n 值，α(n) 都不会超过 5，因此可以认为其效率非常接近 O(1)。</p>
<p><strong>C++ 模板实现 (使用路径压缩和按大小合并)</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"> </span><span class="c1">// 为了 std::iota
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DSU</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// 存储每个元素的父节点，根节点的父节点是其自身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">set_size</span><span class="p">;</span> <span class="c1">// 存储以该节点为根的集合的大小（仅根节点有效）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造函数：初始化 n 个元素，每个元素自成一个集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 元素编号从 0 到 n-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DSU</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">parent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">set_size</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 初始化父节点数组，每个元素的父节点是它自己
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// std::iota(parent.begin(), parent.end(), 0); // 等价于下面的循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Find 操作：查找元素 x 所在集合的代表（根节点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 同时进行路径压缩优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 x 不是根节点 (parent[x] != x)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 递归查找根节点，并将 x 的父节点直接更新为根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span> <span class="c1">// 路径压缩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Union 操作：合并元素 x 和元素 y 所在的集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 使用按大小合并优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 返回 true 如果成功合并 (x 和 y 原本不在同一集合)，否则返回 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 找到 x 和 y 的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rootX</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rootY</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果根节点相同，说明 x 和 y 已经在同一个集合中，无需合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">rootX</span> <span class="o">==</span> <span class="n">rootY</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 按大小合并：将小集合合并到大集合中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">set_size</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">set_size</span><span class="p">[</span><span class="n">rootY</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 交换 rootX 和 rootY，保证 rootX 是较大（或等大）集合的根
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">rootX</span><span class="p">,</span> <span class="n">rootY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 将小集合 (rootY) 的根指向大集合 (rootX) 的根
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新大集合的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">set_size</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">+=</span> <span class="n">set_size</span><span class="p">[</span><span class="n">rootY</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// set_size[rootY] 的值不再需要，可以不清零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 合并成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查两个元素是否在同一个集合中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">is_same_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取元素 x 所在集合的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="nf">get_set_size</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 找到 x 所在集合的根节点，返回该根节点记录的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">set_size</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// --- 示例用法 ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 假设有 10 个元素 (0 到 9)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DSU</span> <span class="n">dsu</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 合并 {0, 1} 和 {2, 3} =&gt; {0, 1, 2, 3}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span> <span class="c1">// 合并 {5, 6} 和 {9} =&gt; {5, 6, 9}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Is 1 and 3 in the same set? &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">dsu</span><span class="p">.</span><span class="n">is_same_set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span> <span class="s">&#34;Yes&#34;</span> <span class="o">:</span> <span class="s">&#34;No&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 Yes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Is 1 and 5 in the same set? &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">dsu</span><span class="p">.</span><span class="n">is_same_set</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="s">&#34;Yes&#34;</span> <span class="o">:</span> <span class="s">&#34;No&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 No
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Find(3): Representative is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dsu</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出可能是 0 或 2 (取决于合并顺序和路径压缩情况)，但 find(0), find(1), find(2), find(3) 结果会相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Size of set containing 3: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dsu</span><span class="p">.</span><span class="n">get_set_size</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Size of set containing 9: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dsu</span><span class="p">.</span><span class="n">get_set_size</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 尝试合并已经在同一集合的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">merged</span> <span class="o">=</span> <span class="n">dsu</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Tried merging 1 and 3 again. Merged? &#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">merged</span> <span class="o">?</span> <span class="s">&#34;Yes&#34;</span> <span class="o">:</span> <span class="s">&#34;No&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 No
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>总结</strong></p>
<p>并查集是一种非常高效的处理集合合并与查询问题的数据结构。其核心在于用树（森林）表示集合，并通过<strong>路径压缩</strong>和<strong>按秩/大小合并</strong>两种优化手段，使得基本操作的均摊时间复杂度接近常数。它在图论（如 Kruskal 算法求最小生成树、判断连通性）、算法竞赛以及其他需要动态维护元素分组关系的场景中应用广泛。上面提供的 C++ 模板是一个标准且高效的实现。</p>
<h2 id="位运算">位运算
</h2><p><img src="/huyang/assets/image-20250424184205086.png"
	
	
	
	loading="lazy"
	
		alt="image-20250424184205086"
	
	
></p>
<h2 id="数据结构">数据结构
</h2><p><img src="/huyang/assets/image-20250424191230113.png"
	
	
	
	loading="lazy"
	
		alt="image-20250424191230113"
	
	
></p>
<p><img src="/huyang/assets/image-20250424191244136.png"
	
	
	
	loading="lazy"
	
		alt="image-20250424191244136"
	
	
></p>
<p><img src="/huyang/assets/image-20250424191255776.png"
	
	
	
	loading="lazy"
	
		alt="image-20250424191255776"
	
	
></p>
<p><img src="/huyang/assets/image-20250424191306194.png"
	
	
	
	loading="lazy"
	
		alt="image-20250424191306194"
	
	
></p>
<p><img src="/huyang/assets/image-20250424191319448.png"
	
	
	
	loading="lazy"
	
		alt="image-20250424191319448"
	
	
></p>
<h2 id="单调栈">单调栈
</h2><p>好的，我们来详细讲解一下 C++ 中的<strong>单调栈 (Monotonic Stack)</strong>。我会假设你之前没有接触过这个概念。</p>
<p><strong>1. 什么是栈 (Stack)？</strong></p>
<p>在讲单调栈之前，我们先快速回顾一下什么是“栈”。想象一摞盘子，你只能在最上面放盘子，也只能从最上面拿走盘子。这就是栈的核心特点：<strong>后进先出 (Last-In, First-Out, LIFO)</strong>。</p>
<p>在 C++ 中，我们通常使用 <code>&lt;stack&gt;</code> 库提供的 <code>std::stack</code> 容器来实现栈。它主要有以下操作：</p>
<ul>
<li><code>push(element)</code>: 将元素压入栈顶。</li>
<li><code>pop()</code>: 移除栈顶元素。</li>
<li><code>top()</code>: 查看栈顶元素（不移除）。</li>
<li><code>empty()</code>: 检查栈是否为空。</li>
<li><code>size()</code>: 获取栈中元素的数量。</li>
</ul>
<p><strong>2. 什么是单调栈 (Monotonic Stack)？</strong></p>
<p>单调栈是一种特殊的栈，它在存储元素时，<strong>始终保持栈内元素的单调性</strong>。也就是说，从栈底到栈顶，元素要么是**单调不减（递增）<strong>的，要么是</strong>单调不增（递减）**的。</p>
<ul>
<li><strong>单调递增栈 (Monotonically Increasing Stack):</strong> 从栈底到栈顶，元素的值是非递减的（例如：<code>[1, 3, 3, 5, 8]</code>）。</li>
<li><strong>单调递减栈 (Monotonically Decreasing Stack):</strong> 从栈底到栈顶，元素的值是非递增的（例如：<code>[9, 6, 6, 4, 2]</code>）。</li>
</ul>
<p><strong>关键点：</strong> 单调性是在<strong>元素入栈时</strong>通过一系列操作来维护的，而不是说栈里的元素自始至终都完全保持单调（因为会有出栈操作）。</p>
<p><strong>3. 单调栈的核心思想与操作</strong></p>
<p>单调栈最核心的作用是：<strong>高效地找到一个元素左边或右边第一个比它大（或小）的元素</strong>。</p>
<p>它的操作逻辑如下（以<strong>单调递增栈</strong>为例，找右边第一个更小的元素）：</p>
<p>假设我们有一个数组 <code>nums</code>，我们要为数组中的每个元素 <code>nums[i]</code> 找到它右边第一个比它小的元素。我们维护一个单调递增栈，里面存储的是元素的<strong>下标 (index)</strong>（存储下标通常比存储值更方便，因为可以通过下标访问原值，并且可以计算距离）。</p>
<p>我们从左到右遍历数组 <code>nums</code> 中的每个元素 <code>nums[i]</code>：</p>
<ol>
<li><strong>检查栈顶：</strong> 查看当前栈顶的下标 <code>stk.top()</code> 对应的元素 <code>nums[stk.top()]</code>。</li>
<li>维护单调性 (关键步骤):
<ul>
<li><strong>如果栈不为空，并且栈顶元素 <code>nums[stk.top()]</code> 大于 当前元素 <code>nums[i]</code>:</strong> 这意味着，对于栈顶下标 <code>stk.top()</code> 对应的元素来说，我们找到了它右边第一个比它小的元素，那就是当前元素 <code>nums[i]</code>。</li>
<li>我们记录下这个结果（比如，<code>result[stk.top()] = nums[i]</code> 或 <code>result[stk.top()] = i</code>）。</li>
<li>然后，<strong>将栈顶元素弹出 <code>stk.pop()</code></strong>。</li>
<li><strong>重复</strong>这个过程，继续比较新的栈顶元素和 <code>nums[i]</code>，直到栈为空或者栈顶元素小于等于 <code>nums[i]</code>。</li>
</ul>
</li>
<li><strong>入栈：</strong> 当栈为空或者栈顶元素小于等于 <code>nums[i]</code> 时，说明 <code>nums[i]</code> 不会破坏栈的单调递增性（或者前面破坏单调性的元素都被弹出了），此时将<strong>当前元素的下标 <code>i</code> 压入栈中 <code>stk.push(i)</code></strong>。</li>
</ol>
<p>遍历完整个数组后，栈中可能还会剩下一些元素的下标，这些元素右边没有比它们更小的元素。</p>
<p>类似地，对于单调递减栈（找右边第一个更大的元素）：</p>
<p>当栈不为空且栈顶元素 nums[stk.top()] 小于 当前元素 nums[i] 时，nums[i] 就是 nums[stk.top()] 右边第一个更大的元素。记录结果，弹出栈顶，重复此过程，最后将 i 压栈。</p>
<p><strong>4. 为什么单调栈是 O(N) 的？</strong></p>
<p>虽然看起来有嵌套循环（外层 <code>for</code> 遍历数组，内层 <code>while</code> 弹出栈元素），但每个元素的下标最多只会<strong>入栈一次</strong>和<strong>出栈一次</strong>。所以，总的操作次数与数组元素的数量 N 成线性关系，时间复杂度是 <strong>O(N)</strong>。空间复杂度在最坏情况下也是 <strong>O(N)</strong>（比如输入数组本身就是单调的）。</p>
<p><strong>5. C++ 实现示例：找到下一个更大的元素 (Next Greater Element - NGE)</strong></p>
<p><strong>问题描述：</strong> 给定一个数组 <code>nums</code>，返回一个等长的数组 <code>result</code>，其中 <code>result[i]</code> 是 <code>nums[i]</code> 右侧第一个比它大的元素的值。如果不存在，则为 -1。</p>
<p><strong>思路：</strong> 我们需要找右边第一个<strong>更大</strong>的元素，所以使用<strong>单调递减栈</strong>。栈中存储<strong>下标</strong>。</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> </span><span class="c1">// 确保 vector 被包含
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nextGreaterElement</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 初始化结果数组，默认值为 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span> <span class="c1">// 单调递减栈，存储下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 维护单调递减：当栈不空且当前元素大于栈顶元素时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">()])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前元素 nums[i] 就是栈顶元素 nums[stk.top()] 的下一个更大元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">()]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="c1">// 弹出栈顶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将当前元素的下标压入栈中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 循环结束后，栈中剩余的下标表示右边没有更大的元素，它们的结果保持为 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 新加坡当前时间是周四晚上，正好适合学习算法 :)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nge</span> <span class="o">=</span> <span class="n">nextGreaterElement</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Original array: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出: Original array: 2 1 2 4 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Next Greater Element: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">nge</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出: Next Greater Element: 4 2 4 -1 -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>代码解释:</strong></p>
<ol>
<li>
<p>初始化结果数组 <code>result</code> 全为 -1。</p>
</li>
<li>
<p>创建 <code>std::stack&lt;int&gt; stk</code> 用于存储下标。</p>
</li>
<li>
<p>遍历输入数组 <code>nums</code> (下标 <code>i</code> 从 0 到 <code>n-1</code>)。</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while
</span></span></code></pre></td></tr></table>
</div>
</div><p>循环检查：</p>
<ul>
<li>栈 <code>stk</code> 不为空。</li>
<li>当前元素 <code>nums[i]</code> <strong>大于</strong> 栈顶下标对应的元素 <code>nums[stk.top()]</code>。</li>
<li>如果条件满足，说明 <code>nums[i]</code> 是 <code>nums[stk.top()]</code> 的 NGE，将结果记录在 <code>result[stk.top()]</code>，并将栈顶下标弹出。</li>
</ul>
</li>
<li>
<p><code>while</code> 循环结束后，将当前元素的下标 <code>i</code> 压入栈 <code>stk.push(i)</code>，维持栈的（可能被破坏后修复的）单调递减性。</p>
</li>
<li>
<p>遍历结束后，栈内剩余元素的 NGE 就是默认的 -1。</p>
</li>
</ol>
<p><strong>6. 其他常见应用场景</strong></p>
<p>单调栈除了找下一个更大/更小元素外，还常用于解决以下问题：</p>
<ul>
<li><strong>上一个更大/更小元素 (Previous Greater/Smaller Element):</strong> 只需从右往左遍历数组即可。</li>
<li><strong>柱状图中最大的矩形 (Largest Rectangle in Histogram):</strong> 通过两次单调栈（或一次更优化的处理）找到每个柱子左右两边第一个比它矮的柱子，从而确定以该柱子为高度的最大矩形面积。</li>
<li><strong>接雨水 (Trapping Rain Water):</strong> 单调栈（通常是递减栈）可以用来找到能够存储雨水的“凹槽”边界。</li>
<li><strong>子数组范围查询:</strong> 求解所有子数组的最小值之和/最大值之和等问题。单调栈可以确定每个元素作为最小值/最大值能影响到的左右边界。</li>
</ul>
<p><strong>总结:</strong></p>
<p>单调栈是一种巧妙的数据结构，通过在栈中维护元素的单调性，可以在 O(N) 的时间复杂度内解决一系列“寻找下一个/上一个更大/更小元素”类型的问题。它的核心在于<strong>入栈时通过弹出破坏单调性的元素来找到对应元素的答案，并最终维护栈的单调性</strong>。在 C++ 中，通常使用 <code>std::stack</code> 存储<strong>下标</strong>来实现。</p>
<h2 id="最大堆最小堆">最大堆/最小堆
</h2><p>好的，没问题！在 C++ 中使用 <code>std::priority_queue</code> 来为自定义的数据结构（比如你自己定义的 <code>struct</code> 或 <code>class</code>）实现最大堆和最小堆，关键在于<strong>如何告诉 <code>priority_queue</code> 怎样比较你的自定义对象的大小（优先级）</strong>。</p>
<p><code>std::priority_queue</code> 的模板定义大致如下：</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;
</span></span><span class="line"><span class="cl">    class T, // 存储的元素类型 (你的自定义结构体)
</span></span><span class="line"><span class="cl">    class Container = std::vector&lt;T&gt;, // 底层使用的容器 (默认是 vector)
</span></span><span class="line"><span class="cl">    class Compare = std::less&lt;typename Container::value_type&gt; // 比较函数对象 (决定是最大堆还是最小堆)
</span></span><span class="line"><span class="cl">&gt; class priority_queue;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们需要关注的就是 <code>T</code>（你的自定义类型）和 <code>Compare</code>（比较方式）。</p>
<p>默认情况下，<code>Compare</code> 是 <code>std::less&lt;T&gt;</code>。<code>std::less&lt;T&gt;</code> 会使用你为类型 <code>T</code> 定义的 <code>operator&lt;</code>（小于号操作符）。<code>std::priority_queue</code> 使用这个比较器，默认行为是把**“最大”<strong>（按照 <code>std::less</code> 的标准，即 <code>a &lt; b</code> 最不成立的那个）的元素放在队首（<code>top()</code>）。因此，默认是</strong>最大堆**。</p>
<blockquote>
<p>[!NOTE]</p>
<p>对于已知大小的tuple来说可以这样子定义最小堆：</p>
<p>Priority_queue&lt;tuple&lt;int,int&gt;,vector&lt;tuple&lt;int,int&raquo;,greater&lt;&raquo;pq;</p>
<p>解压缩的时候：</p>
<p>auto [i,j]=pq.top();</p></blockquote>
<p>要为自定义结构体实现最大堆和最小堆，主要有以下几种方法来定义比较逻辑：</p>
<p><strong>方法一：重载小于号 <code>operator&lt;</code></strong></p>
<p>这是最直接的方法，尤其适用于最大堆的默认行为。</p>
<ol>
<li>
<p><strong>定义你的结构体：</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 构造函数 (可选, 方便创建)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Task</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">priority</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 重载小于号 operator&lt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// **关键**: 定义什么是“小于”。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于最大堆（优先级高的在前），我们希望优先级低的 Task &#34;小于&#34; 优先级高的 Task。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果 this 的优先级 &lt; other 的优先级，则返回 true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 注意: C++ priority_queue 默认用 less 实现最大堆，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 它把“不小于”任何其他元素的元素（即最大的）放在 top。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以这里的 &lt; 定义了优先级低的排在后面。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>使用 <code>priority_queue</code> 实现最大堆：</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main_max_heap_op_lt</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 重命名 main 函数以避免冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 直接使用默认模板参数，它会寻找 Task::operator&lt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="n">max_heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">max_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#34;Low Priority Task&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&#34;High Priority Task&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="s">&#34;Medium Priority Task&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Max Heap (using operator&lt;):&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">max_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Task</span> <span class="n">top_task</span> <span class="o">=</span> <span class="n">max_heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  Priority: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, Name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">max_heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出会按优先级从高到低 (100, 50, 30)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>使用 <code>priority_queue</code> 实现最小堆 (基于 <code>operator&lt;</code>):</strong></p>
<p>如果你已经定义了 <code>operator&lt;</code>，实现最小堆最简单的方法是<strong>提供 <code>std::greater&lt;Task&gt;</code> 作为比较器</strong>。<code>std::greater&lt;Task&gt;</code> 内部会利用你定义的 <code>operator&lt;</code> 来实现“大于”的比较逻辑。</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"> </span><span class="c1">// 需要包含 &lt;functional&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main_min_heap_op_lt_greater</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 提供 std::greater&lt;Task&gt; 作为比较器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span> <span class="n">min_heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">min_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#34;Low Priority Task&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">min_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&#34;High Priority Task&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">min_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="s">&#34;Medium Priority Task&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Min Heap (using operator&lt; and std::greater):&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">min_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Task</span> <span class="n">top_task</span> <span class="o">=</span> <span class="n">min_heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  Priority: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, Name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">min_heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出会按优先级从低到高 (30, 50, 100)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>方法二：提供自定义比较函数对象 (Functor)</strong></p>
<p>当你不想（或不能）修改原始结构体来添加 <code>operator&lt;</code>，或者你需要多种不同的排序逻辑时，自定义比较函数对象（通常是一个重载了 <code>operator()</code> 的结构体）是更灵活的选择。</p>
<ol>
<li>
<p><strong>定义你的结构体 (无需 <code>operator&lt;</code>):</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// (可以复用上面定义的 Task 结构体，但这次假设它没有 operator&lt;)
</span></span><span class="line"><span class="cl">// struct Task { ... };
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>为最大堆定义比较器 (Functor):</strong></p>
<p>比较器 <code>comp(a, b)</code> 应该返回 <code>true</code> 如果 <code>a</code> 的优先级<strong>低于</strong> <code>b</code>。</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">CompareTaskMax</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果</span> <span class="n">a</span> <span class="err">的优先级</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="err">的优先级，则</span> <span class="n">a</span> <span class="err">的优先级较低，返回</span> <span class="bp">true</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>注意：这个逻辑和 <code>operator&lt;</code> 实现最大堆时的逻辑是一样的。</em></p>
</li>
<li>
<p><strong>使用自定义比较器实现最大堆：</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main_max_heap_functor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">CompareTaskMax</span><span class="o">&gt;</span> <span class="n">max_heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">max_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#34;Low&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&#34;High&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">max_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="s">&#34;Medium&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Max Heap (using custom functor):&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">max_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Task</span> <span class="n">top_task</span> <span class="o">=</span> <span class="n">max_heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  Priority: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, Name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">max_heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出按优先级从高到低 (100, 50, 30)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>为最小堆定义比较器 (Functor):</strong></p>
<p>比较器 <code>comp(a, b)</code> 应该返回 <code>true</code> 如果 <code>a</code> 的优先级<strong>低于</strong> <code>b</code>。对于最小堆（优先级低的在前），这意味着当 <code>a</code>的实际值（优先级）<strong>大于</strong> <code>b</code> 时，我们认为 <code>a</code> 的优先级较低（排在后面）。</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">CompareTaskMin</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="err">如果</span> <span class="n">a</span> <span class="err">的优先级</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="err">的优先级，则</span> <span class="n">a</span> <span class="err">的优先级较低（对于最小堆），返回</span> <span class="bp">true</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>注意：这个逻辑和 <code>operator&lt;</code> 实现最小堆时使用 <code>std::greater</code> 的效果是一样的，但这里是直接在比较器里定义了“大于”逻辑。</em></p>
</li>
<li>
<p><strong>使用自定义比较器实现最小堆：</strong></p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main_min_heap_functor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">CompareTaskMin</span><span class="o">&gt;</span> <span class="n">min_heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">min_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">&#34;Low&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">min_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="s">&#34;High&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">min_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">Task</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="s">&#34;Medium&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Min Heap (using custom functor):&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">min_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Task</span> <span class="n">top_task</span> <span class="o">=</span> <span class="n">min_heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  Priority: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">priority</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, Name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">top_task</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">min_heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出按优先级从低到高 (30, 50, 100)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p><strong>总结与选择:</strong></p>
<ul>
<li><strong>实现最大堆:</strong>
<ul>
<li><strong>方法1 (推荐):</strong> 在结构体中重载 <code>operator&lt;</code>，使其按值（优先级）比较（小的在前）。然后直接使用 <code>std::priority_queue&lt;MyStruct&gt;</code>。</li>
<li><strong>方法2:</strong> 定义一个比较器 <code>CompareMax</code>，其 <code>operator()</code> 逻辑与 <code>operator&lt;</code> 相同（<code>return a.value &lt; b.value;</code>），然后使用 <code>std::priority_queue&lt;MyStruct, std::vector&lt;MyStruct&gt;, CompareMax&gt;</code>。</li>
</ul>
</li>
<li><strong>实现最小堆:</strong>
<ul>
<li><strong>方法1 (推荐):</strong> 在结构体中重载 <code>operator&lt;</code>（按值比较，小的在前）。然后使用 <code>std::priority_queue&lt;MyStruct, std::vector&lt;MyStruct&gt;, std::greater&lt;MyStruct&gt;&gt;</code>。</li>
<li><strong>方法2:</strong> 定义一个比较器 <code>CompareMin</code>，其 <code>operator()</code> 逻辑与 <code>operator&lt;</code> 相反（<code>return a.value &gt; b.value;</code>），然后使用 <code>std::priority_queue&lt;MyStruct, std::vector&lt;MyStruct&gt;, CompareMin&gt;</code>。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践:</strong></p>
<ul>
<li>如果你的结构体有一个“自然”的、最常用的排序方式，那么重载 <code>operator&lt;</code> 是最方便的，因为它也便于在其他需要排序或比较的地方（如 <code>std::sort</code>, <code>std::map</code>）使用。</li>
<li>如果你需要多种不同的优先级定义，或者不想修改结构体本身，或者比较逻辑比较复杂，那么使用<strong>自定义比较函数对象 (Functor)</strong> 是更清晰、更灵活的选择。</li>
</ul>
<p>选择哪种方法取决于你的具体需求和代码风格偏好。这两种方法都能有效地为你的自定义数据结构实现最大堆和最小堆。</p>
<p><em>(你可以将上面示例中的 <code>main_...</code> 函数分别放到一个 C++ 文件中运行，记得包含必要的头文件。)</em></p>
<p>在一般的cpp的数据结构中是没有对于priority_queue的删除操作的，所以我们假如有在数据流中一直找到最大值或者是最小值并且需要删除一些值的时候，就可以使用lazy 删除，就是将已经删除的元素记录在一个set中，在查询的时候假如首位元素在set中，那么就pop然后再看下一个首位元素是否已经被删除。</p>
<h2 id="最短路径算法">最短路径算法
</h2><p>好的，我们来一个极简版的Dijkstra算法介绍和C++模板。</p>
<h3 id="dijkstra算法极简版">Dijkstra算法（极简版）
</h3><p>是什么？</p>
<p>Dijkstra算法用于找到图中一个点（起点）到其他所有点的最短路径。前提是图中边的权重不能是负数。</p>
<p>怎么做？</p>
<p>想象你站在起点：</p>
<ol>
<li><strong>初始化</strong>：记下起点到自己的距离是0，到其他所有点的距离是无穷大（表示暂时还不知道多远）。</li>
<li><strong>找最近的</strong>：从所有你还没去过（或者说还没最终确定最短距离）的点里，找到一个当前记录中离起点最近的点。</li>
<li><strong>标记并更新</strong>：标记这个点为“已去过”（最短距离已确定）。然后，看看通过这个刚标记的点，能不能让你到它的邻居点的路程变得更短。如果能，就更新到那个邻居点的距离。</li>
<li><strong>重复</strong>：一直重复第2步和第3步，直到所有点都被标记为“已去过”，或者剩下的点都到不了。</li>
</ol>
<p><strong>核心思想</strong>：每一步都选“看起来最近”的点，并用它来尝试更新到其他点的路径，是一种贪心的方法。</p>
<p>最简C++算法模板 (邻接矩阵，O(V^2))</p>
<p>这个模板使用<strong>邻接矩阵</strong>来表示图，并且通过遍历查找下一个最近的节点，而不是使用优先队列。对于节点数量较少的情况，或者理解算法核心逻辑，这种方式更直接。</p>
<p>C++</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"> </span><span class="c1">// 用于 std::numeric_limits
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span> <span class="c1">// 定义无穷大
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// n: 节点数量 (节点编号从0到n-1)
</span></span></span><span class="line"><span class="cl"><span class="c1">// start_node: 源点
</span></span></span><span class="line"><span class="cl"><span class="c1">// graph: 邻接矩阵，graph[i][j] 是从节点i到节点j的边的权重，如果不存在边则为INF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dijkstra_simple</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_node</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>      <span class="c1">// 从源点到各个节点的最短距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">// 记录节点是否已经确定最短路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 源点到自身的距离为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 从未访问的节点中找到距离最小的节点 u
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">min_dist</span> <span class="o">=</span> <span class="n">INF</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v_node</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v_node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">u</span> <span class="o">=</span> <span class="n">v_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果找不到下一个可达的未访问节点，则结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 标记节点 u 为已访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 更新 u 的所有邻居节点的距离
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v_node</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v_node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v_node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v_node</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">v_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v_node</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 示例：5个节点，节点编号 0 到 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 邻接矩阵表示图的权重
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// graph[i][j] = 权重，如果 i 和 j 之间没有直接边，则为 INF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj_matrix</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>  <span class="c1">// 从节点0出发的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span><span class="n">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">INF</span><span class="p">},</span> <span class="c1">// 从节点1出发的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span><span class="n">INF</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>  <span class="c1">// 从节点2出发的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span><span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="c1">// 从节点3出发的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">{</span><span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="n">INF</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>   <span class="c1">// 从节点4出发的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果是没有直接连接，可以用 INF 初始化，对角线是0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 例如，如果节点0和节点2没有直接边，则 adj_matrix[0][2] = INF;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设定一个实际的图 (注意：Dijkstra不处理负权边)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 对于上面的邻接矩阵示例，我们手动设置一些边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0-&gt;4 (3), 0-&gt;1 (10)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1-&gt;2 (1), 1-&gt;3 (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2-&gt;1 (4), 2-&gt;4 (2), 2-&gt;3 (8)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4-&gt; (无出边，或者到自身为0)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3-&gt;4 (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">start_node</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 以节点0为源点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shortest_paths</span> <span class="o">=</span> <span class="n">dijkstra_simple</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">start_node</span><span class="p">,</span> <span class="n">adj_matrix</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;从源点 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">start_node</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 到各节点的最短路径长度:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;到节点 &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;无法到达&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    预期输出 (基于上面的 adj_matrix 和 start_node = 0):
</span></span></span><span class="line"><span class="cl"><span class="cm">    从源点 0 到各节点的最短路径长度:
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 0: 0
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 1: 7  (路径 0-&gt;4-&gt;2-&gt;1: 3+2+4 = 9; 或者 0-&gt;4-&gt;2(inf)-&gt;1, 0-&gt;1 (10), 0-&gt;4-&gt;2 (5)-&gt;1 (4) = 9)
</span></span></span><span class="line"><span class="cl"><span class="cm">                (路径 0-&gt;4 (3) -&gt; 2 (2) = 5. dist[2]=5. 2-&gt;1(4). dist[1] = 5+4=9)
</span></span></span><span class="line"><span class="cl"><span class="cm">                (路径 0-&gt;1 (10). dist[1]=10)
</span></span></span><span class="line"><span class="cl"><span class="cm">                (实际上: 0-&gt;4 (3), dist[4]=3.
</span></span></span><span class="line"><span class="cl"><span class="cm">                         next u = 4. visited[4]=true.
</span></span></span><span class="line"><span class="cl"><span class="cm">                         dist[0]=0.
</span></span></span><span class="line"><span class="cl"><span class="cm">                         next u = 0. visited[0]=true.
</span></span></span><span class="line"><span class="cl"><span class="cm">                         dist[4] = min(INF, dist[0]+adj[0][4]=0+3=3)
</span></span></span><span class="line"><span class="cl"><span class="cm">                         dist[1] = min(INF, dist[0]+adj[0][1]=0+10=10)
</span></span></span><span class="line"><span class="cl"><span class="cm">                         next u = 4 (dist[4]=3). visited[4]=true. (no outgoing from 4 in example, update for 2-&gt;4 etc.)
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    让我们重新构建一个更清晰的示例图，并手算一遍：
</span></span></span><span class="line"><span class="cl"><span class="cm">    Graph:
</span></span></span><span class="line"><span class="cl"><span class="cm">    0 -&gt; 1 (10)
</span></span></span><span class="line"><span class="cl"><span class="cm">    0 -&gt; 4 (3)
</span></span></span><span class="line"><span class="cl"><span class="cm">    1 -&gt; 2 (1)
</span></span></span><span class="line"><span class="cl"><span class="cm">    1 -&gt; 3 (2)
</span></span></span><span class="line"><span class="cl"><span class="cm">    2 -&gt; 4 (2)  (注意这里，可以从2回到4)
</span></span></span><span class="line"><span class="cl"><span class="cm">    4 -&gt; 1 (7)  (0-&gt;4-&gt;1 is 3+7=10)
</span></span></span><span class="line"><span class="cl"><span class="cm">    4 -&gt; 2 (5)  (0-&gt;4-&gt;2 is 3+5=8)
</span></span></span><span class="line"><span class="cl"><span class="cm">    4 -&gt; 3 (9)  (0-&gt;4-&gt;3 is 3+9=12)
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    adj_matrix = {
</span></span></span><span class="line"><span class="cl"><span class="cm">        {0,  10, INF, INF, 3  },
</span></span></span><span class="line"><span class="cl"><span class="cm">        {INF, 0,  1,   2,   INF},
</span></span></span><span class="line"><span class="cl"><span class="cm">        {INF,INF, 0,  INF, 2  },
</span></span></span><span class="line"><span class="cl"><span class="cm">        {INF,INF, INF, 0,   INF},
</span></span></span><span class="line"><span class="cl"><span class="cm">        {INF, 7,  5,   9,   0  }
</span></span></span><span class="line"><span class="cl"><span class="cm">    };
</span></span></span><span class="line"><span class="cl"><span class="cm">    start_node = 0;
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    Iteration 0: dist = [0, INF, INF, INF, INF], visited = [F,F,F,F,F]
</span></span></span><span class="line"><span class="cl"><span class="cm">    Iteration 1 (count=0):
</span></span></span><span class="line"><span class="cl"><span class="cm">        u = 0 (min_dist = 0)
</span></span></span><span class="line"><span class="cl"><span class="cm">        visited[0] = true
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[1] = min(INF, 0+10) = 10
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[4] = min(INF, 0+3)  = 3
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist = [0, 10, INF, INF, 3]
</span></span></span><span class="line"><span class="cl"><span class="cm">    Iteration 2 (count=1):
</span></span></span><span class="line"><span class="cl"><span class="cm">        u = 4 (min_dist = 3 from dist[4])
</span></span></span><span class="line"><span class="cl"><span class="cm">        visited[4] = true
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[1] = min(10, dist[4]+adj[4][1]=3+7) = 10
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[2] = min(INF, dist[4]+adj[4][2]=3+5) = 8
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[3] = min(INF, dist[4]+adj[4][3]=3+9) = 12
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist = [0, 10, 8, 12, 3]
</span></span></span><span class="line"><span class="cl"><span class="cm">    Iteration 3 (count=2):
</span></span></span><span class="line"><span class="cl"><span class="cm">        u = 2 (min_dist = 8 from dist[2])
</span></span></span><span class="line"><span class="cl"><span class="cm">        visited[2] = true
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[4] - already visited, adj[2][4]=2, dist[2]+adj[2][4] = 8+2=10 &gt; dist[4]=3. No change.
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist = [0, 10, 8, 12, 3]
</span></span></span><span class="line"><span class="cl"><span class="cm">    Iteration 4 (count=3):
</span></span></span><span class="line"><span class="cl"><span class="cm">        u = 1 (min_dist = 10 from dist[1])
</span></span></span><span class="line"><span class="cl"><span class="cm">        visited[1] = true
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[2] - already visited, adj[1][2]=1, dist[1]+adj[1][2] = 10+1=11 &gt; dist[2]=8. No change.
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist[3] = min(12, dist[1]+adj[1][3]=10+2) = 12
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist = [0, 10, 8, 12, 3]
</span></span></span><span class="line"><span class="cl"><span class="cm">    Iteration 5 (count=4):
</span></span></span><span class="line"><span class="cl"><span class="cm">        u = 3 (min_dist = 12 from dist[3])
</span></span></span><span class="line"><span class="cl"><span class="cm">        visited[3] = true
</span></span></span><span class="line"><span class="cl"><span class="cm">        dist = [0, 10, 8, 12, 3]
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    Output for this example:
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 0: 0
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 1: 10
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 2: 8
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 3: 12
</span></span></span><span class="line"><span class="cl"><span class="cm">    到节点 4: 3
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>模板解释 (极简版):</strong></p>
<ol>
<li><strong><code>INF</code></strong>: 一个很大的数，代表无限远。</li>
<li><strong><code>dist</code> 数组</strong>: <code>dist[i]</code> 存的是从起点到节点 <code>i</code> 的当前已知最短距离。一开始除了起点是0，其他都是 <code>INF</code>。</li>
<li><strong><code>visited</code> 数组</strong>: <code>visited[i]</code> 如果是 <code>true</code>，说明节点 <code>i</code> 的最短路径已经找到了，不用再管它了。</li>
<li><strong>外层循环 (<code>for (int count = 0; ...)</code> )</strong>: 最多执行 <code>n</code> 次（因为有 <code>n</code> 个节点需要确定最短路径）。</li>
<li><strong>找到最近的未访问节点 <code>u</code></strong>: 在所有 <code>visited[v_node]</code> 为 <code>false</code> 的节点中，挑一个 <code>dist[v_node]</code> 最小的，这个就是 <code>u</code>。</li>
<li><strong>标记 <code>u</code></strong>: <code>visited[u] = true;</code></li>
<li><strong>更新邻居</strong>: 对于 <code>u</code> 的每一个邻居 <code>v_node</code>，如果通过 <code>u</code> 走到 <code>v_node</code> (即 <code>dist[u] + graph[u][v_node]</code>) 比现在记录的 <code>dist[v_node]</code> 更短，那就更新 <code>dist[v_node]</code>。</li>
</ol>
<p>这个版本牺牲了一些效率（特别是对于边比较少的“稀疏图”），换来了代码上的简洁，更容易理解Dijkstra算法的基本步骤。</p>
<h2 id="前缀和">前缀和
</h2><p>好的，明白了。以后我会专注于核心思路，力求简洁明了。</p>
<p>对于<strong>前缀和</strong>的核心思路就是：</p>
<ol>
<li><strong>预计算累积和</strong>：创建一个新数组，其中每个元素是原数组从开头到对应位置的元素总和。</li>
<li><strong>快速求区间和</strong>：利用预计算的累积和，通过两次查询和一次减法 (&lt;code&gt;prefix_sum[j+1] - prefix_sum[i]&lt;/code&gt;)，在 O(1) 时间内得到原数组任意区间的和。</li>
<li><strong>应用场景</strong>：处理数组区间和、子数组和相关问题（如和为K的子数组）。二维前缀和可处理子矩阵和。</li>
<li><strong>关键</strong>：牺牲 O(N) 空间和 O(N) 预处理时间，换取 O(1) 的区间查询时间。适用于原数组不变的情况。</li>
</ol>
<h2 id="大数求模">大数求模
</h2><p>好的，我们来详细了解一下“模逆元”（Modular Multiplicative Inverse）的概念。</p>
<p><strong>什么是模逆元？</strong></p>
<p>在实数算术中，一个数 <code>a</code> 的倒数（或乘法逆元）是 <code>a⁻¹</code> (即 <code>1/a</code>)，它们满足 <code>a * a⁻¹ = 1</code>。</p>
<p>模逆元是这个概念在模运算（取余运算）环境下的推广。</p>
<p>对于整数 a 和模数 m，如果存在一个整数 x 使得：</p>
<p>(a * x) % m = 1</p>
<p>那么，我们就称 <code>x</code>是 <code>a</code> 关于模 <code>m</code> 的模逆元。通常我们也把 <code>x</code> 记作 <code>a⁻¹ (mod m)</code>。</p>
<p><strong>为什么需要模逆元？</strong></p>
<p>模逆元最主要的应用是在模运算中进行除法。</p>
<p>我们知道，在模运算中：</p>
<ul>
<li><code>(A + B) % m = ((A % m) + (B % m)) % m</code></li>
<li><code>(A - B) % m = ((A % m) - (B % m) + m) % m</code> （加 <code>m</code> 是为了保证结果非负）</li>
<li><code>(A * B) % m = ((A % m) * (B % m)) % m</code></li>
</ul>
<p>但是，除法 <code>(A / B) % m</code> <strong>并不等于</strong> <code>((A % m) / (B % m)) % m</code>。直接进行除法后再取模是行不通的。</p>
<p>为了在模运算中实现除法，我们将除法转换为乘法。如果我们想计算 (A / B) % m，我们可以找到 B 关于模 m 的逆元 B⁻¹。那么：</p>
<p>(A / B) % m = (A * B⁻¹) % m = ((A % m) * (B⁻¹ % m)) % m</p>
<p>这样，我们就把模下的除法问题转化为了模下的乘法问题。</p>
<p><strong>模逆元存在的条件</strong></p>
<p>并不是所有的整数 a 在任意模 m 下都存在模逆元。</p>
<p>a 关于模 m 的模逆元存在的充要条件是 a 和 m 互质（coprime），即它们的最大公约数 gcd(a, m) = 1。</p>
<ul>
<li>如果 <code>m</code> 是一个<strong>素数</strong>，那么任何不被 <code>m</code> 整除的整数 <code>a</code> (即 <code>a % m != 0</code>)都存在关于模 <code>m</code> 的逆元。这在算法竞赛中很常见，模数常常是一个大素数（例如 <code>10^9 + 7</code>）。</li>
</ul>
<p><strong>如何求解模逆元？</strong></p>
<p>主要有两种常用的方法：</p>
<ol>
<li><strong>扩展欧几里得算法 (Extended Euclidean Algorithm)</strong>
<ul>
<li>这是求解模逆元的通用方法，适用于模数 <code>m</code> 不一定是素数的情况（只要 <code>gcd(a, m) = 1</code>）。</li>
<li>扩展欧几里得算法用于求解方程 <code>ax + my = gcd(a, m)</code> 的一组整数解 <code>(x, y)</code>。</li>
<li>如果 <code>gcd(a, m) = 1</code>，那么方程变为 <code>ax + my = 1</code>。</li>
<li>对这个方程两边同时对 <code>m</code> 取模： <code>(ax + my) % m = 1 % m</code> <code>(ax % m) + (my % m) = 1</code> <code>(ax % m) + 0 = 1</code>(因为 <code>my</code> 是 <code>m</code> 的倍数) <code>ax % m = 1</code></li>
<li>此时，<code>x</code> 就是 <code>a</code> 关于模 <code>m</code> 的一个逆元。如果 <code>x</code> 算出来是负数，可以通过 <code>(x % m + m) % m</code> 把它调整到 <code>[0, m-1]</code> 的范围内。</li>
</ul>
</li>
<li><strong>费马小定理 (Fermat&rsquo;s Little Theorem) - 当 m 是素数时</strong>
<ul>
<li>这是一个更简单的方法，但<strong>前提条件是模数 <code>m</code> 必须是素数</strong>，并且 <code>a</code> 不能是 <code>m</code> 的倍数 (即 <code>a % m != 0</code>)。</li>
<li>费马小定理指出：如果 <code>m</code> 是一个素数，且整数 <code>a</code> 不是 <code>m</code> 的倍数，则 <code>a^(m-1) % m = 1</code>。</li>
<li>我们可以把 <code>a^(m-1)</code> 写成 <code>a * a^(m-2)</code>。所以： <code>(a * a^(m-2)) % m = 1</code></li>
<li>根据模逆元的定义，<code>a^(m-2)</code> 就是 <code>a</code> 关于模 <code>m</code> 的逆元。</li>
<li>因此，<code>a⁻¹ % m = a^(m-2) % m</code>。</li>
<li>计算 <code>a^(m-2) % m</code> 通常使用快速幂算法（也叫平方求幂法）来高效完成。</li>
</ul>
</li>
</ol>
<p><strong>举个例子 (使用费马小定理):</strong></p>
<p>计算 3 关于模 7 的逆元。</p>
<p>这里 a = 3，m = 7 (7 是素数)。</p>
<p>根据费马小定理，逆元 x = 3^(7-2) % 7 = 3^5 % 7。</p>
<p>3^1 = 3</p>
<p>3^2 = 9 % 7 = 2</p>
<p>3^3 = (3^2 * 3) % 7 = (2 * 3) % 7 = 6</p>
<p>3^4 = (3^3 * 3) % 7 = (6 * 3) % 7 = 18 % 7 = 4</p>
<p>3^5 = (3^4 * 3) % 7 = (4 * 3) % 7 = 12 % 7 = 5</p>
<p>所以，3 关于模 7 的逆元是 5。</p>
<p>验证一下：(3 * 5) % 7 = 15 % 7 = 1。正确！</p>
<p><strong>在你代码中的应用：</strong></p>
<p>在你的 calMp 函数中，有这样的代码：</p>
<p>res /= F[mp[i+&lsquo;0&rsquo;]];</p>
<p>如果这是在模 MOD 下运算，并且 F[x] 代表 x!，那么你需要将其改为：</p>
<p>res = (res * modularInverse(F[mp[i+&lsquo;0&rsquo;]])) % MOD;</p>
<p>其中 <code>modularInverse</code> 函数可以使用费马小定理（因为 <code>10^9 + 7</code> 是素数）或扩展欧几里得算法来实现。</p>
<p><strong>总结：</strong></p>
<ul>
<li>模逆元 <code>a⁻¹ (mod m)</code> 满足 <code>(a * a⁻¹) % m = 1</code>。</li>
<li>用于在模运算中实现除法：<code>(A / B) % m = (A * B⁻¹) % m</code>。</li>
<li>存在的条件是 <code>gcd(a, m) = 1</code>。</li>
<li>常用求解方法有扩展欧几里得算法和费马小定理（当 <code>m</code> 为素数时）。</li>
</ul>
<p>希望这个解释能帮助你理解模逆元！</p>
<h3 id="费马定理证明">费马定理证明
</h3><p>好的，费马小定理 <code>a^(m-1) % m = 1</code>（其中 <code>m</code> 是素数，<code>a</code> 不是 <code>m</code> 的倍数）的证明有很多种，这里提供一个相对简单和直观的思路：</p>
<p><strong>证明思路：利用构造和消除</strong></p>
<ol>
<li>
<p>考虑一个集合：</p>
<p>我们来看一下数字 1, 2, 3, &hellip;, m-1。这些是模 m 下所有非零的余数。这个集合里有 m-1 个数。</p>
<p>让我们称这个集合为 S = {1, 2, &hellip;, m-1}。</p>
</li>
<li>
<p>用 a 乘以集合中的每个元素并对 m 取模：</p>
<p>现在，我们将集合 S 中的每一个元素都乘以 a，然后对 m 取模，得到一个新的集合 S&rsquo;：</p>
<p>S&rsquo; = { (a * 1) % m, (a * 2) % m, &hellip;, (a * (m-1)) % m }</p>
</li>
<li>
<p><strong>证明新集合 <code>S'</code> 的性质：</strong></p>
<ul>
<li>
<p>S&rsquo; 中的所有元素都互不相同：</p>
<p>假设有两个不同的数 i 和 j (它们都在 S 中，即 1 &lt;= i &lt; j &lt;= m-1)，使得 (a * i) % m = (a * j) % m。</p>
<p>这意味着 a * i ≡ a * j (mod m)。</p>
<p>因为 m 是素数，并且 a 不是 m 的倍数，所以 a 和 m 互质 (gcd(a, m) = 1)。</p>
<p>根据模运算的性质，如果 a * i ≡ a * j (mod m) 且 gcd(a, m) = 1，那么我们可以消去 a，得到 i ≡ j (mod m)。</p>
<p>但是因为 i 和 j 都是小于 m 的正整数，并且我们假设它们不相等，所以 i ≡ j (mod m) 意味着 i = j。这与我们最初假设 i 和 j 不同相矛盾。</p>
<p>因此，S&rsquo; 中的所有 m-1 个元素都是互不相同的。</p>
</li>
<li>
<p>S&rsquo; 中的所有元素都不是 0：</p>
<p>假设 (a * k) % m = 0 对于某个 k 属于 S。</p>
<p>这意味着 a * k 是 m 的倍数。</p>
<p>因为 m 是素数，所以 m 必须整除 a 或者 m 必须整除 k。</p>
<p>但我们已知条件是 a 不是 m 的倍数，并且 k 属于 {1, 2, &hellip;, m-1}，所以 k 也不是 m 的倍数。</p>
<p>因此，(a * k) % m 不可能为 0。</p>
</li>
<li>
<p>结论：S&rsquo; 和 S 是同一个集合（只是元素的顺序可能不同）：</p>
<p>由于 S&rsquo; 包含了 m-1 个互不相同且非零的模 m 的余数，那么 S&rsquo; 实际上就是集合 S 的一个排列。它们包含的元素是完全一样的。</p>
</li>
</ul>
</li>
<li>
<p>比较两个集合所有元素的乘积：</p>
<p>既然集合 S 和 S&rsquo; 包含相同的元素，那么它们所有元素的乘积在模 m 下也应该是相等的。</p>
<ul>
<li>
<p>集合 S 中所有元素的乘积：</p>
<p>P_S = (1 * 2 * 3 * &hellip; * (m-1)) % m = (m-1)! % m</p>
</li>
<li>
<p>集合 S&rsquo; 中所有元素的乘积：</p>
<p>P_S&rsquo; = ((a * 1) * (a * 2) * &hellip; * (a * (m-1))) % m</p>
<p>P_S&rsquo; = (a^(m-1) * (1 * 2 * &hellip; * (m-1))) % m</p>
<p>P_S&rsquo; = (a^(m-1) * (m-1)!) % m</p>
</li>
</ul>
</li>
<li>
<p>相等并消去：</p>
<p>因为 P_S ≡ P_S&rsquo; (mod m)，所以：</p>
<p>(m-1)! ≡ (a^(m-1) * (m-1)!) (mod m)</p>
<p>现在，我们需要从两边“消去”<code>(m-1)!</code>。我们能这样做是因为 <code>(m-1)!</code> 和 <code>m</code> 是互质的 (<code>gcd((m-1)!, m) = 1</code>)。为什么？因为 <code>m</code> 是素数，所以 <code>1, 2, ..., m-1</code> 这些数都不包含因子 <code>m</code>，因此它们的乘积 <code>(m-1)!</code> 也不会包含因子 <code>m</code>。</p>
<p>当 X Y ≡ X Z (mod m) 且 gcd(X, m) = 1 时，我们可以得到 Y ≡ Z (mod m)。</p>
<p>在这里，X = (m-1)!，Y = 1，Z = a^(m-1)。</p>
<p>所以，我们可以消去 (m-1)!，得到：</p>
<p>1 ≡ a^(m-1) (mod m)</p>
<p>这就完成了费马小定理的证明。</p>
</li>
</ol>
<p><strong>简单来说：</strong> 当你用一个与素数 <code>m</code> 互质的数 <code>a</code> 去乘所有小于 <code>m</code> 的正整数再对 <code>m</code> 取模时，你得到的仍然是所有小于 <code>m</code> 的正整数（只是顺序被打乱了）。利用这个性质，比较两组数乘积的关系，就可以推导出定理。</p>
<h3 id="扩展欧几里得">扩展欧几里得
</h3><p>好的，我们来详细讲解一下“扩展欧几里得算法”（Extended Euclidean Algorithm）。</p>
<p>这个算法是标准欧几里得算法（辗转相除法）的扩展。标准的欧几里得算法用于计算两个整数 <code>a</code> 和 <code>b</code> 的最大公约数（Greatest Common Divisor, GCD），而扩展欧几里得算法在计算 <code>gcd(a, b)</code> 的同时，还能找出两个整数 <code>x</code>和 <code>y</code>，使得它们满足下面的<strong>贝祖等式（Bézout&rsquo;s Identity）</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a*x + b*y = gcd(a, b)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>回顾：标准欧几里得算法</strong></p>
<p>首先，回忆一下标准的欧几里得算法是如何工作的。它基于以下原理：</p>
<p>gcd(a, b) = gcd(b, a % b)</p>
<p>其中 a % b 是 a 除以 b 的余数。算法会一直递归下去，直到 b 变为 0，此时 gcd(a, 0) = a。</p>
<p>例如，计算 <code>gcd(48, 18)</code>：</p>
<ol>
<li><code>gcd(48, 18) = gcd(18, 48 % 18) = gcd(18, 12)</code></li>
<li><code>gcd(18, 12) = gcd(12, 18 % 12) = gcd(12, 6)</code></li>
<li><code>gcd(12, 6) = gcd(6, 12 % 6) = gcd(6, 0)</code></li>
<li><code>gcd(6, 0) = 6</code>。所以 <code>gcd(48, 18) = 6</code>。</li>
</ol>
<p><strong>扩展欧几里得算法的原理</strong></p>
<p>扩展欧几里得算法的目标是找到 <code>x</code> 和 <code>y</code> 使得 <code>ax + by = gcd(a, b)</code>。它也是一个递归的过程，与标准欧几里得算法的递归步骤紧密相关。</p>
<p>假设我们正在计算 gcd(a, b)，并且我们已经通过递归调用 extendedEuclidean(b, a % b) 得到了 x&rsquo; 和 y&rsquo;，使得：</p>
<p>b*x&rsquo; + (a % b)*y&rsquo; = gcd(b, a % b)</p>
<p>我们知道 gcd(a, b) = gcd(b, a % b)，所以上面等式的右边也等于 gcd(a, b)。</p>
<p>我们还知道 a % b = a - floor(a/b) * b （其中 floor(a/b) 表示 a 除以 b 的整数部分）。</p>
<p>将 a % b 代入上面的递归结果等式中：</p>
<p>b*x&rsquo; + (a - floor(a/b) * b)*y&rsquo; = gcd(a, b)</p>
<p>展开并重新整理，把 a 和 b 的项归类：</p>
<p>b<em>x&rsquo; + a</em>y&rsquo; - floor(a/b) * b * y&rsquo; = gcd(a, b)</p>
<p>a<em>y&rsquo; + b</em>(x&rsquo; - floor(a/b) * y&rsquo;) = gcd(a, b)</p>
<p>现在，将这个等式与我们期望的目标形式 <code>ax + by = gcd(a, b)</code> 进行比较，我们可以得出：</p>
<ul>
<li><code>x = y'</code></li>
<li><code>y = x' - floor(a/b) * y'</code></li>
</ul>
<p>这就是从下一层递归的结果 <code>(x', y')</code> 计算当前层结果 <code>(x, y)</code> 的递推关系。</p>
<p>递归的基准情况 (Base Case):</p>
<p>当 b = 0 时，gcd(a, 0) = a。</p>
<p>此时，我们需要 ax + by = a，即 ax + 0*y = a。</p>
<p>一组明显的解是 x = 1, y = 0。</p>
<p><strong>算法步骤（递归形式）：</strong></p>
<p>函数 <code>extendedEuclidean(a, b)</code>:</p>
<ol>
<li><strong>如果 <code>b == 0</code></strong>: 返回 <code>(a, 1, 0)</code> （即 <code>gcd = a, x = 1, y = 0</code>）</li>
<li><strong>否则</strong>: 递归调用 <code>(gcd, x_prime, y_prime) = extendedEuclidean(b, a % b)</code> 计算 <code>x = y_prime</code> 计算 <code>y = x_prime - (a // b) * y_prime</code> (这里的 <code>//</code> 代表整数除法) 返回 <code>(gcd, x, y)</code></li>
</ol>
<p><strong>示例：计算 <code>48x + 18y = gcd(48, 18)</code></strong></p>
<p>我们已经知道 <code>gcd(48, 18) = 6</code>。</p>
<ol>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extendedEuclidean(48, 18)
</span></span></code></pre></td></tr></table>
</div>
</div><p>:</p>
<ul>
<li>
<p>调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extendedEuclidean(18, 12)
</span></span></code></pre></td></tr></table>
</div>
</div><p>(</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">12 = 48 % 18
</span></span></code></pre></td></tr></table>
</div>
</div><p>)</p>
<ul>
<li>
<p>调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extendedEuclidean(12, 6)
</span></span></code></pre></td></tr></table>
</div>
</div><p>(</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">6 = 18 % 12
</span></span></code></pre></td></tr></table>
</div>
</div><p>)</p>
<ul>
<li>
<p>调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extendedEuclidean(6, 0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>(</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0 = 12 % 6
</span></span></code></pre></td></tr></table>
</div>
</div><p>)</p>
<ul>
<li><strong>基准情况</strong>: <code>b=0</code>。返回 <code>(gcd=6, x'''=1, y'''=0)</code>。</li>
</ul>
</li>
<li>
<p>返回到 <code>extendedEuclidean(12, 6)</code> 的调用。 这里 <code>a=12, b=6</code>。上一层返回 <code>(gcd=6, x_prime=1, y_prime=0)</code> (即 <code>x'''</code> 和 <code>y'''</code>)。 <code>x'' = y_prime = 0</code> <code>y'' = x_prime - (12 // 6) * y_prime = 1 - 2 * 0 = 1</code>返回 <code>(gcd=6, x''=0, y''=1)</code>。 (验证：<code>12*0 + 6*1 = 6</code>，正确)</p>
</li>
</ul>
</li>
<li>
<p>返回到 <code>extendedEuclidean(18, 12)</code> 的调用。 这里 <code>a=18, b=12</code>。上一层返回 <code>(gcd=6, x_prime=0, y_prime=1)</code> (即 <code>x''</code> 和 <code>y''</code>)。 <code>x' = y_prime = 1</code> <code>y' = x_prime - (18 // 12) * y_prime = 0 - 1 * 1 = -1</code> 返回 <code>(gcd=6, x'=1, y'=-1)</code>。 (验证：<code>18*1 + 12*(-1) = 18 - 12 = 6</code>，正确)</p>
</li>
</ul>
</li>
<li>
<p>返回到最初的 <code>extendedEuclidean(48, 18)</code> 调用。 这里 <code>a=48, b=18</code>。上一层返回 <code>(gcd=6, x_prime=1, y_prime=-1)</code> (即 <code>x'</code> 和 <code>y'</code>)。 <code>x = y_prime = -1</code> <code>y = x_prime - (48 // 18) * y_prime = 1 - 2 * (-1) = 1 - (-2) = 3</code> 最终返回 <code>(gcd=6, x=-1, y=3)</code>。</p>
</li>
</ul>
</li>
</ol>
<p>所以，我们找到了 <code>x = -1</code> 和 <code>y = 3</code>，使得 <code>48*(-1) + 18*(3) = -48 + 54 = 6</code>。</p>
<p><strong>应用场景</strong></p>
<p>扩展欧几里得算法非常重要，主要应用包括：</p>
<ol>
<li>
<p>求解模的乘法逆元：</p>
<p>这是最常见的应用之一。如果你想找到 a 关于模 m 的逆元 x (即 ax ≡ 1 (mod m))，这等价于求解 ax + my = 1 (其中 y 是某个整数)。</p>
<p>这只有在 gcd(a, m) = 1 时才有解。使用扩展欧几里得算法计算 ax + my = gcd(a, m)。如果 gcd(a, m) 确实是 1，那么算法返回的 x (可能需要调整到 [0, m-1] 范围内，例如 (x % m + m) % m) 就是 a 的模逆元。</p>
</li>
<li>
<p>求解线性丢番图方程 (Linear Diophantine Equations)：</p>
<p>形如 ax + by = c 的方程，其中 a, b, c 是整数，要求整数解 x, y。</p>
<ul>
<li>首先，这样的方程有解当且仅当 <code>gcd(a, b)</code> 能够整除 <code>c</code>。</li>
<li>如果存在解，可以先用扩展欧几里得算法找到 <code>ax_0 + by_0 = gcd(a, b)</code> 的一组解 <code>(x_0, y_0)</code>。</li>
<li>然后，方程 <code>ax + by = c</code> 的一个特解是 <code>x = x_0 * (c / gcd(a, b))</code> 和 <code>y = y_0 * (c / gcd(a, b))</code>。</li>
<li>还可以由此推导出通解。</li>
</ul>
</li>
</ol>
<p>扩展欧几里得算法是数论中一个基础且强大的工具。希望这个解释能帮助你理解它！</p>
<h2 id="动态规划的精益思想">动态规划的精益思想
</h2><p>在我们做题的时候很多时候会遇到动态规划等类型的题目，现在我将这些做题经验归纳为如下的方法：</p>
<p><strong>优化路线概览：</strong></p>
<ol>
<li><strong>朴素 DFS (Depth-First Search) / 暴力递归</strong></li>
<li><strong>记忆化搜索 (Memoized DFS / Top-Down DP)</strong></li>
<li><strong>多维（通常二维）DP 数组 (Bottom-Up DP)</strong></li>
<li><strong>DP 数组降维 (空间优化)</strong></li>
<li><strong>状态转移矩阵 + 矩阵快速幂 (针对特定类型的 DP 问题进行加速)</strong></li>
</ol>
<hr>
<h3 id="1-朴素-dfs--暴力递归">1. 朴素 DFS / 暴力递归
</h3><ul>
<li><strong>核心思想：</strong>
<ul>
<li>不考虑子问题重复计算，直接根据问题的定义和状态转移进行递归。</li>
<li>通常对应一个递归函数，函数参数代表当前状态。</li>
<li>在递归函数中，尝试所有可能的“下一步”选择，直到达到递归边界（基本情况）。</li>
</ul>
</li>
<li><strong>适用场景：</strong>
<ul>
<li>问题的解可以通过一系列决策步骤得到。</li>
<li>可以清晰地定义问题的“状态”和“选择”。</li>
</ul>
</li>
<li><strong>优点：</strong>
<ul>
<li>思路直接，接近人类思考方式，容易实现。</li>
<li>代码结构清晰，易于理解。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>存在大量的重复计算。如果子问题的状态空间很大，并且存在许多重叠子问题，会导致指数级的时间复杂度，很容易超时 (Time Limit Exceeded, TLE)。</li>
</ul>
</li>
<li><strong>例子：</strong>
<ul>
<li>斐波那契数列 <code>fib(n) = fib(n-1) + fib(n-2)</code>，直接递归计算会导致 <code>fib(n-2)</code> 等被重复计算多次。</li>
</ul>
</li>
</ul>
<h3 id="2-记忆化搜索-memoized-dfs--top-down-dp">2. 记忆化搜索 (Memoized DFS / Top-Down DP)
</h3><ul>
<li><strong>核心思想：</strong>
<ul>
<li>在朴素 DFS 的基础上，增加一个“备忘录”（通常是数组或哈希表）来存储已经计算过的子问题的解。</li>
<li>在递归函数的开头，检查当前状态的解是否已经在备忘录中。如果是，则直接返回；否则，进行计算，并将结果存入备忘录后再返回。</li>
</ul>
</li>
<li><strong>与动态规划的关系：</strong> 这就是动态规划思想的一种实现方式，称为“自顶向下”(Top-Down) 的动态规划。</li>
<li><strong>优点：</strong>
<ul>
<li>保留了 DFS 的直观性和易理解性。</li>
<li>通过消除冗余计算，极大地提高了效率。时间复杂度通常变为 <code>O(状态数 * 状态转移的平均复杂度)</code>。</li>
<li>对于某些状态空间稀疏的问题，可能比 Bottom-Up DP 更高效，因为它只计算实际需要的状态。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>递归本身有函数调用开销和栈空间开销，对于递归深度过深的问题可能导致栈溢出 (Stack Overflow)。</li>
</ul>
</li>
<li><strong>实现要点：</strong>
<ul>
<li>定义备忘录 <code>memo</code>，并初始化为一个特殊值（例如 <code>-1</code>，表示未计算过）。</li>
<li><code>memo</code> 的维度和大小通常与递归函数中代表状态的参数对应。</li>
</ul>
</li>
<li><strong>例子：</strong>
<ul>
<li>斐波那契数列：<code>memo[n]</code> 存储 <code>fib(n)</code> 的结果。</li>
<li>背包问题：<code>memo[i][capacity]</code> 存储考虑前 <code>i</code> 个物品，当前背包容量为 <code>capacity</code> 时的最优解。</li>
</ul>
</li>
</ul>
<h3 id="3-多维通常二维dp-数组-bottom-up-dp">3. 多维（通常二维）DP 数组 (Bottom-Up DP)
</h3><ul>
<li><strong>核心思想：</strong>
<ul>
<li>与记忆化搜索相反，Bottom-Up DP 从最小的子问题开始，迭代地计算出更大规模子问题的解，直到解决整个问题。</li>
<li>通常使用一个或多个数组（DP 表）来存储子问题的解。</li>
<li><code>dp[state]</code> 表示状态 <code>state</code> 下的解。</li>
<li>通过状态转移方程 <code>dp[state] = f(dp[prev_state1], dp[prev_state2], ...)</code> 从已知的子问题解推导出当前问题的解。</li>
</ul>
</li>
<li><strong>与动态规划的关系：</strong> 这是动态规划思想的另一种实现方式，称为“自底向上”(Bottom-Up) 的动态规划。</li>
<li><strong>优点：</strong>
<ul>
<li>通常使用循环实现，避免了递归开销，空间和时间上的常数因子可能更小。</li>
<li>对于所有状态都需要计算的问题，思路更清晰。</li>
<li>可以方便地进行后续的空间优化。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>需要明确定义状态的计算顺序（拓扑序），有时不如记忆化搜索直观。</li>
<li>如果状态空间稀疏，可能会计算一些无用的状态。</li>
</ul>
</li>
<li><strong>实现步骤：</strong>
<ol>
<li><strong>定义状态：</strong> 明确 <code>dp</code> 数组的含义，即 <code>dp[i]</code> 或 <code>dp[i][j]</code> 等代表什么。</li>
<li><strong>确定状态转移方程：</strong> 找到 <code>dp[state]</code> 如何由之前的状态 <code>dp[prev_state]</code> 推导出来。</li>
<li><strong>初始化：</strong> 确定 DP 数组的初始值（基本情况）。</li>
<li><strong>确定遍历顺序：</strong> 保证在计算 <code>dp[state]</code> 时，其依赖的 <code>dp[prev_state]</code> 都已经被计算过。</li>
</ol>
</li>
<li><strong>例子：</strong>
<ul>
<li>斐波那契数列：<code>dp[i] = dp[i-1] + dp[i-2]</code>。</li>
<li>0/1 背包问题：<code>dp[i][j]</code> 表示考虑前 <code>i</code> 个物品，背包容量为 <code>j</code> 时的最大价值。
<code>dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])</code></li>
</ul>
</li>
</ul>
<h3 id="4-dp-数组降维-空间优化">4. DP 数组降维 (空间优化)
</h3><ul>
<li><strong>核心思想：</strong>
<ul>
<li>观察状态转移方程，如果计算当前状态 <code>dp[i][...]</code> 只需要 <code>dp[i-1][...]</code> (或少数几个前序状态) 的信息，那么 DP 数组的维度就可以被优化。</li>
<li>这种优化通常被称为“滚动数组”或直接在原有维度上进行原地更新。</li>
</ul>
</li>
<li><strong>适用场景：</strong>
<ul>
<li>当前状态的计算只依赖于前一个（或固定几个）状态。</li>
<li>当 DP 数组的某一维度特别大，导致内存不足时。</li>
</ul>
</li>
<li><strong>如何实现：</strong>
<ul>
<li><strong>二维降一维：</strong> 如果 <code>dp[i][j]</code> 只依赖于 <code>dp[i-1][...]</code>，可以将 <code>dp[N][M]</code> 优化为 <code>dp[M]</code>。更新 <code>dp[j]</code> 时需注意遍历 <code>j</code> 的顺序。</li>
<li><strong>使用少量变量：</strong> 如斐波那契数列 <code>dp[i] = dp[i-1] + dp[i-2]</code>，只需两个变量。</li>
</ul>
</li>
<li><strong>优点：</strong>
<ul>
<li>显著降低空间复杂度，例如从 <code>O(N*M)</code> 降到 <code>O(M)</code> 或 <code>O(N)</code>。</li>
</ul>
</li>
<li><strong>缺点：</strong>
<ul>
<li>可能丢失部分状态信息，影响路径回溯。</li>
<li>代码直观性可能下降。</li>
</ul>
</li>
<li><strong>例子：</strong>
<ul>
<li>0/1 背包问题空间优化：<code>dp[j] = max(dp[j], dp[j-weight[i]] + value[i])</code>，<code>j</code> 需从大到小遍历。</li>
</ul>
</li>
</ul>
<h3 id="5-状态转移矩阵--矩阵快速幂">5. 状态转移矩阵 + 矩阵快速幂
</h3><ul>
<li>
<p><strong>核心思想：</strong></p>
<ul>
<li>当 DP 的状态转移是线性的，并且状态的维度较小且固定时，可以将状态转移表示为：<code>State(k+1) = TransitionMatrix * State(k)</code>。</li>
<li>则 <code>State(N) = (TransitionMatrix ^ N) * State(0)</code>。</li>
<li><code>TransitionMatrix ^ N</code> 使用矩阵快速幂在 <code>O(D^3 * logN)</code> 时间内计算（<code>D</code> 是状态向量维度）。</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong></p>
<ul>
<li>线性递推关系，如斐波那契数列及其变种。</li>
<li>问题需计算第 <code>N</code> 个状态，且 <code>N</code> 非常大 (如 <code>10^9</code>, <code>10^{18}</code>), 而状态维度不大。</li>
<li>路径计数问题，步数 <code>N</code> 巨大，但图节点数（状态数）较小。</li>
</ul>
</li>
<li>
<p><strong>如何构建转移矩阵：</strong></p>
<ol>
<li>
<p><strong>定义状态向量：</strong> 如 <code>[fib(k), fib(k-1)]^T</code>。</p>
</li>
<li>
<p><strong>构造转移矩阵 M：</strong> 使得 <code>M * State(k-1) = State(k)</code>。
例如，斐波那契数列的转移矩阵 <code>M</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[ fib(k)   ] = [ 1  1 ] * [ fib(k-1) ]
</span></span><span class="line"><span class="cl">[ fib(k-1) ]   [ 1  0 ]   [ fib(k-2) ]
</span></span><span class="line"><span class="cl">M = [[1, 1], [1, 0]]
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
</li>
<li>
<p><strong>矩阵快速幂：</strong></p>
<ul>
<li>类似于整数快速幂，通过分治计算 <code>M^N</code>。</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>当 <code>N</code> 巨大时，复杂度从 <code>O(N*D^k)</code> 降至 <code>O(D^3 * logN)</code>。</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>只适用于特定类型的线性递推 DP。</li>
<li>矩阵乘法常数大，<code>N</code> 不够大或 <code>D</code> 很大时可能不优。</li>
</ul>
</li>
<li>
<p><strong>例子：</strong></p>
<ul>
<li>计算斐波那契数列第 <code>N</code> 项模 <code>P</code> 的值。</li>
<li>有向图中从节点 A 到节点 B 恰好走 <code>K</code> 步的路径数量。</li>
</ul>
</li>
</ul>
<h2 id="dp变种">DP变种
</h2><h3 id="状态集dp">状态集DP
</h3><p>题目来源于：涂色问题。</p>
<p>状态dp指的是在dp数组中存储的并不是单个的结果数字，而是前一个dp的所有状态。</p>
<p>一般来说dp方法中求解当前dp的方法是依赖于当前的环境和历史的dp数组值，而这种方法他需要的条件是当前的dp只是依赖于历史的dp数值，但是对于那些在求解当前的dp时候，需要依赖于历史dp的具体状态，对于每一种不同状态的历史dp都会有不同的（✖️或➕）的方式。</p>
<p>状态dp中存储的是当前dp的所有状态，而这种状态可能因为状态数量过多而需要将一种状态压缩到一个int。</p>
<p>在求解当前dp状态的时候，对于多维dp，可能会产生状态不一致的情况（例如对于二维dp，dp[i] [j]需要依赖于上一个i-1和j-1的状态，只不过这两种i-1的状态和j-1的状态也是相互关联依赖的，所以对于这种情况需要进行dp降维，也就是说对于dp【i】表示行i只依赖于i-1行。</p>
<p>状态dp一般是只依赖于上一个状态，而不依赖于历史状态。对于那些状态依赖转换时，是进行线性求解的，可以使用矩阵快速幂的方法求解。</p>
<h3 id="状态机振荡dp">状态机（振荡）DP
</h3><blockquote>
<p>[!NOTE]</p>
<p>多种状态和情况</p></blockquote>
<p>状态机动态规划的核心在于将复杂问题分解为一系列基于<strong>有限且明确定义的状态</strong>的子问题。其解题思路可以概括为：首先，你需要在问题中抽取出若干个<strong>关键的、相互排斥的“模式”或“阶段”</strong>，并将它们定义为你的“状态”，这些状态必须能够完整描述在处理当前输入时所处的情境或已积累的信息。接着，针对序列中的每一个元素，你需要识别出所有<strong>合法的“动作”或“选择”</strong>，这些选择将决定系统从当前状态如何<strong>转移</strong>到下一个状态（或保持当前状态）。然后，通过<strong>构建状态转移方程</strong>，明确每个状态的值如何从前一个或多个状态以及当前元素的值推导而来，通常这涉及到在多种转移路径中选取<strong>最优值</strong>。在递推计算之前，务必<strong>设定好初始状态</strong>的边界条件，为整个DP过程提供一个正确的起点。最后，根据问题的具体目标，从所有计算出的最终状态中挑选出符合要求的那个作为最终答案。这种方法特别适用于那些序列处理问题，即当你对序列中的每个元素做出决策时，该决策不仅取决于元素本身，还会受到此前累积的某种“情况”或“属性”的影响，并且这些“情况”或“属性”是有限且可被清晰分类的场景，旨在求取某种最优值（如最大/最小和、最长/最短序列等）。</p>
<p>对于状态机DP有可能下面的状态转移方法：</p>
<ol>
<li>奇偶DP相互转换：<a class="link" href="https://leetcode.cn/problems/find-the-maximum-sum-of-node-values/description/"  target="_blank" rel="noopener"
    >最大节点价值之和</a></li>
<li>上升下降序列的DP相互转换：<a class="link" href="https://leetcode.cn/problems/wiggle-subsequence/description/"  target="_blank" rel="noopener"
    >摆动序列</a></li>
</ol>
<p>总结的DP形式：<code>vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(state_num,0))</code></p>
<h3 id="字符集动态规划-character-set-dp-方法与思路总结">字符集动态规划 (Character Set DP) 方法与思路总结
</h3><blockquote>
<p>[!NOTE]</p>
<p>一般出现的预告：在string中只会出现小写字母</p>
<p>涉及的题目：<a class="link" href="https://leetcode.cn/problems/decremental-string-concatenation/description/"  target="_blank" rel="noopener"
    >字符串连接删减字母</a></p>
<p>特征：dp【字符集】【序列】</p></blockquote>
<p>字符集DP的核心在于，当处理序列问题时，若每一步决策的优化目标仅依赖于<strong>当前形成的中间结果的某些关键属性（例如字符串的首尾字符），且这些属性的数量有限且可枚举</strong>，我们便可将其作为DP状态的维度，从而高效地解决问题。</p>
<hr>
<h4 id="1-核心思想">1. 核心思想
</h4><p>这种方法利用了这样一个观察：在某些序列连接或构建问题中，虽然中间结果可能很长，但<strong>决定未来连接方式和成本的关键信息仅仅是其头部和尾部的字符</strong>（或其它少量、有限的属性）。通过将这些关键字符编码到DP状态中，我们避免了存储和传递整个字符串，极大地降低了状态空间复杂度。</p>
<hr>
<h4 id="2-通用方法步骤">2. 通用方法步骤
</h4><ol>
<li>
<p><strong>定义DP状态：</strong></p>
<ul>
<li>确定DP数组的维度，其中一维通常表示<strong>当前处理到的序列元素索引</strong>（例如 <code>dp[i]</code> 表示处理到 <code>words[i]</code>）。</li>
<li>将影响后续决策的<strong>关键属性作为DP状态的额外维度</strong>。在本题中，就是当前字符串的<strong>首字符</strong>和<strong>尾字符</strong>。由于字符集有限（如26个小写字母），这两个字符可以映射为0-25的整数索引，从而形成 <code>dp[i][first_char_idx][last_char_idx]</code> 这样的状态定义。此状态表示处理完前 <code>i</code> 个元素，且最终形成的字符串以 <code>first_char_idx</code> 开头、以 <code>last_char_idx</code> 结尾时的最优值（例如最小总长度）。</li>
</ul>
</li>
<li>
<p><strong>初始化DP状态：</strong></p>
<ul>
<li>对于求最小值的DP问题，通常将不可达的状态初始化为无穷大。</li>
<li>设定初始元素（例如 <code>words[0]</code>）对应的状态值。它的首尾字符是确定的，此时的总长度就是其自身长度。</li>
</ul>
</li>
<li>
<p><strong>推导状态转移方程：</strong></p>
<ul>
<li>遍历输入序列中的每个元素。对于当前元素 <code>current_word</code>，你需要考虑它与之前所有可能的中间结果如何连接。</li>
<li><strong>分析所有可能的连接方式及其对长度的影响</strong>。例如，将 <code>current_word</code> 连接到之前字符串的<strong>前面</strong>或<strong>后面</strong>。</li>
<li>根据连接规则（如本题中首尾字符相同时长度减1），计算新的总长度，并更新相应的新状态 <code>dp[i][new_first_char_idx][new_last_char_idx]</code> 的最优值。这个过程会涉及从 <code>dp[i-1][prev_first][prev_last]</code> 转移到新的 <code>dp[i][new_first][new_last]</code>。</li>
</ul>
</li>
<li>
<p><strong>确定最终结果：</strong></p>
<ul>
<li>在处理完所有序列元素后，最终答案即为所有 <code>dp[n-1][first_char_idx][last_char_idx]</code> （遍历所有可能的首尾字符组合）中的最优值（例如最小值）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-适用场景">3. 适用场景
</h4><p>字符集DP特别适用于以下问题类型：</p>
<ul>
<li><strong>序列处理问题：</strong> 当问题涉及对序列（如字符串数组、字符序列）进行操作，且每次操作会形成一个新的中间结果。</li>
<li><strong>关键属性有限：</strong> 只有中间结果的少数几个关键属性（如字符串的首尾字符、字符计数、固定长度子串的哈希值等）对后续决策至关重要，并且这些属性的数量是<strong>有限且可枚举</strong>的常数。</li>
<li><strong>最优性问题：</strong> 目标是求取某个值（如最小/最大长度、成本、路径等）的最优解。</li>
<li><strong>重叠子问题与最优子结构：</strong> 大问题的解决依赖于小问题的最优解，且存在重复计算的子问题。</li>
</ul>
<p>通过这种方式，字符集DP有效地将看似复杂的字符串操作问题转化为一个状态空间可控的动态规划问题，从而实现高效求解。</p>
<h3 id="树形动态规划-tree-dp-方法与思路总结">树形动态规划 (Tree DP) 方法与思路总结
</h3><p>树形动态规划（Tree DP）是一种强大的DP范式，专门用于解决<strong>树结构上的优化问题</strong>。它的核心在于巧妙利用树的<strong>递归结构和子树的独立性</strong>，通过自底向上或自顶向下的方式，计算每个节点子树的DP值，并将其合并以解决更大子树乃至整个树的问题。</p>
<blockquote>
<p>[!NOTE]</p>
<p>特征：使用dfs计算从根遍历+dp【节点】【状态】</p></blockquote>
<hr>
<h4 id="1-核心思想-1">1. 核心思想
</h4><p>Tree DP 的本质是<strong>将树分解为子树，并定义状态来概括每个子树的最优信息</strong>。在计算父节点的状态时，我们依赖于其所有子节点已计算出的最优状态，并通过特定规则进行合并或转换。这种方法确保了在计算任何节点时，其所有依赖的子问题都已解决，从而遵循了动态规划的<strong>最优子结构和无后效性</strong>原则。</p>
<hr>
<h4 id="2-通用方法步骤-1">2. 通用方法步骤
</h4><ol>
<li>
<p><strong>树的转化与根的选择（DFS 遍历）：</strong></p>
<ul>
<li>尽管输入通常是无向树，但为了构建DP的计算顺序，我们通常会<strong>选择一个任意节点作为根</strong>（例如节点 0）。</li>
<li>接着进行一次<strong>深度优先搜索 (DFS)</strong> 遍历，建立明确的父子关系。这个DFS过程通常是<strong>后序遍历（post-order traversal）</strong>，即先递归处理所有子节点，再处理当前节点。这种自底向上的计算顺序是Tree DP最常见的模式，确保了在计算父节点时，其所有子节点的DP值都已准备就绪。</li>
</ul>
</li>
<li>
<p><strong>定义DP状态：</strong></p>
<ul>
<li>这是Tree DP最关键的一步。你需要为树中的每个节点 <code>u</code> 定义一个或多个DP状态 <code>dp[u][...]</code>。这些状态必须能够：
<ul>
<li><strong>充分概括以 <code>u</code> 为根的子树的最优信息</strong>，或者与 <code>u</code> 相关的局部关键属性。</li>
<li><strong>为 <code>u</code> 的父节点或兄弟节点的计算提供足够的信息</strong>。</li>
</ul>
</li>
<li>状态的维度通常与问题的决策或需要跟踪的属性相关。例如，在本题中，<code>f[x][0]</code> 和 <code>f[x][1]</code> 就分别表示节点 <code>x</code> 被操作偶数次和奇数次时，其子树（不包含 <code>x</code> 本身，因为它将在最后与父节点合并时处理）的最大价值和。</li>
</ul>
</li>
<li>
<p><strong>推导状态转移方程：</strong></p>
<ul>
<li>对于每个节点 <code>u</code>，其DP值通常通过<strong>聚合其所有子节点 <code>v</code> 的DP值</strong>，并结合 <code>u</code> 自身的价值和当前决策来计算。</li>
<li><strong>决策点</strong>通常发生在节点与子节点之间的<strong>边上</strong>，或者<strong>节点自身的操作</strong>。</li>
<li>转移方程描述了如何从子节点的状态推导出父节点的状态。这可能涉及对子节点状态的求和、取最大/最小值，或者根据特定操作对子节点状态进行变换。</li>
<li><strong>以本题为例：</strong> 在处理节点 <code>x</code> 的子节点 <code>y</code> 时，会考虑两种情况：不操作边 <code>[x, y]</code> 和操作边 <code>[x, y]</code>。这两种情况导致 <code>y</code> 的最终状态（被操作奇数次还是偶数次）以及 <code>x</code> 的状态（被操作奇数次还是偶数次）发生变化，并根据这些变化来累加价值，最终取最大值来更新 <code>f[x][0]</code> 和 <code>f[x][1]</code>。</li>
</ul>
</li>
<li>
<p><strong>确定初始状态与最终答案：</strong></p>
<ul>
<li><strong>叶子节点：</strong> 作为DP递推的终点，叶子节点的DP值通常可以直接根据它们的自身属性（不考虑子树）来初始化。</li>
<li><strong>最终答案：</strong> 经过整个DFS过程，根节点的特定DP状态（例如 <code>dp[root][0]</code> 或所有根状态中的最优值，取决于问题要求）即为整个树的最终解。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-适用场景-1">3. 适用场景
</h4><p>Tree DP 适用于以下类型的优化问题：</p>
<ul>
<li><strong>树上的最大/最小化问题：</strong> 目标是在给定树结构上寻找某种属性的最大或最小值（如最大价值和、最小代价路径、最少删除边等）。</li>
<li><strong>决策与子树状态相关：</strong> 当对一个节点做出的决策会影响其整个子树的属性，并且这种影响可以被子树的DP状态精确概括时。</li>
<li><strong>局部决策影响全局最优：</strong> 整体问题的最优解可以通过合并局部子树的最优解来获得（满足最优子结构）。</li>
<li><strong>信息聚合：</strong> 某个节点的DP值需要综合其所有子节点的DP信息来计算。</li>
<li><strong>无后效性：</strong> 一旦某个节点的DP值被计算出来，它就成为了一个固定的信息块，不会再被后续的子问题计算所修改，其对其他部分的影射也完全体现在其DP状态中。</li>
</ul>
<p>通过精确定义状态、巧妙设计转移方程和利用DFS的递归结构，Tree DP 能够高效地解决各种复杂的树上优化问题。</p>
<h2 id="区间融合">区间融合
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">begin</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">        <span class="n">it</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">&amp;&amp;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">&amp;&amp;</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">&gt;=</span><span class="n">left</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">left</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">right</span><span class="o">=</span><span class="n">max</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">cnt</span><span class="o">-=</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">mp</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">it</span><span class="o">=</span><span class="n">mp</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">it</span><span class="o">!=</span><span class="n">mp</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span><span class="n">it</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cnt</span><span class="o">+=</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mp</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">=</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="查分数组性质">查分数组性质
</h2><blockquote>
<p>[!NOTE]</p>
<p>（对于子数组数组的连续加减可以转换成对于两个元素的加减）</p></blockquote>
<p><img src="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520110627670.png"
	width="1368"
	height="668"
	srcset="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520110627670_hu_59fb5bfd73d49519.png 480w, /huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520110627670_hu_a6f0608d2c848ff8.png 1024w"
	loading="lazy"
	
		alt="image-20250520110627670"
	
	
		class="gallery-image" 
		data-flex-grow="204"
		data-flex-basis="491px"
	
></p>
<p><img src="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520110653471.png"
	width="1382"
	height="996"
	srcset="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520110653471_hu_50fddfed8cb9b1d5.png 480w, /huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520110653471_hu_60febc2b7a7eb1af.png 1024w"
	loading="lazy"
	
		alt="image-20250520110653471"
	
	
		class="gallery-image" 
		data-flex-grow="138"
		data-flex-basis="333px"
	
></p>
<p>适用于的题目：3355.</p>
<h2 id="从环染色到递推思想">从环染色到递推思想
</h2><p>下面的内容取之于原贴：https://zhuanlan.zhihu.com/p/469651849?share_code=1kwOskN7LMwwq&amp;utm_psn=1908119624903534021</p>
<p>用m种颜色给n边形的n条边染色，要求邻边不同色，求方法数。（m,n≥3）</p>
<p><img src="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/v2-86c5c782afd6a1c32962795e8719fb63_1440w.jpg"
	width="504"
	height="422"
	srcset="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/v2-86c5c782afd6a1c32962795e8719fb63_1440w_hu_2d7786579c6ebf10.jpg 480w, /huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/v2-86c5c782afd6a1c32962795e8719fb63_1440w_hu_a5089d7acd443bc3.jpg 1024w"
	loading="lazy"
	
		alt="img"
	
	
		class="gallery-image" 
		data-flex-grow="119"
		data-flex-basis="286px"
	
></p>
<p><img src="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520112247847.png"
	width="1360"
	height="1516"
	srcset="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520112247847_hu_31ab0d240babef7d.png 480w, /huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520112247847_hu_bbc2e8dba4f5e280.png 1024w"
	loading="lazy"
	
		alt="image-20250520112247847"
	
	
		class="gallery-image" 
		data-flex-grow="89"
		data-flex-basis="215px"
	
></p>
<p><img src="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520112315443.png"
	width="1350"
	height="358"
	srcset="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520112315443_hu_3d83a714daf9eb26.png 480w, /huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250520112315443_hu_bc51b1b1058e07ec.png 1024w"
	loading="lazy"
	
		alt="image-20250520112315443"
	
	
		class="gallery-image" 
		data-flex-grow="377"
		data-flex-basis="905px"
	
></p>
<p>对于上面的式子，我们可以使用乘法的快速幂方法来做。</p>
<blockquote>
<p>[!NOTE]</p>
<p>思考上面的过程是一种什么样子的过程：</p>
<p>从A1到An的求解过程中我们发现其中限制最多的位置是最后一个位置，也就是说我们在求解除了An位置以外，对于其他的位置总共的可能情况都是m-1中方式。而对于最后一个An的判定方法，我们需要分情况讨论An前后位置是否为同一个颜色。对于这种情况我们能够入手的地方是：</p>
<ul>
<li>从后往前推导：分情况讨论假如An-1是和A1同色的情况，假如An-1和A1不同色的情况，但是很快我们发现我们在分情况讨论An-1的颜色的时候就会牵扯到An-2的情况，这样分情况讨论就会陷入循环中。</li>
<li>从前往后推到：从n=1开始先试一试n=2，3，4.。。的情况，尝试在其中发现规律。</li>
</ul>
<p>但是我们发现在上面方法中提到思路并不是这两种方法，所以这里就有第三种思路：</p>
<p>最简单化，看看在取消了最后一个限制的情况下（也就是将染色问题从环变成直线）会有什么结果，然后我们呢就可以发现分为两种结果：</p>
<ol>
<li>An和A1同色，对于这种情况我们可以直接将An和A1首位相连，因为这两个同色，所以我们可以将他看作是将将A1和An融合起来，这样子的结果和融合前后没有任何变化，但是我们惊奇地发现此时A1到An-1的可能性数量就是Sn-1，因为A1一定和An-1颜色不同。</li>
<li>假如An和A1不同色，那么显然可能性的数量就是Sn。</li>
</ol>
<p>综上就能够发现递推关系。</p>
<p>但是我们现在来看一看从后往前求解思路的可能性，因为这种将A1和An同色融合的trick有点困难。</p>
<p>设置k为颜色的数量：</p>
<p>我们不妨将An-1和A1颜色相同的可能性数量设置为Bn-1，颜色相同的可能性设置为Cn-1，那么显然Sn=Bn-1*(k-1)+Cn-1*(k-2).</p>
<p>Bn=Cn-1,Cn=Cn-1*(k-2)+Bn-1*(k-1),由此也可以求出来递推公式。</p>
<p>下面是GPT的回答：</p>
<h1 id="环染色问题的递推关系证明思路">环染色问题的递推关系证明思路
</h1><h2 id="1-问题定义与符号约定">1. 问题定义与符号约定
</h2><p>我们要计算用 $k$ 种颜色给一个由 $n$ 个块组成的环 ($A_1, A_2, \ldots, A_n$) 进行染色，要求相邻的块颜色不同的方案数。设最终的方案数为 $S_n$。</p>
<h2 id="2-辅助状态定义-路径染色">2. 辅助状态定义 (路径染色)
</h2><p>为了从后往前（或者说，通过构建的方式）推导，我们定义以下两种状态，用于描述对一个<strong>线性路径</strong> $A_1, A_2, \ldots, A_i$ 进行染色，且满足相邻元素颜色不同的方案数：</p>
<ul>
<li>$B_i$: 路径 $A_1, \ldots, A_i$ 的染色方案数，其中首元素 $A_1$ 和尾元素 $A_i$ 的颜色<strong>相同</strong>。</li>
<li>$C_i$: 路径 $A_1, \ldots, A_i$ 的染色方案数，其中首元素 $A_1$ 和尾元素 $A_i$ 的颜色<strong>不同</strong>。</li>
</ul>
<h2 id="3-递推关系的建立">3. 递推关系的建立
</h2><h3 id="31-b_i-的递推关系">3.1. $B_i$ 的递推关系
</h3><p>要使路径 $A_1, \ldots, A_i$ 的首尾颜色相同 ($A_i$ 与 $A_1$ 同色)，且 $A_i$ 与 $A_{i-1}$ 颜色不同：</p>
<ul>
<li>$A_i$ 的颜色必须与 $A_1$ 的颜色一致 (1 种选择)。</li>
<li>$A_{i-1}$ 的颜色必须与 $A_i$ 的颜色不同，也就是说 $A_{i-1}$ 的颜色必须与 $A_1$ 的颜色不同。</li>
<li>因此，对路径 $A_1, \ldots, A_{i-1}$ 进行染色，要求 $A_{i-1}$ 与 $A_1$ 颜色不同，这样的方案数是 $C_{i-1}$。</li>
</ul>
<p>所以，
</p>
$$ B_i = C_{i-1} $$<h3 id="32-c_i-的递推关系">3.2. $C_i$ 的递推关系
</h3><p>要使路径 $A_1, \ldots, A_i$ 的首尾颜色不同 ($A_i$ 与 $A_1$ 不同色)，且 $A_i$ 与 $A_{i-1}$ 颜色不同：</p>
<ul>
<li>
<p><strong>情况一</strong>: 路径 $A_1, \ldots, A_{i-1}$ 中，$A_{i-1}$ 与 $A_1$ 的颜色<strong>相同</strong>。</p>
<ul>
<li>这种染色方案有 $B_{i-1}$ 种。</li>
<li>此时，$A_i$ 的颜色只需与 $A_{i-1}$ (也就是 $A_1$) 不同即可。有 $k-1$ 种选择。</li>
<li>这些选择都将使得 $A_i$ 与 $A_1$ 不同色。</li>
<li>贡献: $B_{i-1} \times (k-1)$。</li>
</ul>
</li>
<li>
<p><strong>情况二</strong>: 路径 $A_1, \ldots, A_{i-1}$ 中，$A_{i-1}$ 与 $A_1$ 的颜色<strong>不同</strong>。</p>
<ul>
<li>这种染色方案有 $C_{i-1}$ 种。</li>
<li>此时，$A_i$ 的颜色既要与 $A_{i-1}$ 不同，也要与 $A_1$ 不同。由于 $A_{i-1}$ 和 $A_1$ 的颜色已经不同，所以 $A_i$ 有 $k-2$ 种选择。</li>
<li>贡献: $C_{i-1} \times (k-2)$。</li>
</ul>
</li>
</ul>
<p>所以，
</p>
$$ C_i = (k-1)B_{i-1} + (k-2)C_{i-1} $$<h2 id="4-环染色方案数-s_n-的表达式">4. 环染色方案数 $S_n$ 的表达式
</h2><p>现在考虑对环 $A_1, \ldots, A_n$ 进行染色。我们可以先对路径 $A_1, \ldots, A_{n-1}$ 进行染色，然后确定 $A_n$ 的颜色。$A_n$ 必须与 $A_{n-1}$ 和 $A_1$ 的颜色都不同。</p>
<ul>
<li>
<p><strong>如果 $A_{n-1}$ 与 $A_1$ 同色</strong> (方案数为 $B_{n-1}$):</p>
<ul>
<li>$A_n$ 只需与 $A_{n-1}$ (也就是 $A_1$) 不同色即可。有 $k-1$ 种选择。</li>
<li>贡献: $B_{n-1} \times (k-1)$。</li>
</ul>
</li>
<li>
<p><strong>如果 $A_{n-1}$ 与 $A_1$ 不同色</strong> (方案数为 $C_{n-1}$):</p>
<ul>
<li>$A_n$ 必须与 $A_{n-1}$ 不同色，且与 $A_1$ 不同色。由于 $A_{n-1}$ 和 $A_1$ 的颜色已不同， $A_n$ 有 $k-2$ 种选择。</li>
<li>贡献: $C_{n-1} \times (k-2)$。</li>
</ul>
</li>
</ul>
<p>因此，环染色的总方案数 $S_n$ 为：
</p>
$$ S_n = (k-1)B_{n-1} + (k-2)C_{n-1} $$<h2 id="5-s_n-与-c_n-的关系">5. $S_n$ 与 $C_n$ 的关系
</h2><p>比较 $S_n$ 的表达式和 $C_i$ 的递推公式，我们发现：
</p>
$$ S_n = (k-1)B_{n-1} + (k-2)C_{n-1} $$<p>
</p>
$$ C_n = (k-1)B_{n-1} + (k-2)C_{n-1} $$<p>
由此可见，$S_n = C_n$。
这符合直觉：对一个 $n$ 块的环进行染色，等价于对一个 $n$ 块的路径进行染色，并要求路径的首尾两块颜色不同。</p>
<h2 id="6-最终递推公式">6. 最终递推公式
</h2><p>将 $B_{i-1} = C_{i-2}$ 代入 $C_i$ (或 $S_i$) 的表达式中：
</p>
$$ C_i = (k-2)C_{i-1} + (k-1)B_{i-1} $$<p>
</p>
$$ C_i = (k-2)C_{i-1} + (k-1)C_{i-2} $$<p>
所以，环染色方案数 $S_n (=C_n)$ 的递推公式为：
</p>
$$ S_n = (k-2)S_{n-1} + (k-1)S_{n-2} \quad (\text{对于 } n \ge 3) $$<h2 id="7-初始条件">7. 初始条件
</h2><ul>
<li>
<p><strong>$S_1 (=C_1)$</strong>:</p>
<ul>
<li>对于 $C_1$ (路径 $A_1$，要求 $A_1 \ne A_1$)：$C_1 = 0$。</li>
<li>对于 $S_1$ (单个块的环)：没有相邻块，可以染任意 $k$ 种颜色。$S_1 = k$。</li>
<li><em>注意</em>: 这里的 $S_n$ 和 $C_n$ 的关系在 $n=1$ 时需要小心。通常，递推公式从 $n \ge 3$ 开始， $S_1, S_2$ 单独计算。如果严格使用 $S_n=C_n$，则 $S_1=0$，这与单个块的环有 $k$ 种染色的直观理解不同。经典环染色公式 $(k-1)^n + (-1)^n(k-1)$ 在 $n=1$ 时也给出 $0$。如果题目定义 $n=1$ 时为 $k$ 种，则 $S_1=k$ 是特殊情况。</li>
</ul>
</li>
<li>
<p><strong>$S_2 (=C_2)$</strong>:</p>
<ul>
<li>$B_1 = k$ (路径 $A_1$，$A_1$ 与 $A_1$ 同色，有 $k$ 种方案)。</li>
<li>$C_2 = (k-1)B_1 + (k-2)C_1 = (k-1)k + (k-2) \cdot 0 = k(k-1)$。</li>
<li>$S_2 = k(k-1)$。 (环 $A_1,A_2$: $A_1$ 有 $k$ 种选择，$A_2$ 有 $k-1$ 种选择)。</li>
</ul>
</li>
<li>
<p><strong>$S_3 (=C_3)$</strong>:</p>
<ul>
<li>$C_3 = (k-2)C_2 + (k-1)C_1 = (k-2)k(k-1) + (k-1) \cdot 0 = k(k-1)(k-2)$。</li>
<li>$S_3 = k(k-1)(k-2)$。</li>
</ul>
</li>
</ul>
<p>这个递推公式与已知的环染色问题的结果是一致的。</p></blockquote>
<h3 id="1传球问题">（1）传球问题
</h3><p><em><strong>Q.</strong> m个人进行篮球传球游戏，规则为每个人接球后再传给别人。规定由甲第一次传球，若第n次传球后，球又回到甲的手中，求所有的传球方法数。</em></p>
<p>相信读者或多或少接触过这种题，笔者将从递推的角度给出此类题的通解。</p>
<p>受此前的启发，我们不妨反过来考虑。暂且不管第 次传给了谁，注意到第 次传球后拿到球的人把球传给甲就行了，因此总方法数为 次传球的方法数即 。但是如果第 次传球给了甲，由于他不能传给自己，因此这种情况是不成立的，减去即可。设第 次传球后回到甲手中的方法数为 ，我们得到递推式 ，整理得</p>
<p>边界条件 （甲第一次只能传给别人）。这个递推式的处理方法和多边形染色的是一模一样的，因此这里不加证明地给出结果</p>
<h3 id="2">(2)
</h3><p>***Q.*<em>某人计划给8块牌子涂色，每块牌子可选用红、蓝中的一种颜色喷涂。若要求相邻两块牌子不都为红色，试求所有的染色方案数。</em></p>
<p>“相邻不都为红色”用正难则反也很难处理，我们先从规模较小的情况找找灵感。</p>
<p>设有n块牌子时涂色方案数有 种</p>
<p>若有2块牌子:</p>
<p>1.第一块涂蓝色，则第二块可以是红色或者蓝色，有两种</p>
<p>2.第一块涂红色，则第二块只能是蓝色，有一种</p>
<p>若有3块牌子：</p>
<p>若第一块涂蓝色</p>
<p>等等我们发现了什么！</p>
<p>第一块涂蓝色的时候，第二块可以涂红色或者蓝色。我们注意到，如果某一块涂了蓝色，那么下一块的涂色没有任何限制（红蓝都可以涂），相当于可以扔掉前面那些已经涂好的牌子，从下一块重新开始规划这个问题！</p>
<p>因此，如果第1块涂蓝色，则之后的 块牌子有 种涂色方法数</p>
<p>这太让人振奋了。可问题还没有结束，根据分类加法原理，我们只需要再看看第一块涂红色的情形</p>
<p>若第一块涂红色</p>
<p>如果第一块涂红，那么第二块必须涂蓝。！！这是不是又回到了第一种情况？这种情况下，剩下的 块有 种涂色方法数</p>
<p>因此我们得到递推关系</p>
<p>边界 。由递推关系得到答案</p>
<p>（此题没有必要求出通项公式）</p>
<h3 id="3全错位排列问题">(3)<a class="link" href="https://zhida.zhihu.com/search?content_id=192498207&amp;content_type=Article&amp;match_order=1&amp;q=%e5%85%a8%e9%94%99%e4%bd%8d%e6%8e%92%e5%88%97&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDc4ODM5ODQsInEiOiLlhajplJnkvY3mjpLliJciLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxOTI0OTgyMDcsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.2I5z29BbhABKOFn9Kqf57yny_XRf1mQ9gVbyxHjtwg0&amp;zhida_source=entity"  target="_blank" rel="noopener"
    >全错位排列</a>问题
</h3><p>***Q.*<em>一个人写了n封不同的信及相应的n个不同的信封，他把这n封信都装错了信封，问有多少种方法？</em></p>
<p>我们假设正确对应关系为第 个信封分别应该装第 封信， 封信全部错位放的方法有 种</p>
<p>考虑其中一封信 ，显然 不能放到第 个信封，总共有 种错位放法</p>
<p>记 错装到第 个位置，考虑被挤占的 怎么放</p>
<p>1.如果 放到第 个位置，也就是说和 调换顺序，那它俩都错放了满足题意，只需要考虑剩下 封信怎么错位排，有 种方法</p>
<p>2.如果 放到第 个位置之外的位置，那么只需要考虑包含 在内剩下 封信怎么错位排，有 种方法</p>
<p>由分类加法原理和分步乘法原理可知</p>
<p>P.S*.*</p>
<p><em>1.给出一个数学归纳得到的便于计算的递推公式</em></p>
<p><em>2.给出通项公式 （计算不如上面的递推方便）</em></p>
<p><em>3.对于<strong>问题的推广</strong>，若 封信中恰有 封信装错，则方法数 。很简单，只需要先把n封信全部装对，然后选出m封需要装错的，再将m封信全错位排列，根据乘法原理便能得到上面的结果。</em></p>
<h2 id="二分查找在满足单调性条件的函数中寻找特定边界值">二分查找在满足单调性条件的函数中寻找特定边界值
</h2><p><img src="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250521111940337.png"
	width="1806"
	height="504"
	srcset="/huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250521111940337_hu_a8abab3cb648bc5e.png 480w, /huyang/p/leetcode%E7%AE%97%E6%B3%95%E6%80%9D%E8%80%83/image-20250521111940337_hu_381308a0cd285228.png 1024w"
	loading="lazy"
	
		alt="image-20250521111940337"
	
	
		class="gallery-image" 
		data-flex-grow="358"
		data-flex-basis="860px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">max_val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 或者一个不可能的值，用于存储最终结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 或者 left &lt; right, 根据具体边界处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mid 满足条件，尝试更小的 mid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">result</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// 记录当前满足条件的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 继续向左搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// mid 不满足条件，需要更大的 mid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 向右搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="如何识别与解决贪心算法问题-">如何识别与解决贪心算法问题 🧐
</h2><h3 id="1-识别贪心问题"><strong>1. 识别贪心问题</strong>
</h3><ul>
<li><strong>目标是最优化 + 满足约束：</strong> 题目通常要求在满足特定约束条件的前提下，求解某个指标的<strong>最小值</strong>或<strong>最大值</strong>。
<ul>
<li>你准确地指出了“使用最少的query数组”是贪心算法的一个重要信号。</li>
</ul>
</li>
<li><strong>与动态规划 (DP) 的区别：</strong>
<ul>
<li><strong>DP</strong>：通过将问题分解为子问题，并从子问题的最优解逐步构建整体最优解。DP 通常会探索多种可能性，状态转移和依赖关系是核心。</li>
<li><strong>贪心算法</strong>：在每一步都做出<strong>当前看起来最优</strong>的选择，并期望通过一系列局部最优选择达到全局最优。一旦做出选择，通常不会“反悔”或重新评估。决策是即时且针对当前步骤的。</li>
</ul>
</li>
<li><strong>“最少代价/工具”或“最大即时收益”：</strong> 像“用最少的物品”，“在这一步获得最大价值”，或者“用当前最佳选项满足当前需求”这类描述，常常暗示了贪心策略。你提到的“在满足某个条件下面使用最少的Utility优化问题”与此非常吻合。</li>
</ul>
<hr>
<h3 id="2-构建贪心策略"><strong>2. 构建贪心策略</strong>
</h3><p>一旦怀疑是贪心问题，下一步的关键就是确定“如何贪心”。</p>
<ul>
<li><strong>明确“贪心选择”是什么：</strong> 在问题的每一步，你能做出什么样的决策，使得当前情况看起来是最佳的？这个选择需要基于某种启发式规则或标准。</li>
<li><strong>排序作为预处理步骤：</strong>
<ul>
<li>许多贪心问题的第一步是对输入的“工具”（例如，区间、任务、物品）按照某个特定标准进行排序。排序有助于结构化决策过程。</li>
<li>正如你所说：“一般来说贪心是将我们所有的Util按照某一种条件排序，然后根据这个排序对于我们要解决的Staff进行解决。”</li>
<li><strong>静态排序：</strong> 如果一个固定的、全局的排序标准能够让你顺序遍历元素并做出决策，那么简单的 <code>sort()</code> 通常就足够了（例如，按区间起始点或结束点排序）。</li>
</ul>
</li>
<li><strong>使用堆（优先队列）进行动态优先级排序：</strong>
<ul>
<li>有时，“最佳”选择并不仅仅由一个固定的全局排序决定。可用的“工具”集合或者选择的优先级可能会随着你处理主问题（“Staff”）的进度而动态变化。</li>
<li>你准确地指出了：“对于条件复杂的题目，我们需要使用最大堆或者最小堆来进行排序……这种判断条件不是一种静态条件，而是一种动态更新的条件，或者说是在迭代数组中，对于堆进行更新的。”</li>
<li><strong>何时使用堆：</strong> 当你在迭代过程中（例如，遍历 <code>nums</code> 数组到索引 <code>i</code>），需要在每个步骤 <code>i</code> 从一个动态变化的当前<em>活跃</em>或<em>可用</em>“工具”集合中，根据某个优先级选出最优的那个。堆能够高效地管理这个活跃集合，并快速获取最高（或最低）优先级的元素。</li>
</ul>
</li>
<li><strong>定义堆的排序标准（贪心核心）：</strong>
<ul>
<li>这通常是最具挑战性的一步。你问到：“怎么来说我们才能够贪心选择覆盖掉位置i的区间使得Utility最大化？（也就是堆的判断条件）”。</li>
<li>你的洞察——“那就是这个覆盖了位置i的query要尽可能的覆盖掉未来的位置，所以堆排序的条件应该是最大的区间右端点”——是区间问题中一个经典且往往有效的贪心启发式规则。这种策略旨在让每一个被选择的区间尽可能地对后续的需求产生“价值”。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-贪心算法配合堆的通用模板类似你的题目"><strong>3. 贪心算法配合堆的通用模板（类似你的题目）</strong>
</h3><p>你的思考过程导向了这类问题的一个常见解决模式：</p>
<ol>
<li>
<p><strong>预处理（可选但常见）：</strong></p>
<ul>
<li>如果按特定顺序处理“工具”（例如 <code>queries</code>）有助于后续决策，则先对其进行排序（例如，按起始点 <code>q[0]</code> 排序）。</li>
</ul>
</li>
<li>
<p><strong>迭代与状态管理：</strong></p>
<ul>
<li>遍历主问题的元素（例如，<code>nums</code> 数组，从 <code>i = 0</code> 到 <code>n-1</code>）。</li>
<li>维护当前已做选择的“状态”或“效果”（例如，你的 <code>sum</code> 代表当前的覆盖程度，对于区间问题，通常使用<strong>差分数组</strong>来管理）。</li>
</ul>
</li>
<li>
<p><strong>动态更新候选池（堆）：</strong></p>
<ul>
<li>当你处理到 <code>nums[i]</code> 时，将所有新近可用的“工具”加入堆中。对于区间问题，这通常是那些起始点 <code>q[0]</code> 现在 <code>&lt;= i</code> 的区间。</li>
</ul>
</li>
<li>
<p><strong>做出贪心选择：</strong></p>
<ul>
<li>如果当前状态不满足在 <code>i</code> 点的需求（例如，<code>sum &lt; nums[i]</code>）：
<ul>
<li>检查堆中是否有有效的候选者（例如，<code>!pq.empty()</code> 并且堆顶的区间确实覆盖了 <code>i</code>，如 <code>pq.top().b &gt;= i</code>）。</li>
<li>如果有，根据你的贪心标准从堆中选择“最佳”的一个（例如，弹出具有最大右端点 <code>b</code> 的区间）。</li>
<li>根据这个选择更新你的状态（例如，<code>sum++</code>，并更新差分数组以反映所选区间的效果：<code>diff_nums[pq.top().b + 1]--</code>）。</li>
<li>重复此过程，直到在 <code>i</code> 点的需求得到满足，或者堆中没有更多有效的候选者。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>检查可行性：</strong></p>
<ul>
<li>在尝试做出贪心选择后，如果在 <code>i</code> 点的需求仍然未被满足，那么就无法满足所有条件，此时可能返回 <code>-1</code> 或其他相应的失败指示。</li>
</ul>
</li>
<li>
<p><strong>最终结果：</strong></p>
<ul>
<li>结果可能是已做选择的计数、堆的最终状态（在你的例子中是 <code>pq.size()</code>，代表了那些可用但未被使用的物品），或根据具体问题定义的其他值。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="为什么使用差分数组"><strong>为什么使用差分数组？🤔</strong>
</h3><p>你提到：“在我们选择了某一个query的时候，怎么对于未来位置的i+1，i+2，，，起到作用的。这里我们使用的是差分数组。这里的思路比较复杂，所以我们直接看题解。”</p>
<ul>
<li><strong>差分数组</strong>是一种能够高效处理区间更新的技术。当你选择一个区间 <code>[start, end]</code> 来施加某种效果（比如覆盖度增加1）时，你不需要遍历从 <code>start</code> 到 <code>end</code> 的所有点来更新一个直接记录覆盖度的数组，而是可以：
<ul>
<li>使 <code>diff[start]</code> 增加 1。</li>
<li>使 <code>diff[end + 1]</code> 减少 1。</li>
</ul>
</li>
<li>然后，任何点 <code>i</code> 的实际覆盖度可以通过计算差分数组 <code>diff</code> 到 <code>i</code> 为止的前缀和来得到（这正是你的 <code>sum += diff_nums[i]</code> 步骤所做的事情）。</li>
<li>当涉及到大量区间更新时，这种方法至关重要，因为每次选择区间只需要对差分数组进行两次更新，而不是对一个直接的覆盖数组进行可能很多次的更新，从而大大提高了效率。</li>
</ul>
<hr>
<p>这个源于你自身洞察的结构化方法，为你解决类似的贪心优化问题（尤其是涉及区间和动态选择的问题）提供了一个坚实的框架。关键始终在于清晰地定义局部最优选择（贪心选择）以及如何进行这种选择（通过排序或堆的优先级）。</p>
<h2 id="图的拓扑排序">图的拓扑排序
</h2><p>在什么时候需要对于一个图进行拓扑排序：</p>
<p>求解图的某一条路径，在求解每一个节点的时候需要先处理它的子节点，图不给根节点的时候，这个时候只要优先进行拓扑排序，就能够先处理好节点之间的依赖关系，并且能够从依赖最小的节点开始按照拓扑序来进行动态规划。</p>
<h3 id="dfs-拓扑排序算法">DFS 拓扑排序算法
</h3><p>DFS 拓扑排序算法通过深度优先遍历图，并在回溯时将节点添加到结果列表中。这种方法得到的拓扑序列是<strong>逆拓扑序</strong>，即如果存在从 A 到 B 的边，那么在结果中 B 会出现在 A 之前。</p>
<p><strong>1. 核心思想</strong></p>
<ul>
<li>对图进行深度优先遍历。</li>
<li>使用一个 <code>visited</code> 数组来标记节点的访问状态，同时用于检测环。</li>
<li>当一个节点的所有邻接（子）节点都已访问完毕后，将其添加到拓扑排序的结果列表中。</li>
</ul>
<p><strong>2. 节点状态定义</strong></p>
<ul>
<li><code>visited[i] = 0</code>: 节点 <code>i</code> 未被访问。</li>
<li><code>visited[i] = 1</code>: 节点 <code>i</code> 正在被访问（位于当前 DFS 递归栈中），用于检测环。</li>
<li><code>visited[i] = 2</code>: 节点 <code>i</code> 已被完全访问（其所有后继节点都已处理完毕）。</li>
</ul>
<p><strong>3. 算法步骤</strong></p>
<ol>
<li>
<p><strong>初始化：</strong></p>
<ul>
<li><code>adj</code>：图的邻接表。</li>
<li><code>visited</code>：大小为 <code>N</code> 的数组，所有元素初始化为 <code>0</code>。</li>
<li><code>topological_order</code>：空列表，用于存储拓扑排序结果。</li>
<li><code>has_cycle</code>：布尔变量，初始化为 <code>false</code>。</li>
</ul>
</li>
<li>
<p><strong>主循环：</strong></p>
<ul>
<li>遍历图中的每一个节点 <code>i</code> 从 <code>0</code> 到 <code>N-1</code>。</li>
<li>如果 <code>visited[i] == 0</code>（即节点未被访问）：
<ul>
<li>调用 <code>dfs(i, adj, visited, topological_order, has_cycle)</code>。</li>
<li>如果 <code>has_cycle</code> 变为 <code>true</code>，则图包含环，拓扑排序失败（返回错误或空列表）。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DFS 函数 <code>dfs(node, adj, visited, topological_order, has_cycle)</code>：</strong></p>
<ul>
<li>将 <code>visited[node]</code> 设置为 <code>1</code>（访问中）。</li>
<li><strong>遍历 <code>node</code> 的所有邻接（后继）节点 <code>neighbor</code>：</strong>
<ul>
<li>如果 <code>has_cycle</code> 已经为 <code>true</code>，直接返回（剪枝）。</li>
<li>如果 <code>visited[neighbor] == 1</code>：
<ul>
<li>发现环！将 <code>has_cycle</code> 设置为 <code>true</code>，并返回。</li>
</ul>
</li>
<li>如果 <code>visited[neighbor] == 0</code>：
<ul>
<li>递归调用 <code>dfs(neighbor, adj, visited, topological_order, has_cycle)</code>。</li>
</ul>
</li>
</ul>
</li>
<li>当 <code>node</code> 的所有邻接节点都处理完毕后：
<ul>
<li>将 <code>visited[node]</code> 设置为 <code>2</code>（已访问）。</li>
<li>将 <code>node</code> 添加到 <code>topological_order</code> 列表的<strong>末尾</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>4. 结果</strong></p>
<ul>
<li>如果 <code>has_cycle</code> 为 <code>true</code>，则图不是有向无环图（DAG），无法进行拓扑排序。</li>
<li>否则，<code>topological_order</code> 列表包含图的逆拓扑排序。如果需要正拓扑序，将该列表反转即可。</li>
</ul>
<hr>
<p><strong>C++ 代码示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"> </span><span class="c1">// For std::reverse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// visited 数组状态：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 0: 未访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1: 访问中（正在当前 DFS 递归栈中）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2: 已访问（DFS 已经从该节点及其所有子节点返回）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="n">dfs_toposort</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">adj</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">topological_order</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">has_cycle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果已经检测到环，直接返回，不再进行后续遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">has_cycle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 标记当前节点为“访问中”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历当前节点的所有邻接点（后继节点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">neighbor</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 发现环：如果邻接点正在访问中，说明有环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">has_cycle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span><span class="p">;</span> <span class="c1">// 立即返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果邻接点未访问，则递归调用 DFS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">dfs_toposort</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">topological_order</span><span class="p">,</span> <span class="n">has_cycle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">has_cycle</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 递归调用返回后，再次检查是否发现环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">return</span><span class="p">;</span> <span class="c1">// 如果发现环，直接向上返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 当所有邻接点都处理完毕后，将当前节点标记为“已访问”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将节点加入拓扑排序结果。由于是 DFS 回溯时加入，topological_order 将是逆拓扑序。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">topological_order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 主函数，执行拓扑排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getTopologicalOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">adj</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topological_order</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">has_cycle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 对所有未访问的节点进行 DFS，构建拓扑排序序列并检测环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">dfs_toposort</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">topological_order</span><span class="p">,</span> <span class="n">has_cycle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">has_cycle</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果在某个 DFS 路径中发现环，则返回空列表或抛出异常
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">return</span> <span class="p">{};</span> <span class="c1">// 表示存在环，无法进行拓扑排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 得到的 topological_order 是逆拓扑序，需要反转得到正拓扑序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">topological_order</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">topological_order</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">topological_order</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="kahn-算法-基于入度">Kahn 算法 (基于入度)
</h3><p>Kahn 算法是另一种实现拓扑排序的常用方法，它基于不断移除图中入度为 0 的节点。</p>
<p><strong>1. 核心思想</strong></p>
<ul>
<li>找出图中所有入度为 0 的节点（即没有前置依赖的节点）。</li>
<li>将这些节点加入到一个队列中。</li>
<li>从队列中取出一个节点，将其添加到拓扑排序结果中，并“移除”它，同时更新其所有邻接节点的入度。</li>
<li>重复上述过程，直到队列为空。</li>
</ul>
<p><strong>2. 算法步骤</strong></p>
<ol>
<li>
<p><strong>初始化：</strong></p>
<ul>
<li><code>adj</code>：图的邻接表。</li>
<li><code>indegree</code>：大小为 <code>N</code> 的数组，<code>indegree[i]</code> 存储节点 <code>i</code> 的入度。</li>
<li><code>q</code>：一个队列。</li>
<li><code>topological_order</code>：空列表，用于存储拓扑排序结果。</li>
</ul>
</li>
<li>
<p><strong>计算所有节点的入度：</strong></p>
<ul>
<li>遍历图中的所有边 <code>(u, v)</code>。</li>
<li>对于每条边，将 <code>indegree[v]</code> 加 1。</li>
</ul>
</li>
<li>
<p><strong>初始化队列：</strong></p>
<ul>
<li>遍历所有节点 <code>i</code> 从 <code>0</code> 到 <code>N-1</code>。</li>
<li>如果 <code>indegree[i] == 0</code>，将节点 <code>i</code> 加入队列 <code>q</code>。</li>
</ul>
</li>
<li>
<p><strong>主循环 (BFS 过程)：</strong></p>
<ul>
<li>当队列 <code>q</code> 不为空时：
<ul>
<li>从队列 <code>q</code> 中取出队头节点 <code>u</code>。</li>
<li>将 <code>u</code> 添加到 <code>topological_order</code> 列表的<strong>末尾</strong>。</li>
<li><strong>遍历 <code>u</code> 的所有邻接（后继）节点 <code>v</code>：</strong>
<ul>
<li>将 <code>indegree[v]</code> 减 1（表示移除了 <code>u</code> 对 <code>v</code> 的依赖）。</li>
<li>如果 <code>indegree[v]</code> 变为 <code>0</code>，则将 <code>v</code> 加入队列 <code>q</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>5. 环检测</strong></p>
<ul>
<li>在算法结束后，检查 <code>topological_order</code> 列表的长度。</li>
<li>如果 <code>topological_order.size()</code> 等于图中的总节点数 <code>N</code>，则表示成功构建了拓扑排序，图中无环。</li>
<li>如果 <code>topological_order.size()</code> 小于 <code>N</code>，则表示图中存在环，无法对所有节点进行拓扑排序。</li>
</ul>
<hr>
<p><strong>C++ 代码示例</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"> </span><span class="c1">// Not strictly needed for Kahn, but common utilities
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取图的拓扑排序（Kahn 算法）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getTopologicalOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 邻接表，存储图的边
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 入度数组，存储每个节点的入度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">indegree</span><span class="p">(</span><span class="n">num_nodes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 构建图和计算入度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">edge</span> <span class="p">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">indegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 节点 v 的入度增加 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 拓扑排序使用的队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 存储拓扑排序结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topological_order</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 将所有入度为 0 的节点加入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// BFS 遍历过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">topological_order</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="c1">// 将当前节点加入结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 遍历 u 的所有邻接点 v
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">indegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 移除 u 对 v 的依赖，v 的入度减 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果 v 的入度变为 0，则加入队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 环检测：如果拓扑排序结果的节点数量不等于图的总节点数量，说明存在环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">topological_order</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">num_nodes</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="p">{};</span> <span class="c1">// 返回空列表表示存在环，无法进行拓扑排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">topological_order</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="组合数递推关系">组合数递推关系
</h2><p>组合数遵循帕斯卡恒等式（Pascal&rsquo;s Identity）：
</p>
$$C(n, k) = C(n-1, k-1) + C(n-1, k)$$<p>
此公式适用于 $1 \le k \le n-1$。</p>
<p><strong>边界条件</strong> (Base Cases):</p>
<ol>
<li>$C(n, 0) = 1$  （对于 $n \ge 0$）：从 $n$ 个元素中选 0 个，只有一种方法（选择空集）。</li>
<li>$C(n, n) = 1$  （对于 $n \ge 0$）：从 $n$ 个元素中选 $n$ 个，只有一种方法（选择所有元素）。</li>
<li>$C(n, k) = 0$  如果 $k &gt; n$ 或 $k &lt; 0$。</li>
</ol>
<p>这条递推关系是构建帕斯卡三角形的基础。</p>
<hr>
<h3 id="c-计算组合数代码">C++ 计算组合数代码
</h3><p>下面是一个使用动态规划（基于上述递推关系并优化空间复杂度）计算组合数的 C++ 函数。该方法通常称为“杨辉三角”或“帕斯卡三角形”的逐行计算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"> </span><span class="c1">// 用于 std::min
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 函数计算组合数 C(n, k)
</span></span></span><span class="line"><span class="cl"><span class="c1">// 返回 long long 类型以处理较大的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">long</span> <span class="kt">long</span> <span class="nf">combinations</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理无效输入或边界情况：k &lt; 0 或 k &gt; n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 边界情况：C(n, 0) = 1, C(n, n) = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 优化：C(n, k) = C(n, n - k)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 选择较小的 k 可以减少计算量和空间需求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建一个大小为 k+1 的动态规划数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// dp[j] 将存储 C(current_row, j)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化基础情况 C(any_row, 0) = 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 逐行计算帕斯卡三角形的当前行值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 外层循环代表行数 i (从 1 到 n)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 内层循环代表当前行中的元素 j (从 min(i, k) 到 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 从右向左计算，以利用上一行 (i-1) 的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// dp[j] (新) = dp[j] (旧) + dp[j-1] (旧)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 即 C(i, j) = C(i-1, j) + C(i-1, j-1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 最终结果存储在 dp[k] 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">// 示例用法：
</span></span></span><span class="line"><span class="cl"><span class="cm">#include &lt;iostream&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">int main() {
</span></span></span><span class="line"><span class="cl"><span class="cm">    int n = 5;
</span></span></span><span class="line"><span class="cl"><span class="cm">    int k = 2;
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;C(&#34; &lt;&lt; n &lt;&lt; &#34;, &#34; &lt;&lt; k &lt;&lt; &#34;) = &#34; &lt;&lt; combinations(n, k) &lt;&lt; std::endl; // 输出 C(5, 2) = 10
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    n = 10;
</span></span></span><span class="line"><span class="cl"><span class="cm">    k = 3;
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;C(&#34; &lt;&lt; n &lt;&lt; &#34;, &#34; &lt;&lt; k &lt;&lt; &#34;) = &#34; &lt;&lt; combinations(n, k) &lt;&lt; std::endl; // 输出 C(10, 3) = 120
</span></span></span><span class="line"><span class="cl"><span class="cm">    
</span></span></span><span class="line"><span class="cl"><span class="cm">    n = 67; // 对于更大的 n, k 注意 long long 溢出
</span></span></span><span class="line"><span class="cl"><span class="cm">    k = 33;
</span></span></span><span class="line"><span class="cl"><span class="cm">    // C(67,33) 约为 1.4 * 10^19，接近 long long 上限
</span></span></span><span class="line"><span class="cl"><span class="cm">    std::cout &lt;&lt; &#34;C(&#34; &lt;&lt; n &lt;&lt; &#34;, &#34; &lt;&lt; k &lt;&lt; &#34;) = &#34; &lt;&lt; combinations(n, k) &lt;&lt; std::endl; 
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">    return 0;
</span></span></span><span class="line"><span class="cl"><span class="cm">}
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="曼哈顿距离等价公式推导">曼哈顿距离等价公式推导
</h2><p>给定两个点 $A(x_1, y_1)$ 和 $B(x_2, y_2)$。
标准的曼哈顿距离定义为：
</p>
$$d_M(A,B) = |x_1-x_2| + |y_1-y_2|$$<p>您给出的公式是：
</p>
$$s(A,B) = \max(|(x_1+y_1)-(x_2+y_2)|, |(x_1-y_1)-(x_2-y_2)|)$$<p>我们需要证明这两个公式是等价的。
设 $\Delta x = x_1-x_2$ 且 $\Delta y = y_1-y_2$。
那么，标准曼哈顿距离可以写作 $|\Delta x| + |\Delta y|$。
您给出的公式可以写作 $\max(|(\Delta x + \Delta y)|, |(\Delta x - \Delta y)|)$。</p>
<p>因此，核心是证明以下恒等式：
</p>
$$|\Delta x| + |\Delta y| = \max(|\Delta x + \Delta y|, |\Delta x - \Delta y|)$$<p>为了简化书写，我们令 $X = \Delta x$，$Y = \Delta y$。需要证明的恒等式即：
</p>
$$|X| + |Y| = \max(|X+Y|, |X-Y|)$$<p><strong>证明过程如下：</strong></p>
<p>由于等式两边均为非负值，我们可以通过比较它们平方值来证明等式成立。</p>
<ol>
<li>
<p><strong>计算左手边 (LHS) 的平方：</strong>
</p>
$$(|X| + |Y|)^2 = |X|^2 + 2|X||Y| + |Y|^2 = X^2 + 2|XY| + Y^2$$</li>
<li>
<p><strong>计算右手边 (RHS) 的平方：</strong>
</p>
$$(\max(|X+Y|, |X-Y|))^2 = \max(|X+Y|^2, |X-Y|^2)$$<p>   </p>
$$= \max((X+Y)^2, (X-Y)^2)$$<p>   </p>
$$= \max(X^2+2XY+Y^2, X^2-2XY+Y^2)$$</li>
<li>
<p><strong>比较平方结果：</strong>
我们需要证明 $X^2 + Y^2 + 2|XY| = \max(X^2+2XY+Y^2, X^2-2XY+Y^2)$。
令 $P = X^2+Y^2$ 和 $Q = 2XY$。
那么，上述等式可以改写为证明：
</p>
$$P + |Q| = \max(P+Q, P-Q)$$<p>我们分两种情况讨论 $Q$ 的符号：</p>
<ul>
<li>
<p><strong>情况一：$Q \ge 0$</strong>
此时，$|Q| = Q$。
所以 $P+|Q| = P+Q$。
同时，$\max(P+Q, P-Q) = P+Q$ （因为 $Q \ge 0 \implies P+Q \ge P-Q$）。
因此，$P+Q = P+Q$，等式成立。</p>
</li>
<li>
<p><strong>情况二：$Q &lt; 0$</strong>
此时，$|Q| = -Q$。
所以 $P+|Q| = P-Q$。
同时，$\max(P+Q, P-Q) = P-Q$ （因为 $Q &lt; 0 \implies P-Q &gt; P+Q$）。
因此，$P-Q = P-Q$，等式成立。</p>
</li>
</ul>
<p>由于在所有情况下 $P+|Q| = \max(P+Q, P-Q)$ 都成立，所以我们证明了：
</p>
$$X^2 + Y^2 + 2|XY| = \max(X^2+2XY+Y^2, X^2-2XY+Y^2)$$<p>
这意味着：
</p>
$$(|X| + |Y|)^2 = (\max(|X+Y|, |X-Y|))^2$$</li>
<li>
<p><strong>取平方根：</strong>
由于 $|X|+|Y|$ 和 $\max(|X+Y|, |X-Y|)$ 均为非负值，对两边取平方根，等式依然成立：
</p>
$$|X| + |Y| = \max(|X+Y|, |X-Y|)$$</li>
</ol>
<p>将 $X = x_1-x_2$ 和 $Y = y_1-y_2$ 代回上式：
</p>
$$|x_1-x_2| + |y_1-y_2| = \max(|(x_1-x_2) + (y_1-y_2)|, |(x_1-x_2) - (y_1-y_2)|)$$<p>整理括号内部：</p>
$$|x_1-x_2| + |y_1-y_2| = \max(|(x_1+y_1) - (x_2+y_2)|, |(x_1-y_1) - (x_2-y_2)|)$$<p>这就证明了您给出的公式 $s(A,B)$ 确实等价于标准曼哈顿距离 $d_M(A,B)$。</p>
<p>这种坐标变换 $(x,y) \to (x+y, x-y)$ 实质上是将坐标系旋转45度并进行拉伸，曼哈顿距离在原坐标系下的计算等价于新坐标系下的切比雪夫距离（$L_\infty$ 范数）。</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>CC BY-NC-ND</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            Last updated on Oct 09, 2020 00:00 UTC
        </span>
    </section></footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">Related content</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/huyang/p/bellman_%E6%97%A0%E8%B4%9F%E7%8E%AF/">
        
        

        <div class="article-details">
            <h2 class="article-title">Bellman_无负环</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/huyang/p/bfs_%E5%8D%95%E5%85%83%E6%9D%83%E8%BE%B9/">
        
        

        <div class="article-details">
            <h2 class="article-title">Bfs_单元权边</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/huyang/p/dag%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">
        
        

        <div class="article-details">
            <h2 class="article-title">Dag拓扑排序</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/huyang/p/dijastra_%E6%AD%A3%E6%9D%83%E8%BE%B9/">
        
        

        <div class="article-details">
            <h2 class="article-title">Dijastra_正权边</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/huyang/p/kmp%E7%AE%97%E6%B3%95/">
        
        

        <div class="article-details">
            <h2 class="article-title">Kmp算法</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Hu Yang
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>

    
<section class="running-time">
    本博客已稳定运行
    <span id="runningdays" class="running-days"></span>
    </section>
    
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/huyang/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

<script
    src="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/ribbon.min.js"
    integrity="sha384-UEK8ZiP3VgFNP8KnKMKDmd4pAUAOJ59Y2Jo3ED2Z5qKQf6HLHovMxq7Beb9CLPUe"
    crossorigin="anonymous"
    size="300"
    alpha="0.6"
    zindex="-1"
    defer
></script>


<a href="#" id="back-to-top" title="返回顶部"></a>


<style>
  #back-to-top {
    display: none;
    position: fixed;
    bottom: 5px;
    right: 15px;
    width: 40px;  
    height: 40px;  
    border-radius: 50%;  
    background-color: var(--body-background);
    box-shadow: var(--shadow-l2);
    font-size: 20px;  
    text-align: center;
    line-height: 38px;  
    cursor: pointer;
    transition:
      transform 0.3s ease,
      background-color 0.3s ease;  
  }

  #back-to-top:before {
    content: "";
    display: inline-block;
    position: relative;
    transform: rotate(135deg);
    height: 8px;  
    width: 8px;  
    border-width: 0 0 2px 2px;
    border-color: var(--back-to-top-color);
    border-style: solid;
  }

  #back-to-top:hover {
    transform: scale(1.1);  
    background-color: var(--accent-background);  
  }

  #back-to-top:hover:before {
    border-color: var(--accent-color);  
  }

   
  @media screen and (max-width: 768px) {
    #back-to-top {
      bottom: 5px;
      right: var(--container-padding);
      width: 30px;  
      height: 30px;
      font-size: 16px;
      line-height: 32px;
    }
  }

  @media screen and (min-width: 1024px) {
    #back-to-top {
      bottom: 10px;
      right: 20px;
    }
  }

  @media screen and (min-width: 1280px) {
    #back-to-top {
      bottom: 15px;
      right: 25px;
    }
  }

  @media screen and (min-width: 1536px) {
    #back-to-top {
      bottom: 15px;
      right: 25px;
       
    }
  }
</style>



<script>
    let s1 = '2025-5-18'; 
    s1 = new Date(s1.replace(/-/g, "/"));
    let s2 = new Date();
    let timeDifference = s2.getTime() - s1.getTime();

    let days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));
    let hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    let minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));

    let result = days + "天" + hours + "小时" + minutes + "分钟";
    document.getElementById('runningdays').innerHTML = result;
</script>




<script
    src="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js"
    integrity="sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg"
    crossorigin="anonymous"
></script>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css"
    integrity="sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE"
    crossorigin="anonymous"
/>
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>


    </body>
</html>
