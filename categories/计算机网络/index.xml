<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>计算机网络 on Hu Yang&#39;s Blog</title>
        <link>https://114514yangyi.github.io/huyang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
        <description>Recent content in 计算机网络 on Hu Yang&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Hu Yang</copyright>
        <lastBuildDate>Sat, 24 May 2025 17:10:21 +0000</lastBuildDate><atom:link href="https://114514yangyi.github.io/huyang/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>网络层</title>
        <link>https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/</link>
        <pubDate>Sat, 24 May 2025 17:10:21 +0000</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/</guid>
        <description>&lt;h1 id=&#34;网络层协议&#34;&gt;网络层协议
&lt;/h1&gt;&lt;p&gt;Internet的网络架构是best-effort的网络协议,不会做任何的保证,并且没有拥塞的通知.IPV4的头部的基础长度是20字节,而IPV6的长度是40字节.&lt;/p&gt;
&lt;h2 id=&#34;ip协议简介&#34;&gt;IP协议简介:
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/lady_killer9/article/details/113482131&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;网络-IP协议详解（报文格式、分类、NAT、子网、CIDR、抓包分析）_nat报文-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在IPV4或者IPV6都要有一个信息去指示包裹在IP中的数据报文的类型&lt;/p&gt;
&lt;h3 id=&#34;ip数据报格式&#34;&gt;IP数据报格式
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170902702.png&#34;
	width=&#34;1452&#34;
	height=&#34;694&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170902702_hu_76ae64fc52b0e81c.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170902702_hu_df119fff0d8c677b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610170902702&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;502px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;ipv4头部字段结构&#34;&gt;IPv4头部字段结构：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本（Version）&lt;/strong&gt;（4 bits）：指定使用的IPv4协议版本，通常为IPv4，值为4。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头部长度（IHL - Internet Header Length）&lt;/strong&gt;（4 bits）：表示IPv4头部的长度，以32位字的数量来计算，因此值为正整数，最小值为5，最大值为15（即最大长度为60字节）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区分服务（Type of Service, ToS）&lt;/strong&gt;（8 bits）：用于指定数据包的服务质量要求，包括优先级、延迟、吞吐量、可靠性等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总长度（Total Length）&lt;/strong&gt;（16 bits）：指定整个IPv4数据报的长度，包括头部和数据部分的总长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标识（Identification）&lt;/strong&gt;（16 bits）：用于识别数据报的唯一性，有助于数据包的重组和重组应用（如分片）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标志（Flags）&lt;/strong&gt;（3 bits）：包含分片的标志信息，包括标记、不分片和更多分片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;片偏移（Fragment Offset）&lt;/strong&gt;（13 bits）：指定数据报的片偏移，表示数据报在原始报文中的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生存时间（Time to Live, TTL）&lt;/strong&gt;（8 bits）：指定数据报在网络中最大生存时间，每经过一个路由器减一，直到为0时被丢弃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协议（Protocol）&lt;/strong&gt;（8 bits）：指定数据部分使用的协议，例如TCP为6，UDP为17。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头部校验和（Header Checksum）&lt;/strong&gt;（16 bits）：用于校验IPv4头部的完整性，检测传输过程中是否发生错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源IP地址（Source IP Address）&lt;/strong&gt;（32 bits）：指定数据包的源IP地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的IP地址（Destination IP Address）&lt;/strong&gt;（32 bits）：指定数据包的目的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ipv6头信息&#34;&gt;IPV6头信息
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610172931459.png&#34;
	width=&#34;712&#34;
	height=&#34;753&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610172931459_hu_52666f5dc3762373.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610172931459_hu_d5720e54ca18656f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610172931459&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;94&#34;
		data-flex-basis=&#34;226px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;#IP地址变成了8个字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本（Version）&lt;/strong&gt;（4 bits）：表示使用的IPv6协议版本，值为6。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量分类（Traffic Class）&lt;/strong&gt;（8 bits）：类似于IPv4中的区分服务（Type of Service），用于指定不同类型的数据流，如优先级、延迟或吞吐量要求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有效载荷长度（Payload Length）&lt;/strong&gt;（16 bits）：指定IPv6头部后面的有效载荷（payload）的长度，包括扩展头部及数据部分的总长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下一个头部（Next Header）&lt;/strong&gt;（8 bits）：指示紧随IPv6头部的下一个头部类型，类似IPv4的协议字段，确定如何解释数据包的有效载荷。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳限制（Hop Limit）&lt;/strong&gt;（8 bits）：类似于IPv4中的生存时间（Time to Live），指定数据包在网络中能通过的最大跳数，每经过一个路由器减一，最终为0时数据包被丢弃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源地址（Source Address）&lt;/strong&gt;（128 bits）：指定IPv6数据包的源IPv6地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的地址（Destination Address）&lt;/strong&gt;（128 bits）：指定IPv6数据包的目的IPv6地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flow Label&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标识数据流&lt;/strong&gt;：Flow Label用于唯一标识一个数据流，帮助网络设备识别和区分不同的数据流。这对于实时传输、多媒体传输和其他需要特殊处理的数据流尤为重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化路由决策&lt;/strong&gt;：Flow Label可以帮助路由器做出更智能的路由决策，以提高数据流的传输效率和减少传输时延。通过识别Flow Label，路由器可以采取更合适的路由策略，如流级负载均衡或特定路径选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高服务质量&lt;/strong&gt;：使用Flow Label可以支持差异化服务质量（QoS），确保特定的数据流能够获得适当的带宽和延迟要求。这对于要求实时传输和延迟敏感的应用程序非常重要。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化数据包处理&lt;/strong&gt;：Flow Label可以帮助网络设备快速识别特定数据流，从而简化数据包的处理过程，提高网络设备的效率和性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;从ipv4向ipv6的转换方法&#34;&gt;从IPV4向IPV6的转换方法:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;双栈:由支持IPV4/IPV6的路由器将包转换为IPV4的包,当发送给只支持IPV4的路由器的时候.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隧道技术:将IPV6的头部信息包裹在IPV4中来传输给只支持IPV4的路由器设备.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ip网络格式&#34;&gt;IP网络格式
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529120122482.png&#34;
	width=&#34;968&#34;
	height=&#34;552&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529120122482_hu_a788b7c2d0836a94.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529120122482_hu_a739d7f43ca9deff.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240529120122482&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;175&#34;
		data-flex-basis=&#34;420px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;全1代表着广播,全0代表着自己&lt;/p&gt;
&lt;h4 id=&#34;class-a&#34;&gt;class A:
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529120738430.png&#34;
	width=&#34;1094&#34;
	height=&#34;295&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529120738430_hu_84268ed1a1d17835.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529120738430_hu_eebad524001ac688.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240529120738430&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;370&#34;
		data-flex-basis=&#34;890px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以使用的主机数量为$(2^7-2)\times(2^{24}-2)$​.&lt;/p&gt;
&lt;h4 id=&#34;class-b&#34;&gt;class B:
&lt;/h4&gt;&lt;p&gt;总共有$(2^{14})(2^{16}-2)$,因为主机的id不能够是全1或者是全0.&lt;/p&gt;
&lt;h4 id=&#34;class-c&#34;&gt;class C:
&lt;/h4&gt;&lt;p&gt;同样的是子网的数量可以随便取,但是主机的数量要减去2.为$(2^{21})(2^{8}-2)$​.&lt;/p&gt;
&lt;h4 id=&#34;子网&#34;&gt;子网
&lt;/h4&gt;&lt;p&gt;为解决网络地址不足的问题，IPv4引入了子网划分的概念，使主机地址部分被划分为子网号和主机号，通过子网掩码表示哪些位属于子网号，哪些位属于主机号。这种划分带来以下好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;更灵活的地址分配&lt;/strong&gt;：将每个局域网分配一个子网号，使得在特定网络内部更灵活地管理和分配IP地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地路由器在子网网络内部路由&lt;/strong&gt;：局域网内的路由器可以直接在子网内进行路由，管理子网内部的数据流量，提高网络性能和安全性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子网对外看起来像单个网络&lt;/strong&gt;：对外部网络而言，划分的子网会像单个网络一样呈现，从而简化网络的结构，减少增长的网络号和路由复杂性对整个互联网造成的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过子网划分，IPv4网络可以更好地应对网络地址空间不足的问题，提高网络管理的效率和灵活性。同时，子网划分能够在全球互联网中提供一种有效的方式来处理与网络增长和复杂性增加相关的挑战，为网络的可扩展性和可管理性提供支持。&lt;/p&gt;
&lt;h4 id=&#34;cidr无类别域间路由选择&#34;&gt;CIDR:无类别域间路由选择
&lt;/h4&gt;&lt;p&gt;表示方法:10.217.112.0/20&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;主机是怎么获得自己的ip地址的&#34;&gt;主机是怎么获得自己的IP地址的:
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;DHCP: Dynamic Host Configuration Protocol&lt;/strong&gt;:应用层的协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529122331506.png&#34;
	width=&#34;918&#34;
	height=&#34;494&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529122331506_hu_f326ef5e2d0c0b3.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240529122331506_hu_8e1feac05b7ceaae.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240529122331506&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;185&#34;
		data-flex-basis=&#34;445px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Dynamic Host Configuration Protocol (DHCP)是一种网络协议，用于自动分配IP地址和其他网络配置给主机。下面是DHCP的工作过程概述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;主机广播 DHCP Discover 消息（可选）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当主机加入网络时（如启动时或更换网络时），它可以广播一个DHCP Discover消息，以寻找可用的DHCP服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DHCP服务器响应 DHCP Offer 消息（可选）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;DHCP服务器收到Discover消息后，可以向主机发送一个DHCP Offer消息，提供可用的IP地址、子网掩码、网关等配置信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主机请求IP地址：发送 DHCP Request 消息&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;主机在接收到DHCP Offer后，选择其中一个提供的IP地址，并向DHCP服务器发送一个DHCP Request消息，请求分配该IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DHCP服务器发送地址：发送 DHCP Ack 消息&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;DHCP服务器收到主机的Request消息后，确认IP地址的分配情况，然后发送一个DHCP Ack消息给主机，正式分配该IP地址并包含其他网络配置信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;natnetwork-address-translation&#34;&gt;NAT:Network Address Translation:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;将内网的地址映射到外网的地址,可以是静态的IP映射,也可能是从一系列的IP池中随机选择一个IP进行映射.可以起到防火墙的作用,或者是隔离内网的变化.这种映射可以是单一的IP地址的映射也可以是将IP和port的键值对的映射.&lt;/li&gt;
&lt;li&gt;使用10.0.0.0/24的同样的子网内网地址&lt;/li&gt;
&lt;li&gt;在外界看来就是一个拥有一个地址或者一系列地址的NAT转换主机.隐藏了内部网络的细节&lt;/li&gt;
&lt;li&gt;使用一张NAT转换表,将相应的&lt;code&gt;外界IP地址和端口唯一映射到一个内网的IP地址和端口&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;泛化转发匹配操作&#34;&gt;泛化转发:匹配+操作:
&lt;/h2&gt;&lt;p&gt;\泛化转发：简单的数据包处理规则,使用OpenFlow协议&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610201843709.png&#34;
	width=&#34;361&#34;
	height=&#34;202&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610201843709_hu_5d6e958ca61068e6.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610201843709_hu_68b1972f9a32eeea.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610201843709&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;178&#34;
		data-flex-basis=&#34;428px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;– 匹配：数据包头字段中的模式值-&amp;gt;会匹配头信息中的&lt;code&gt;链路层,网络层,传输层&lt;/code&gt;的信息.&lt;/li&gt;
&lt;li&gt;– 动作：对匹配的数据包进行操作：丢弃、转发、修改匹配的数据包或将匹配的数据包发送至控制器&lt;/li&gt;
&lt;li&gt;– 优先级：消除重叠模式&lt;/li&gt;
&lt;li&gt;– 计数器：字节数和数据包数&lt;/li&gt;
&lt;li&gt;可以根据链路层帧,网络层的数据报,传输层的报文段来进行匹配操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中间盒&#34;&gt;中间盒
&lt;/h2&gt;&lt;p&gt;除了路由器之外的其他的网络层设备:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;防火墙（Firewall）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;防火墙是网络安全的重要组成部分，用于监控和控制进出网络的流量。它可以根据预设的规则阻止恶意流量并确保网络安全。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡器（Load Balancer）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;负载均衡器用于在多个服务器之间分配传入流量，以确保各个服务器都能够有效处理请求并提高整体性能和可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理服务器（Proxy Server）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;代理服务器充当客户端和服务器之间的中介，可用于过滤内容、加速访问、提供匿名性等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NAT盒&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;NAT用于在私有网络和公共网络之间进行地址转换，有效地隐藏内部网络的真实IP地址，同时允许多个主机共享同一个公共IP地址，从而解决IPv4地址不足的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据平面&#34;&gt;数据平面:
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;在router的内部进行的算法,转发&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用最长前缀匹配的原则&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610165559815.png&#34;
	width=&#34;1043&#34;
	height=&#34;612&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610165559815_hu_e8b14b2799cd455b.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610165559815_hu_19aa51df39e6b773.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610165559815&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;409px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;input-port&#34;&gt;input port:
&lt;/h3&gt;&lt;p&gt;会在端口前面进行链路层的&lt;code&gt;比特差错&lt;/code&gt;的检测&lt;/p&gt;
&lt;p&gt;使用排队的队列缓冲接受的包,但是可能会发生Head-of-the-Line (HOL) blocking的情况,由于在队列的前端的包在等待着同一个switch fabric的转发,所以导致在队列后面的包不能够提前进行转发.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新数据报的头信息&lt;/li&gt;
&lt;li&gt;查找相应的destPort&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;output-port&#34;&gt;output port:
&lt;/h3&gt;&lt;p&gt;会将输入的package进行分类,根据每一个包的优先级,应该考虑但队列满的时候应该让哪些包进入队列,而丢弃哪些包.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FIFO router&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170621145.png&#34;
	width=&#34;616&#34;
	height=&#34;278&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170621145_hu_a8bf662416c0d15c.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170621145_hu_639b200972688129.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610170621145&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;221&#34;
		data-flex-basis=&#34;531px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Priority scheduling:将每一个包进行优先级的划分,总是先发送有=优先级高的包,直到优先级高的队列里面没有任何包为止.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170632548.png&#34;
	width=&#34;704&#34;
	height=&#34;327&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170632548_hu_3b01501c76af812f.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170632548_hu_d54171c884df68f2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610170632548&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;215&#34;
		data-flex-basis=&#34;516px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Round Robin (RR) scheduling:循环着发送每一个队列的数据包.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170641482.png&#34;
	width=&#34;920&#34;
	height=&#34;477&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170641482_hu_c416bf9b1a341ed8.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170641482_hu_6ac6e35fedd8c4d3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610170641482&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;462px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Weighted Fair Queuing (WFQ):每一次循环发送队列中的包的数量是有权重的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170650448.png&#34;
	width=&#34;905&#34;
	height=&#34;429&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170650448_hu_38396937c3500b60.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610170650448_hu_bd277c7441150f26.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610170650448&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;210&#34;
		data-flex-basis=&#34;506px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;switch-fabric&#34;&gt;switch fabric:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用内存实现
将数据放进特定的地址空间,而output port从memery中找到相应的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用总线实现
每次使用总线将一对的输入输出的端口相连&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用互联网络实现
每一个相交的点都可以进行开关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由选择处理器&#34;&gt;路由选择处理器:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用destIP的最长前缀匹配&lt;/li&gt;
&lt;li&gt;使用OpenFlow的泛化转发&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;控制平面&#34;&gt;控制平面:
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;决定一个数据包应该在整个网络中如何传输,从起点是如何传输到终点的.&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;路由器间的控制平面&#34;&gt;路由器间的控制平面:
&lt;/h3&gt;&lt;h4 id=&#34;1全局算法每一个路由器都知道关于网络上所有的信息&#34;&gt;1.全局算法(每一个路由器都知道关于网络上所有的信息)
&lt;/h4&gt;&lt;p&gt;Dijkstra算法:&lt;/p&gt;
&lt;p&gt;下面是一个简单的Dijkstra（迪杰斯特拉）最短路径算法的伪代码实现，用于找到从起点到其余各顶点的最短路径：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plaintext&#34; data-lang=&#34;plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Dijkstra(Graph, source):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1. 初始化集合distances，用于存储每个顶点到起点的最短距离，初始化为无穷大(INF)。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2. 初始化集合visited，用于标记已经找到最短路径的顶点，初始时为空。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3. 将源顶点的距离设置为0，表示源顶点到自身的距离为0。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4. while 未访问完所有顶点:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   a. 选取未访问过的距禓源顶点最近的顶点u，将其标记为visited。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   b. for 每个与顶点u相邻的顶点v:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      i. 计算从源顶点经过u到v的距离d。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      ii. 如果d &amp;lt; distances[v]，更新distances[v]为d。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5. 返回distances。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;2分布式的算法每一个路由器只知道自己的信息和邻居的信息&#34;&gt;2.分布式的算法(每一个路由器只知道自己的信息和邻居的信息)
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;每一个路由器间自己的对于每一个点的最短向量告诉邻居&lt;/li&gt;
&lt;li&gt;假如一个路由器u发现了有邻居发送的cost向量:$DV_u(x)&amp;gt;w(u,v)+DV_v(x)$,则更新自己的DV值为最小的,并且修改转发表让到x的packet走通向v的端口.假如自己的转发表发生了变动,则将自己的cost向量也发送给邻居.&lt;/li&gt;
&lt;li&gt;每一个路由器分布式地更新数据,直到最终的cost向量不再发生变化.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;效应:&lt;/p&gt;
&lt;p&gt;好的消息(链路的状态变好)传播的快,但是坏消息(链路上面的cost增大)传播地慢.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610203724832.png&#34;
	width=&#34;1536&#34;
	height=&#34;653&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610203724832_hu_5f7d6dcd1a46654f.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610203724832_hu_9c4ba39344625a26.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610203724832&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;235&#34;
		data-flex-basis=&#34;564px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610203734381.png&#34;
	width=&#34;1463&#34;
	height=&#34;699&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610203734381_hu_25675deece0154b4.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610203734381_hu_42d5d65aafa349f6.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610203734381&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;502px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;snd软件定义的控制平面&#34;&gt;SND:软件定义的控制平面:
&lt;/h3&gt;&lt;p&gt;使用一个远程的软件定义的服务器去计算每一个路由器的转发表&lt;/p&gt;
&lt;p&gt;转发表基于OpenFlow API,并且可以根据流标签来进行负载均衡&lt;/p&gt;
&lt;h4 id=&#34;sdn的特征&#34;&gt;SDN的特征
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基于流的转发&lt;/li&gt;
&lt;li&gt;数据平面与控制平面的分离&lt;/li&gt;
&lt;li&gt;网络控制能力&lt;/li&gt;
&lt;li&gt;可编程的网络&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以更加方便管理,更多的灵活性;&lt;/li&gt;
&lt;li&gt;可以编程的转发表,由于传统的路径固定不能实现负载均衡&lt;/li&gt;
&lt;li&gt;可以将控制平面的实现公开&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610212026918.png&#34;
	width=&#34;639&#34;
	height=&#34;801&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610212026918_hu_659eb245f412ee37.png 480w, https://114514yangyi.github.io/huyang/p/%E7%BD%91%E7%BB%9C%E5%B1%82/image-20240610212026918_hu_5a2ac4c2bd250645.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610212026918&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;79&#34;
		data-flex-basis=&#34;191px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最底层**:(数据平面交换机)**
&lt;ul&gt;
&lt;li&gt;它们是快速、简单的商品化交换机，能够高效处理数据转发任务。&lt;/li&gt;
&lt;li&gt;这些交换机的流表（转发表）是在控制器监督下计算并安装的。&lt;/li&gt;
&lt;li&gt;它们提供基于表格的交换机控制的API，比如OpenFlow，该API定义了可控制和不可控制的内容。&lt;/li&gt;
&lt;li&gt;数据平面交换机使用与控制器通信的协议（例如OpenFlow），实现与控制器的通信，从而实现网络的集中化控制&lt;/li&gt;
&lt;li&gt;使用广义转发的OpenFlow协议,并且抽象出API提供给上层的SDN Controller使用,和Controller进行交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中层:&lt;strong&gt;SDN controller (network OS)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;维护&lt;code&gt;网络状态信息&lt;/code&gt;，持续跟踪网络中各个设备的状态和信息。&lt;/li&gt;
&lt;li&gt;通过北向API与&lt;code&gt;上层的网络控制应用程序进行交互&lt;/code&gt;，&lt;code&gt;接收和处理来自应用层的指令和需求。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过南向API与&lt;code&gt;下层的网络交换机进行交互&lt;/code&gt;，向网络设备下发配置命令和路由信息。&lt;/li&gt;
&lt;li&gt;通常以分布式系统的形式实现，以确保性能、可扩展性、容错性和稳健性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上层:&lt;strong&gt;network-control apps&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;实现控制功能：利用SDN控制器提供的低层服务和API，执行各种控制功能，如流量管理、策略实施等。&lt;/li&gt;
&lt;li&gt;解耦化：这些控制功能可以由第三方提供，与路由器供应商或SDN控制器本身分离，使得控制功能的提供更加灵活和可定制化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ospf开放最短路径优先&#34;&gt;OSPF(开放最短路径优先):
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;将一片区域的Router归纳与于一个autonomous systems.&lt;/li&gt;
&lt;li&gt;每一个路由器都知道整个自治系统拓扑图,一次来确定由自己到AS中的所有的节点的最短路径&lt;/li&gt;
&lt;li&gt;OSPF是link-state的协议,使用dijkstra的算法.&lt;/li&gt;
&lt;li&gt;OSPF只在每一个区域中和每一个骨干区域中内部传播,这个是&lt;code&gt;层次化&lt;/code&gt;的表现.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bgpborder-gateway-protocol&#34;&gt;BGP(Border Gateway Protocol):
&lt;/h3&gt;&lt;p&gt;inter:告诉其他的AS他的终点网络的可达性;&lt;/p&gt;
&lt;p&gt;intra:告诉在同一个AS中的路由器自己的可达性;&lt;/p&gt;
&lt;p&gt;BGP链接是&lt;code&gt;半永久的TCP连接&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包含的信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AS_PATH:经过的AS的路径&lt;/li&gt;
&lt;li&gt;next-hop:是到达发布更新消息的AS的&lt;code&gt;边界路由器的IP地址&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是以&lt;code&gt;策略&lt;/code&gt;为基础的路由,每一个gateway路由器使用import 策略来接受路径,而根据AS的策略决定是否广播路径.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;iBGP-&amp;gt;Intra-ISP (Intra-AS)Routing:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网关路由器在接收到其他的AS的子网可达的信息的时候,会&lt;code&gt;将这种可达的信息传递给内部的AS中的所有的路由器&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;eBGP-&amp;gt;Inter-AS:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网关路由器是AS的边界&lt;/li&gt;
&lt;li&gt;&lt;code&gt;将自身网络的子网可达性通知给相邻的AS的网关路由器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个网关路由器在接受到了来自同一个子网的不同的AS路径会根据自己的算法选择一个&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;选择最好的路由&#34;&gt;选择最好的路由:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;热土豆路由:在内部的路由器不考虑AS间的路径开销,只是单纯地想要将发往其他AS的packet&lt;code&gt;尽快发送到网关路由器.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;本地设置的偏好值&lt;/code&gt;来确定当多个通往相同的子网的路径的时候选择将哪一个条目来进行保存在转发表中&lt;/li&gt;
&lt;li&gt;AS可以设置是否要将由其他AS传递过来的可达状态继续传递下去&lt;/li&gt;
&lt;li&gt;最短路径决定&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;icmpinternet-control-message-protocol&#34;&gt;ICMP:internet control message protocol
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;用于主机和路由器交流网络状态信息的协议&lt;/code&gt;,即是否可达,是否有错误&lt;/li&gt;
&lt;li&gt;ICMP是分装在IP协议中的&lt;/li&gt;
&lt;li&gt;拥有一个type,code,和8字节的错误原因&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现路由跟踪:&lt;/p&gt;
&lt;p&gt;​	source设置一个合适的ttl=n,当这个发送的数据包经过了第n个路由器的时候,会被丢弃并且这个路由器会向source发送一个ICMP的状态包,记录着自己的信息,而source可以等待这个ICMP的包,用于计算RTT;假如这个UDP的数据包到达了目标的主机就会直接返回一个ICMP信息,表示自己是可达的.&lt;/p&gt;
&lt;h3 id=&#34;网络管理&#34;&gt;网络管理:
&lt;/h3&gt;&lt;p&gt;网络管理的关键设备:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理服务器&lt;/li&gt;
&lt;li&gt;被管理设备&lt;/li&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;网络管理协议&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;snmp&#34;&gt;SNMP
&lt;/h4&gt;&lt;p&gt;SNMP（Simple Network Management Protocol，简单网络管理协议）是一种&lt;code&gt;管理服务器和代管理服务器执行的代理之间传递网络管理信息报文的协议&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;功能和工作原理&#34;&gt;功能和工作原理：
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;SNMP允许网络管理系统（NMS）通过网络与SNMP代理交互，以监视设备状态、配置设备参数、远程管理和故障排除等。它提供了一种标准化的管理框架，使得不同厂商生产的设备可以方便地与管理系统集成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作原理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;SNMP基于客户端-服务器模型，包括三个主要组件：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;管理系统&lt;/strong&gt;：负责监控和管理网络设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代理&lt;/strong&gt;（Agent）：安装在网络设备上，负责收集设备状态信息并向管理系统提供数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MIB&lt;/strong&gt;（Management Information Base）：包含设备的管理信息数据库，管理系统通过查询MIB获取设备信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;snmp消息类型&#34;&gt;SNMP消息类型：
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Get Request&lt;/strong&gt;：管理系统向代理请求特定参数值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Get Response&lt;/strong&gt;：代理响应Get请求，返回参数值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set Request&lt;/strong&gt;：管理系统向代理发送设置参数值的请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Trap&lt;/strong&gt;：代理向管理系统主动发送警报消息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;管理者使用SNMP(Simple Network Management Protocol)来获取设备信息(MIB)&lt;/p&gt;
&lt;p&gt;网络配置协议:NETCONF 使用RFC(remote procedure call),格式为xml,是一种配置的语言,可以使用yang这种编程语言来编写.&lt;/p&gt;
</description>
        </item>
        <item>
        <title>互联网安全</title>
        <link>https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/</guid>
        <description>&lt;h1 id=&#34;互联网安全&#34;&gt;互联网安全
&lt;/h1&gt;&lt;p&gt;主要是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;鉴别&lt;/li&gt;
&lt;li&gt;机密性&lt;/li&gt;
&lt;li&gt;完整性&lt;/li&gt;
&lt;li&gt;运行安全性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;秘钥&#34;&gt;秘钥
&lt;/h2&gt;&lt;h3 id=&#34;对称秘钥&#34;&gt;对称秘钥
&lt;/h3&gt;&lt;p&gt;接收方和发送者使用同一份秘钥进行加密和解密&lt;/p&gt;
&lt;p&gt;加密算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;凯撒密码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环的加密模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DES加密算法:&lt;/p&gt;
&lt;p&gt;使用56位对称密钥，64位明文输入&lt;/p&gt;
&lt;p&gt;有3DES:使用3个不同的秘钥进行加密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AES:&lt;/p&gt;
&lt;p&gt;使用128/192/256bits的秘钥加密128bits的数据块&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;非对称秘钥&#34;&gt;非对称秘钥
&lt;/h3&gt;&lt;p&gt;所有人都知道接受者的公钥,只有接受者有私钥;发送者使用公钥加密,接受者使用私钥解密;&lt;/p&gt;
&lt;p&gt;RSA算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;密钥生成&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;选择两个大素数 p 和 q。&lt;/li&gt;
&lt;li&gt;计算 n = p * q，n 称为模数。&lt;/li&gt;
&lt;li&gt;计算欧拉函数 φ(n) = (p-1) * (q-1)。&lt;/li&gt;
&lt;li&gt;选择一个指数 e，使得 e 与 φ(n) 互质，通常选择一个小素数，常见的选择是65537。&lt;/li&gt;
&lt;li&gt;计算私钥指数 d，满足 (d * e) mod φ(n) = 1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加密&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;将明文 M 转换为整数 m，要求 0 &amp;lt;= m &amp;lt; n。&lt;/li&gt;
&lt;li&gt;加密计算：C = M^e mod n，得到密文 C。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解密&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;解密计算：M = C^d mod n，得到原始明文 M。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;私钥:$K^{-}&lt;em&gt;{B}=(n,d)$;公钥:$K^{+}&lt;/em&gt;{B}=(n,e)$.&lt;/p&gt;
&lt;p&gt;一般使用RSA算法来传递会话的对称秘钥,因为RSA虽然安全但是开销大&lt;/p&gt;
&lt;h2 id=&#34;认证&#34;&gt;认证
&lt;/h2&gt;&lt;p&gt;不重数:在每一次的会话中都不会重复出现的数字,只会使用一次&lt;/p&gt;
&lt;p&gt;数字签名:使用私钥对证书进行加密签名&lt;/p&gt;
&lt;p&gt;哈希函数:将一长段的长度为M的信息映射到一个较短的长度为m的数字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MD5&lt;/li&gt;
&lt;li&gt;SHA-1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数字签名&#34;&gt;数字签名
&lt;/h3&gt;&lt;h4 id=&#34;生成过程&#34;&gt;生成过程:
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611195128788.png&#34;
	width=&#34;1682&#34;
	height=&#34;815&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611195128788_hu_4867fd924ca39347.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611195128788_hu_113c7886abe956f0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611195128788&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;206&#34;
		data-flex-basis=&#34;495px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送者使用众所周知的哈希函数来生成证书的信息摘要,并用私钥对其进行签名,附加上证书的明文信息,发送给接受者&lt;/li&gt;
&lt;li&gt;接受者使用公钥将加密的摘要进行解密,再使用哈希函数对证书信息进行哈希处理,对照解密出来的摘要和生成的摘要是否相同.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;颁布公钥的组织ca&#34;&gt;颁布公钥的组织:CA
&lt;/h4&gt;&lt;p&gt;在数字证书体系中的一些关键概念包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;证书颁发机构 (Certification Authority, CA)&lt;/strong&gt;：证书颁发机构是负责将公钥绑定到特定实体（Entity，E）的机构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实体&lt;/strong&gt;：实体可以是个人、网站、路由器等，通过向CA注册其公钥，并向CA提供身份证明来确保其身份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册流程&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;实体通过身份验证程序向CA注册其公钥。&lt;/li&gt;
&lt;li&gt;CA生成一个证书，将实体的身份与其公钥绑定在一起。&lt;/li&gt;
&lt;li&gt;证书包含了实体的公钥，并由CA使用CA的私钥进行数字签名，证明“这是实体E的公钥”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字签名&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;CA数字签名证书，确认证书的真实性和可信度。&lt;/li&gt;
&lt;li&gt;数字签名可以确保证书在传输过程中不被篡改，并且可以被其他方验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此当一个A想要获取B的公钥的时候,B就会发送给A,B的证书,A使用CA的公钥来解密证书,里面包含着B的公钥和B的信息.由于CA的公钥一定是对的,并且由CA颁发的证书也记录的一定是B的公钥.&lt;/p&gt;
&lt;h2 id=&#34;安全邮件&#34;&gt;安全邮件
&lt;/h2&gt;&lt;h3 id=&#34;可靠性机密性&#34;&gt;可靠性(机密性)
&lt;/h3&gt;&lt;p&gt;可靠性的实现应该使用会话秘钥来加密数据,并且使用对方的公钥来加密会话私钥&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203548937.png&#34;
	width=&#34;1438&#34;
	height=&#34;425&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203548937_hu_5b8cf8a183084f4a.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203548937_hu_18b1b8a4ecbf5de3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611203548937&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;338&#34;
		data-flex-basis=&#34;812px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;完整性和认证&#34;&gt;完整性和认证
&lt;/h3&gt;&lt;p&gt;完整性应该对数据形成一个哈希函数摘要,使用自己的私钥签名,来证明信息是自己发送的,并且和原信息一起发送,可以验证完整性&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203532291.png&#34;
	width=&#34;1466&#34;
	height=&#34;401&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203532291_hu_d4fcd34691fc1e1b.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203532291_hu_fa799dccac82290e.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611203532291&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;365&#34;
		data-flex-basis=&#34;877px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;可靠性完整性认证&#34;&gt;可靠性+完整性+认证
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203723133.png&#34;
	width=&#34;1597&#34;
	height=&#34;570&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203723133_hu_f2ce8c318eae6806.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611203723133_hu_6b760197137ff062.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611203723133&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;280&#34;
		data-flex-basis=&#34;672px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;安全tcp连接传输层安全&#34;&gt;安全TCP连接:传输层安全
&lt;/h2&gt;&lt;p&gt;使用TLS协议-&amp;gt;https&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAC&lt;/strong&gt;:message authentication code:消息认证码,用于消息的认证和完整性&lt;/p&gt;
&lt;p&gt;使用一个Master Key来生成四种不同的秘钥,使用秘钥生成函数KDF(key derivation function)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用四种密钥：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Kc&lt;/strong&gt;：用于客户端到服务器端发送数据的加密密钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mc&lt;/strong&gt;：用于客户端到服务器端发送数据的MAC密钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ks&lt;/strong&gt;：用于服务器端到客户端发送数据的加密密钥。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ms&lt;/strong&gt;：用于服务器端到客户端发送数据的MAC密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;密钥通过密钥派生函数（Key Derivation Function, KDF）派生：
&lt;ul&gt;
&lt;li&gt;KDF接受主密钥（master secret）和可能的一些额外随机数据，用于生成新的密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;过程&#34;&gt;过程:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;客户端发送协议版本号、加密算法列表和不重数A到服务器端。&lt;/li&gt;
&lt;li&gt;服务端返回自己的协议版本号、加密算法选择、证书和不重数B到客户端。&lt;/li&gt;
&lt;li&gt;客户端验证服务器端的证书，并生成一个前主秘钥。客户端使用服务端的公钥（从证书中获取）加密前主秘钥，并发送给服务器端。&lt;/li&gt;
&lt;li&gt;服务端收到客户端加密的前主秘钥后，使用自己的私钥解密，获取前主秘钥。&lt;/li&gt;
&lt;li&gt;客户端和服务端根据不重数和前主秘钥计算出主密钥，并通过KDF导出四个秘钥并开始加密通信&lt;/li&gt;
&lt;li&gt;客户端发送所有的握手报文的HMAC&lt;/li&gt;
&lt;li&gt;服务端发送所有握手报文的HMAC&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;hmac&#34;&gt;HMAC:
&lt;/h4&gt;&lt;p&gt;HMAC（Keyed-Hash Message Authentication Code）是一种在计算机安全领域中使用的消息认证码（MAC）算法。HMAC通过在哈希函数的基础上加入一个密钥，结合消息本身进行计算，可以验证消息的完整性和真实性，防止数据被篡改。以下是HMAC的基本原理和特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基本原理：HMAC算法使用一个密钥和一个消息作为输入，通过哈希函数对它们进行公式计算得到一个消息认证码（MAC）。发送方将这个MAC与消息一起发送给接收方，接收方再使用相同的密钥和消息，通过哈希函数计算MAC并与接收到的MAC比对，从而验证消息的完整性和真实性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;s:对称秘钥;m:信息;&lt;/p&gt;
&lt;p&gt;MAC=H(s+m).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HMAC算法基于哈希函数，常用的哈希函数包括MD5、SHA-1、SHA-256等。&lt;/li&gt;
&lt;li&gt;HMAC使用了密钥进行计算，对消息进行哈希运算后再进行加密处理，保证了消息的机密性。&lt;/li&gt;
&lt;li&gt;HMAC可以防止常见的攻击（如中间人攻击、伪造消息攻击等），提供了更高的安全性保障&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipsec网络层安全&#34;&gt;IPsec:网络层安全
&lt;/h2&gt;&lt;h3 id=&#34;两种协议&#34;&gt;两种协议:
&lt;/h3&gt;&lt;p&gt;一、AH协议（Authentication Header）：&lt;/p&gt;
&lt;p&gt;AH协议是一种用于提供IP通信认证和完整性保护的协议。其主要功能包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;认证：AH协议提供了对IP数据包的来源进行认证的功能，确保接收到的数据包确实来自合法的发送方。&lt;/li&gt;
&lt;li&gt;数据完整性保护：AH协议可以检测IP数据包在传输过程中是否被篡改或损坏，确保数据的完整性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AH协议通过在IP数据包中添加一个认证头来实现上述功能，该头包含加密的哈希值和用于验证发送方的数字签名等信息。接收方可以通过验证哈希值和数字签名来确认数据包的来源和完整性。&lt;/p&gt;
&lt;p&gt;二、ESP协议（Encapsulating Security Payload）：&lt;/p&gt;
&lt;p&gt;ESP协议是一种提供更全面的IP通信安全保护的协议，它提供了加密、认证和完整性保护等功能。其主要特点包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加密：ESP协议可以对IP数据包的内容进行加密，保护数据在传输过程中的隐私。&lt;/li&gt;
&lt;li&gt;认证：ESP协议也提供了对IP数据包的来源进行认证的功能，与AH协议类似。&lt;/li&gt;
&lt;li&gt;数据完整性保护：ESP协议可以检测IP数据包在传输过程中是否被篡改或损坏。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ESP协议通过在IP数据包中添加一个加密的有效载荷来实现上述功能，该有效载荷包含加密的数据和认证信息。发送方使用加密密钥对有效载荷进行加密，接收方使用相同的密钥进行解密，并验证数字签名和哈希值以确保数据的完整性和来源。&lt;/p&gt;
&lt;h3 id=&#34;sa--security-association-安全关联&#34;&gt;SA : Security Association 安全关联
&lt;/h3&gt;&lt;p&gt;SA安全关联是一种在通信双方之间建立的规则集合，用于定义网络通信的安全属性。这些规则包括加密算法、认证方式、密钥管理等方面的约定，以确保通信双方能够安全地交换数据。&lt;/p&gt;
&lt;p&gt;在发送数据之前，发送实体和接收实体之间会建立一个安全关联（SA）。这个SA是用于定义两个实体之间通信的安全属性和参数的。简单地说，它描述了如何安全地发送和接收数据。这种关联是单工的，即从&lt;code&gt;发送实体到接收实体只有一个方向传输,所以一般会同时建立两条SA&lt;/code&gt;。这意味着，在发送实体想要向接收实体发送数据时，需要确保双方都同意并遵循相同的SA来确保数据的机密性和完整性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611215136377.png&#34;
	width=&#34;1675&#34;
	height=&#34;822&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611215136377_hu_5261a04ed564c380.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611215136377_hu_9c47a7d35f5ac59a.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611215136377&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;203&#34;
		data-flex-basis=&#34;489px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;分组模式&#34;&gt;分组模式
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611215147860.png&#34;
	width=&#34;1625&#34;
	height=&#34;808&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611215147860_hu_a6929ef4e7585312.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/image-20240611215147860_hu_111348e355231841.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611215147860&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;482px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;传输过程&#34;&gt;传输过程
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;R1阶段&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;附加ESP尾迹到原始数据报&lt;/strong&gt;: ESP会对原始的IP数据报进行封装。这意味着原始的IP数据报（包括其头部字段）会被保留并附加一个ESP尾迹。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用SA指定的算法和密钥进行加密&lt;/strong&gt;: 安全关联（SA）定义了一系列参数，包括加密和认证算法以及相应的密钥。在这个阶段，使用这些参数对添加了ESP尾迹的数据报进行加密。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在加密数据前附加ESP头部&lt;/strong&gt;: 在加密后的数据前，会添加一个ESP头部。这个头部包含了关于加密数据的元信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建认证MAC&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;使用SA中指定的算法和密钥，对加密后的数据进行认证，创建一个消息认证码（MAC）。MAC的目的是确保数据的完整性和真实性，确保数据在传输过程中没有被篡改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将MAC形成载荷附加到数据&lt;/strong&gt;: MAC被添加到数据报中，形成一个新的载荷部分。这样接收方可以通过MAC验证数据的完整性和真实性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建新的IP头部和地址&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;由于这是一个封装过程（例如，用于VPN或隧道通信），所以需要创建一个新的IP头部和相关的字段。这些字段通常包括新的源和目标地址（这里是隧道的端点）。这个新的IP头部和数据一起发送，形成一个新的数据报，该数据报会在网络中传输&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ip-sequence&#34;&gt;IP Sequence
&lt;/h3&gt;&lt;p&gt;IPsec（Internet Protocol Security）中的&lt;code&gt;序列号&lt;/code&gt;（sequence numbers）是用于确保IP通信安全的重要机制。以下是关于IPsec序列号的一些详细解释：&lt;/p&gt;
&lt;h3 id=&#34;对于新的安全关联sasecurity-association&#34;&gt;对于新的安全关联（SA，Security Association）
&lt;/h3&gt;&lt;p&gt;当建立一个新的安全关联时，发送方将序列号初始化为0。&lt;/p&gt;
&lt;h4 id=&#34;spi&#34;&gt;SPI
&lt;/h4&gt;&lt;p&gt;SPI全称为Security Parameter Index（&lt;code&gt;安全参数索引&lt;/code&gt;），在网络通信中是一个用于标识和区分不同的安全服务或安全协议的标识符。在IPsec（Internet Protocol Security）中，SPI通常用于标识IPsec中的安全关联（Security Association，SA），以便在数据包中传递给接收方，并将其与正确的安全策略和密钥相关联。&lt;/p&gt;
&lt;p&gt;SPI的作用包括以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;唯一标识符&lt;/strong&gt;：SPI的主要作用是作为&lt;code&gt;用于识别不同的SA的唯一标识符&lt;/code&gt;。每个SA都有自己的SPI，这样在收到数据包时就能够根据SPI来匹配对应的SA。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关联安全参数&lt;/strong&gt;：SPI与SA相关联，其中包括加密算法、认证算法、密钥信息等安全参数。接收方使用SPI确定如何处理收到的数据包，以便正确地解密和验证数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在数据包中传递&lt;/strong&gt;：SPI通常被包含在数据包的头部或者IPsec封装的部分中。接收方接收到数据包时会检查SPI，以确定如何处理数据包中的安全信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，SPI是一个重要的标识符，用于在IPsec通信中唯一标识不同的安全关联，并帮助数据包正确地被解密和验证。通过SPI的使用，可以确保IPsec通信的安全性和完整性。&lt;/p&gt;
&lt;h4 id=&#34;每次在sa上发送数据报时&#34;&gt;每次在SA上发送数据报时
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;发送方&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;增加序列号计数器。&lt;/li&gt;
&lt;li&gt;将新的序列号值放入序列号字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的方&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;检查接收到的数据包是否是重复的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;目标&#34;&gt;目标
&lt;/h4&gt;&lt;p&gt;IPsec序列号的主要目标是&lt;code&gt;防止攻击者嗅探（sniffing）&lt;/code&gt;并重新发送数据包（replay attack）。如果一个数据包被捕获并重新发送，由于序列号的变化，接收方可以轻松地识别出这是一个重复的数据包，从而拒绝它或采取其他适当的措施。此外，接收重复的、经过身份验证的IP数据包可能会破坏服务或导致数据不一致。&lt;/p&gt;
&lt;h4 id=&#34;方法&#34;&gt;方法
&lt;/h4&gt;&lt;p&gt;目的方不跟踪所有接收到的数据包，而是使用&lt;code&gt;一个窗口（window）机制&lt;/code&gt;来高效地检测重复的数据包。这个窗口通常是一个时间序列范围，接收方会检查每个到达的数据包的序列号是否在这个窗口内。如果不在窗口内，那么该数据包可能是重复的或是旧的。这样，系统可以有效地识别并处理重复的数据包，而不必检查每一个单独的数据包。这种方法的效率较高，因为不需要跟踪所有接收到的数据包。&lt;/p&gt;
&lt;h3 id=&#34;数据库&#34;&gt;数据库
&lt;/h3&gt;&lt;p&gt;IPsec是一套安全协议，用于保护IP网络上的通信数据的安全性和完整性。IPsec包含两个核心组件：Security Policy Database (SPD) 和 Security Association Database (SAD)。这两者在IPsec中发挥着不同的作用，并具有各自特定的功能和重要性。以下是关于它们的详细解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Security Policy Database (SPD)：安全策略数据库&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;策略（Policy）&lt;/strong&gt;: 对于给定的数据报，发送者需要知道是否应该使用IPsec。这意味着在发送数据之前，系统需要根据某些规则或条件决定是否应该对该数据进行加密或验证。这些规则或条件构成了安全策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储位置&lt;/strong&gt;: 安全策略存储在安全策略数据库中（SPD）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容&lt;/strong&gt;: SPD中的策略可能包含源和目的IP地址、协议号等信息，用于确定哪些数据报需要使用IPsec加密或验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Security Association Database (SAD)：安全关联数据库&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;状态持有&lt;/strong&gt;: 端点在安全关联数据库（SAD）中持有安全关联状态。这些状态描述了与特定安全关联（SA）相关的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发送过程&lt;/strong&gt;: 当发送IPsec数据报时，如路由器R1，会访问SAD以确定如何处理该数据报。它根据SAD中的信息来确定应该使用的加密或验证方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接收过程&lt;/strong&gt;: 当IPsec数据报到达路由器R2时，R2会检查数据报中的序列号（SPI），然后使用SPI索引SAD，并据此处理数据报。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;简单总结&#34;&gt;简单总结：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SPD&lt;/strong&gt;: 告诉你“&lt;strong&gt;要做什么&lt;/strong&gt;”（即哪些数据报需要使用IPsec，使用哪种加密或验证方法）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SAD&lt;/strong&gt;: 告诉你“&lt;strong&gt;如何做&lt;/strong&gt;”（即具体如何加密或验证数据报，包括使用的密钥、算法等信息）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际应用中，SPD和SAD协同工作，确保IP网络上的通信数据安全、可靠。通过对这两者的管理和维护，可以实现高效的网络安全保障。&lt;/p&gt;
&lt;h2 id=&#34;ike&#34;&gt;IKE
&lt;/h2&gt;&lt;p&gt;IKE（Internet Key Exchange）通常指的是Internet Key Exchange协议或者IKEv系列协议（IKEv协议的主要版本是IKEv1和IKEv2），是一种在网络通信中用于&lt;code&gt;密钥交换&lt;/code&gt;的协议。IKE主要用于IPSec通信，为安全通信建立和维护虚拟私有网络（VPN）的安全关联。其原理包括以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立初始联系和标识符交换：IKE启动时，两端的IKE对等体通过交换标识符（如IP地址或其他标识符）来识别对方。在这个阶段，还可能会进行某些安全策略的检查。&lt;/li&gt;
&lt;li&gt;身份验证和协商阶段：在这个阶段，IKE对等体会进行身份验证和协商。IKE协议支持多种身份验证方法，如基于预共享密钥的验证、基于证书的验证等。此外，还会协商密钥生成算法、加密算法等参数。&lt;/li&gt;
&lt;li&gt;创建安全的网络连接和建立加密参数：完成验证后，IKE会创建一个安全的网络连接并使用安全的认证方式进行数据的加密传输。它通过基于一系列参数建立一个共享的密钥集合来实现。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上所述，IKE的基本原理是通过一系列协议步骤来实现安全的密钥交换和虚拟网络的安全关联建立。它通过特定的身份验证机制和安全参数协商来确保网络通信的安全性和可靠性。&lt;/p&gt;
&lt;p&gt;钥交换和虚拟网络的安全关联建立。它通过特定的身份验证机制和安全参数协商来确保网络通信的安全性和可靠性。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>互联网要点</title>
        <link>https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%A6%81%E7%82%B9/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%A6%81%E7%82%B9/</guid>
        <description>&lt;h1 id=&#34;互联网要点&#34;&gt;互联网要点
&lt;/h1&gt;&lt;h2 id=&#34;互联网计算简介&#34;&gt;互联网计算简介
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;主机:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连接互联网的,运行应用程序的系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个端系统向另一个端系统传输的数据,将&lt;code&gt;数据分段&lt;/code&gt;,并添加&lt;code&gt;首部字节&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指的是发送&lt;code&gt;报文的格式,顺序&lt;/code&gt;,发送/接受报文和其他事件所采取的操作&lt;/p&gt;
&lt;h2 id=&#34;运输层&#34;&gt;运输层
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多路复用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收集套接字的数据块,并添加&lt;code&gt;首部信息&lt;/code&gt;,形成报文段,并将报文段发送到网络层&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多路分解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将从运输层接受的报文段&lt;code&gt;正确地交付&lt;/code&gt;给套接字&lt;/p&gt;
&lt;h2 id=&#34;网络层&#34;&gt;网络层
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数据平面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入链路之一的数据报转发到输出链路之一&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制平面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制数据报从&lt;code&gt;源主机到目的主机的端到端的路由方式&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将输入链路接口的数据包转移给合适的输出链路接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将数据报从源到目的地采取的端到端的&lt;code&gt;网络范围处理过程&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSPF&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在AS中计算每一个节点的最短距离的链路状态算法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SDN体系的4个特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于流的转发&lt;/li&gt;
&lt;li&gt;控制平面和数据平面分离&lt;/li&gt;
&lt;li&gt;可编程网络&lt;/li&gt;
&lt;li&gt;网络控制能力&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;ICMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主机和路由器交流&lt;code&gt;网络状态信息报文&lt;/code&gt;的协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于管理服务器和代被管理主机执行的代理之间传递&lt;code&gt;网络管理信息报文&lt;/code&gt;的协议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理&lt;/li&gt;
&lt;li&gt;MBI&lt;/li&gt;
&lt;li&gt;管理系统&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;网络管理的关键组件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理服务器&lt;/li&gt;
&lt;li&gt;被管理设备&lt;/li&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链路层&#34;&gt;链路层
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何运行&lt;code&gt;链路层协议&lt;/code&gt;的设备&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个节点之间的&lt;code&gt;通信信道&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路层提供的服务&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成帧&lt;/li&gt;
&lt;li&gt;链路接入&lt;/li&gt;
&lt;li&gt;可靠交付&lt;/li&gt;
&lt;li&gt;比特级的差错检验和纠正&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;链路层在何处实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络适配器的芯片上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多路访问协议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;频率,时间片划分接入&lt;/li&gt;
&lt;li&gt;随机接入&lt;/li&gt;
&lt;li&gt;轮流接入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数据中心的等级拓扑&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网关路由器&lt;/li&gt;
&lt;li&gt;接入路由器&lt;/li&gt;
&lt;li&gt;负载均衡器&lt;/li&gt;
&lt;li&gt;第一层交换机&lt;/li&gt;
&lt;li&gt;第二层交换机&lt;/li&gt;
&lt;li&gt;TOR交换机&lt;/li&gt;
&lt;li&gt;服务器架构&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;无线网络和移动网络&#34;&gt;无线网络和移动网络
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;无线主机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行应用程序的端系统设备&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无线链路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主机通过无线通信链路和基站或主机连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基站&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是&lt;code&gt;无线网络基础设施&lt;/code&gt;的关键部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基础设施模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是与基站向连接的模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自组织模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是没有基站连接,主机之间相互连接的模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多径传播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电磁波在传播的过程中遇到地面物体的反射了一部分,在接收方和发送方之间走了不同的长度的路径.&lt;/p&gt;
&lt;p&gt;4G LTE&lt;strong&gt;架构&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;移动设备&lt;/li&gt;
&lt;li&gt;基站&lt;/li&gt;
&lt;li&gt;HSS&lt;/li&gt;
&lt;li&gt;MME&lt;/li&gt;
&lt;li&gt;P-GW,S-GW&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;计算机网络安全&#34;&gt;计算机网络安全
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;安全通信包含的性质&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;机密性&lt;/li&gt;
&lt;li&gt;报文完整性&lt;/li&gt;
&lt;li&gt;端点鉴别&lt;/li&gt;
&lt;li&gt;运行安全性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;密码散列函数的性质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到任意的两个x,y,使得H(x)=H(y),在计算上是不可能的&lt;/p&gt;
&lt;p&gt;IPsec&lt;strong&gt;的重要协议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AH&lt;/li&gt;
&lt;li&gt;ESP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;防火墙分类&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传统分组过滤器&lt;/li&gt;
&lt;li&gt;状态过滤器&lt;/li&gt;
&lt;li&gt;应用程序网关&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;入侵检测系统和防火墙的主要区别&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;功能差异&lt;/strong&gt;：IDS主要用于检测网络中的&lt;code&gt;异常行为和威胁&lt;/code&gt;，而防火墙则主要用于&lt;code&gt;过滤和阻止网络流量。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应方式&lt;/strong&gt;：IDS警报和记录异常行为，但不直接进行阻断操作；防火墙可以主动拦截和阻止不符合规则的流量。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>互联网计算简洁</title>
        <link>https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E7%AE%80%E6%B4%81/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E7%AE%80%E6%B4%81/</guid>
        <description>&lt;h1 id=&#34;互联网计算简介&#34;&gt;互联网计算简介
&lt;/h1&gt;&lt;h2 id=&#34;接入互联网&#34;&gt;接入互联网
&lt;/h2&gt;&lt;p&gt;网络设备:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网络边沿:&lt;/p&gt;
&lt;p&gt;运行程序,访问互联网的主机&lt;/p&gt;
&lt;p&gt;服务器,电脑,笔记本电脑,手机,智能家具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接入互联网:&lt;/p&gt;
&lt;p&gt;接入互联网的物理设备(介质)&lt;/p&gt;
&lt;p&gt;双绞线,无线路由器,同轴电缆,光纤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络核心:&lt;/p&gt;
&lt;p&gt;链路层交换机,路由器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;交换机制&#34;&gt;交换机制
&lt;/h2&gt;&lt;h3 id=&#34;电路交换&#34;&gt;电路交换
&lt;/h3&gt;&lt;p&gt;当双方想要通信的时候建立一条交换机之间的电路,预留了恒定的传输速度,这种事端到端的连接(P2P)&lt;/p&gt;
&lt;h4 id=&#34;好处&#34;&gt;好处:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;可以预测的行为&lt;/li&gt;
&lt;li&gt;足够简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;坏处&#34;&gt;坏处:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;电路的建立和关闭是复杂的&lt;/li&gt;
&lt;li&gt;当电路没有使用者的时候是空闲的,效率低下&lt;/li&gt;
&lt;li&gt;电路的建立需要消耗时间&lt;/li&gt;
&lt;li&gt;当建立电路的交换机故障时,通信就故障&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分组交换&#34;&gt;分组交换
&lt;/h3&gt;&lt;p&gt;将数据分割成一个个的报文进行根据IP传输,但是会有传输时延,传播时延,排队时延,还有丢包的可能性&lt;/p&gt;
&lt;h4 id=&#34;好处-1&#34;&gt;好处:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;足够效率高&lt;/li&gt;
&lt;li&gt;实现更加简单&lt;/li&gt;
&lt;li&gt;鲁棒性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;坏处-1&#34;&gt;坏处:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;行为不可预测&lt;/li&gt;
&lt;li&gt;需要buffer的管理和拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;虚电路交换&#34;&gt;虚电路交换
&lt;/h3&gt;&lt;p&gt;电路交换+分组交换-&amp;gt;&lt;/p&gt;
&lt;p&gt;选择一条建立的电路,使用报文的形式传输&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E7%AE%80%E6%B4%81/image-20240609165136349.png&#34;
	width=&#34;1638&#34;
	height=&#34;744&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E7%AE%80%E6%B4%81/image-20240609165136349_hu_a618dc7b85e4c6d1.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E7%AE%80%E6%B4%81/image-20240609165136349_hu_f9e4e902c27712f1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609165136349&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;528px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;电路交换相较于分组交换的优点&#34;&gt;电路交换相较于分组交换的优点
&lt;/h3&gt;&lt;p&gt;电路交换：由于电路交换在通信之前要在通信双方之间建立一条被双方独占的物理通
路（由通信双方之间的交换设备和链路逐段连接而成）。因而有以下优点：
（1）由于通信线路为通信双方用户专用，数据直达，所以&lt;code&gt;传输数据的时延非常小&lt;/code&gt;
（2）通信双方之间的物理通路一旦建立，双方可以随时通信，&lt;code&gt;实时性强。&lt;/code&gt;
（3）双方通信时按发送顺序传送数据，&lt;code&gt;不存在失序问题。&lt;/code&gt;
（4）电路交换既适用于&lt;code&gt;传输模拟信号&lt;/code&gt;，也适用于&lt;code&gt;传输数字信号。&lt;/code&gt;
（5）电路交换设备控制均&lt;code&gt;较简单&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;tmd相较于fmd的优点&#34;&gt;TMD相较于FMD的优点
&lt;/h3&gt;&lt;p&gt;TDM比FDM的优点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发生拥塞等网络问题时，&lt;code&gt;TDM中的数据丢失可能只会是一部分，而FDM中就可能&lt;/code&gt;
&lt;code&gt;是大部分或全部。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TDM适合数字信号传输&lt;/code&gt;，而FDM适合模拟信号传输，因为现在通信网络多是传输数
字信号，所以TDM比FDM好。&lt;/li&gt;
&lt;li&gt;因为频分复用连接建立后，当中途没有数据传输时，他所占有的频段带宽不能被其
他连接使用，故可能存在空置，而在时分复用的统计时分模式下，连接建立后，当某
个连接暂时不用传输数据时可以少分时间片或者不分，即其&lt;code&gt;时隙的分配时“按需分&lt;/code&gt;
&lt;code&gt;配”&lt;/code&gt;，这样就让出了相应的传输时间给其他连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;交换技术时延计算核心公式-&#34;&gt;交换技术时延计算核心公式 ⏱️
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;发送延时在每一个路由器上（包括原主机上）都要记一次，一次的发送延时是发送一次分组的时间。&lt;/p&gt;
&lt;p&gt;在进行分组传输比较麻烦的情况可以使用画图的形式来说明。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;1-电路交换-circuit-switching-&#34;&gt;1. 电路交换 (Circuit Switching) 📞
&lt;/h3&gt;&lt;p&gt;通信前先建立专用物理路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总时延 ($T_{circuit}$)&lt;/strong&gt; $\approx$ &lt;strong&gt;连接建立时延&lt;/strong&gt; + &lt;strong&gt;数据传输时延&lt;/strong&gt; + &lt;strong&gt;传播时延&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;连接建立时延 ($T_{setup}$):&lt;/strong&gt; 建立完整连接所需时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据传输时延 ($T_{data}$):&lt;/strong&gt; $\frac{\text{报文总长度 (bits)}}{\text{数据传输速率 (bps)}}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传播时延 ($T_{prop}$):&lt;/strong&gt; 信号在物理介质中传播所需时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt; 一旦连接，时延固定，无排队。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2-报文交换-message-switching-&#34;&gt;2. 报文交换 (Message Switching) 📦
&lt;/h3&gt;&lt;p&gt;整个报文作为单个单元进行“存储-转发”。整个包是一个分组！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总时延 ($T_{message}$)&lt;/strong&gt; $\approx$ &lt;strong&gt;H × (报文发送时延 + 报文传播时延)&lt;/strong&gt; + &lt;strong&gt;(H-1) × (处理时延 + 排队时延)&lt;/strong&gt;
(其中 H 为跳数/链路段数)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;报文发送时延:&lt;/strong&gt; $\frac{\text{报文总长度 (bits)}}{\text{链路速率 (bps)}}$ (每段链路都发生)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文传播时延:&lt;/strong&gt; 信号在每段链路上传播的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理时延:&lt;/strong&gt; 节点处理报文的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排队时延:&lt;/strong&gt; 报文在节点等待转发的时间 (高度可变)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt; 完整报文存储转发，有显著排队时延。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-分组交换-packet-switching-&#34;&gt;3. 分组交换 (Packet Switching) ✉️
&lt;/h3&gt;&lt;p&gt;报文被分割成小数据包（分组），每个分组独立进行“存储-转发”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总时延 ($T_{packet}$)&lt;/strong&gt; $\approx$ &lt;strong&gt;(P + H - 1) × 分组发送时延&lt;/strong&gt; + &lt;strong&gt;总传播时延&lt;/strong&gt; + &lt;strong&gt;总处理与排队时延&lt;/strong&gt;
(P 为分组数，H 为跳数/链路段数)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分组发送时延:&lt;/strong&gt; $\frac{\text{单个分组长度 (bits)}}{\text{链路速率 (bps)}}$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总传播时延:&lt;/strong&gt; 所有链路段传播时延之和。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总处理与排队时延:&lt;/strong&gt; 所有中间节点处理和排队时延之和 (高度可变)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键在于流水线效应：&lt;/strong&gt; 第一个分组到达后，后续分组相继到达，减少了等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点:&lt;/strong&gt; 分组流水线传输，比报文交换高效，但仍有排队时延。&lt;/p&gt;
&lt;p&gt;分组计算的方式如下：&lt;/p&gt;
&lt;p&gt;假设有k条路，每条路的传播时延为i，中间节点有k-1个，处理时延为m，传输速率为b，分组有n个，每个分组的大小是r，则总的时延为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传输时延：（源主机传输时延）（n*r）/b+(每一个中间节点的传输时延)(（k-1）*(r/b))&lt;/li&gt;
&lt;li&gt;传播时延：k*i&lt;/li&gt;
&lt;li&gt;处理时延：m*(k-1)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;通用时延组成部分：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发送/传输时延 ($T_{tx}$):&lt;/strong&gt; 数据量 / 带宽&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传播时延 ($T_{prop}$):&lt;/strong&gt; 距离 / 传播速率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理时延 ($T_{proc}$):&lt;/strong&gt; 节点处理数据所需时间 (通常较小)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排队时延 ($T_{queue}$):&lt;/strong&gt; 等待网络资源所花费的时间 (受网络拥塞影响，最难预测)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 上述公式为简化模型。实际网络中，排队时延非常复杂，通常用排队论模型分析。&lt;/p&gt;
&lt;h2 id=&#34;统计多路复用&#34;&gt;统计多路复用
&lt;/h2&gt;&lt;p&gt;Link bandwidth shared on demand (按需共享)&lt;/p&gt;
&lt;p&gt;就是根据计算每一个用户使用网络的流量概率来计算出在平时会有多大的几率出现拥塞的情况&lt;/p&gt;
&lt;h2 id=&#34;iso-osi模型&#34;&gt;ISO-OSI模型
&lt;/h2&gt;&lt;p&gt;每一层都要依靠下一层去实现自己的功能&lt;/p&gt;
&lt;p&gt;每一层都向上一层去提供功能&lt;/p&gt;
&lt;h3 id=&#34;传统的osi模型&#34;&gt;传统的OSI模型
&lt;/h3&gt;&lt;p&gt;ISO-OSI模型（International Standards Organization Open Systems Interconnection model，国际标准化组织开放系统互联模型）是一个概念模型，用于标准化网络通信，确保不同系统和网络设备之间可以互相通信。OSI模型将复杂的网络通信任务分为七个独立的层次，每一层都有特定的功能和职责。这个模型为理解和设计网络体系结构提供了一个直观的框架。&lt;/p&gt;
&lt;p&gt;OSI/ISO模型和TCP/IP模型又一点的不同，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSI的传输层提供的是有链接的服务，二在网络层提供的是有连接的和无连接的协议；TCP/IP在传输层提供有链接的TCP协议和无连接的UDP协议，但是在网络层只提供无连接的IP协议。&lt;/li&gt;
&lt;li&gt;传输层协议是端到端的，也就是从原主机到目的主机进程之间的通信，而网络层和链路层是点到点的连接，也就是主机之间的通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcpip模型&#34;&gt;TCP/IP模型：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物理层（Physical Layer）&lt;/strong&gt;-&amp;gt;比特流&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; 物理层在实际媒介负责传输原始的比特流，并定义设备和传输介质之间的电气、机械和功能特性。它涉及的内容包括连接器类型、电缆标准、信号电压和脉冲等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作内容：&lt;/strong&gt; 比特流传输、物理连接的建立和终止、信号调制和脉冲编码等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据链路层（Data Link Layer）&lt;/strong&gt;-&amp;gt;帧（点到点）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;链路层帧是链路层协议在实际传输介质上传输数据时所使用的单位。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; &lt;code&gt;数据链路层负责提供节点到节点的数据传输&lt;/code&gt;，确保传输的可靠性。它处理帧的创建、发送、接收和确认，并检测和纠正传输错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作内容：&lt;/strong&gt; 帧同步、流量控制、错误检测和校正、媒体访问控制（MAC）等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络层（Network Layer）&lt;/strong&gt;-&amp;gt;数据报&lt;/p&gt;
&lt;p&gt;&lt;code&gt;网络层数据报是IP协议在进行路由转发时所使用的数据单位。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; &lt;code&gt;网络层负责选择最佳路径将数据包从源送到目标，逻辑选址，路由选择&lt;/code&gt;（如IP地址），并管理网络拥塞。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作内容：&lt;/strong&gt; 路由选择、逻辑地址管理、路径优化、流量控制和分组转发等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输层（Transport Layer）&lt;/strong&gt;-&amp;gt;报文段&lt;/p&gt;
&lt;p&gt;&lt;code&gt;运输层报文段是TCP或UDP在传输数据时所使用的数据单位。&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; &lt;code&gt;传输层确保可靠的端到端通信&lt;/code&gt;，数据包的顺序性可靠交付，实现流量控制和拥塞控制。主要协议包括TCP和UDP。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作内容：&lt;/strong&gt; 传输连接的建立和终止、分段和重组、流量控制、错误检测和恢复等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用层（Application Layer）&lt;/strong&gt;-&amp;gt;报文&lt;/p&gt;
&lt;p&gt;&lt;code&gt;应用层报文是应用层协议用于交换数据的基本单位,&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能：&lt;/strong&gt; &lt;code&gt;应用层提供用户直接与网络交互的接口&lt;/code&gt;，支持应用服务。它定义了应用程序如何与网络通信，并为常见网络服务提供支持，如邮件、文件传输和远程登录等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作内容：&lt;/strong&gt; 提供网络服务接口、支持不同的网络应用（如HTTP、FTP、SMTP、Telnet等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;路由器处理网络层、链路层、物理层协议。&lt;/li&gt;
&lt;li&gt;链路层交换机处理链路层、物理层协议。&lt;/li&gt;
&lt;li&gt;主机处理应用层、运输层、网络层、链路层、物理层协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;网络评估&#34;&gt;网络评估
&lt;/h2&gt;&lt;h3 id=&#34;延迟&#34;&gt;延迟
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;传输延迟:&lt;/p&gt;
&lt;p&gt;$T_{delay}=\frac{L}{R}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传播延迟:&lt;/p&gt;
&lt;p&gt;$P_{delay}=\frac{Distance}{V_{light}}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排队延迟:&lt;/p&gt;
&lt;p&gt;$L&amp;lt;length\ of \ the\ queue&amp;gt;=A&amp;lt;average\ speed\ the \ packet\ arrive&amp;gt;\times W&amp;lt;average\ time\ the \ packet \ waitting \ in \ queue&amp;gt;$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理延迟&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;吞吐量&#34;&gt;吞吐量
&lt;/h3&gt;&lt;p&gt;$Throughput=\frac{L}{T_{delay}+P_{delay}}$&lt;/p&gt;
</description>
        </item>
        <item>
        <title>传输层</title>
        <link>https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/</guid>
        <description>&lt;h1 id=&#34;tcp的基础简介&#34;&gt;TCP的基础简介
&lt;/h1&gt;&lt;h2 id=&#34;套接字和端口&#34;&gt;套接字和端口
&lt;/h2&gt;&lt;p&gt;端口-&amp;gt;是在报文段中用于指示OS中的具体的套接字&lt;/p&gt;
&lt;p&gt;套接字-&amp;gt;是运行在OS中的&lt;/p&gt;
&lt;h3 id=&#34;套接字socket&#34;&gt;&lt;strong&gt;套接字(Socket)&lt;/strong&gt;:
&lt;/h3&gt;&lt;p&gt;套接字是一种软件抽象,它允许应用进程与操作系统的传输层(transport layer)进行网络消息交换。套接字提供了一种标准的编程接口,使得应用程序可以独立于底层网络协议进行通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层地址&lt;/strong&gt;:
套接字由两部分组成:&amp;lt;主机IP, 端口号&amp;gt;。这个地址组合被称为套接字。&lt;/p&gt;
&lt;h3 id=&#34;端口&#34;&gt;端口:
&lt;/h3&gt;&lt;p&gt;16位数字用于区分应用程序:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络数据包的传输头部中包含源端口号和目的端口号。&lt;/li&gt;
&lt;li&gt;这些数字有助于路由器和其他网络设备识别和区分不同的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多路复用和反多路复用&#34;&gt;多路复用和反多路复用
&lt;/h2&gt;&lt;h3 id=&#34;udp协议&#34;&gt;UDP协议
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;是&lt;code&gt;无连接&lt;/code&gt;的协议,只根据目的IP和目的端口来将报文段分配给相应的套接字&lt;/li&gt;
&lt;li&gt;与TCP相比，UDP是一种更轻量级的传输协议。UDP通常被用于实时应用或对延迟要求较高的情况，因为它不提供像TCP那样的顺序传送和重传机制。通过使用UDP，可以避免TCP中对包序号、重传和流控制等方面带来的开销和延迟.&lt;/li&gt;
&lt;li&gt;是一种尽力而为的协议&lt;/li&gt;
&lt;li&gt;有DNS,流媒体应用来使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;头信息&#34;&gt;头信息
&lt;/h4&gt;&lt;p&gt;占用8字节&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610102114637-8078080.png&#34;
	width=&#34;662&#34;
	height=&#34;518&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610102114637-8078080_hu_dc372b72da07e4f1.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610102114637-8078080_hu_77ca24eb3027d0d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610102114637&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;306px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;length:应用报文+头的长度&lt;/li&gt;
&lt;li&gt;checksum:校验和&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;checksum&#34;&gt;checksum:
&lt;/h4&gt;&lt;p&gt;将每16bits作为一个加数相加(包括应用报文和头),进位是将1加到个位,最终得到一个16bits的相加和以后,将取反码,得到最终的校验和&lt;/p&gt;
&lt;h3 id=&#34;tcp协议&#34;&gt;TCP协议
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;是有连接的,以连接为导向的协议,根据源IP地址,源端口,目的地址,目的端口来分配套接字&lt;/li&gt;
&lt;li&gt;提供可靠的,顺序的字节流服务,流量控制&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;头信息-1&#34;&gt;头信息
&lt;/h4&gt;&lt;p&gt;占用20字节&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610102733023-8078080.png&#34;
	width=&#34;1004&#34;
	height=&#34;777&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610102733023-8078080_hu_eb281ac41813ea52.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610102733023-8078080_hu_1a17d4462223ef5.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610102733023&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;129&#34;
		data-flex-basis=&#34;310px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;序列号（Sequence Number）&lt;/strong&gt;：对于sender有用,是当前发送的数据包的首位的字节序列号,我要发的数据的SQ是对方上次发送的ack序列号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;确认号（Acknowledgment Number）&lt;/strong&gt;：对于receiver有用,对于接受的数据包的确认,,我要发送的ack序列号是上次接收到的序列号+报文的长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HdrLen&lt;/strong&gt;:表明头部的长度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制位（Flags）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;URG&lt;/strong&gt;（紧急指针有效）：表示紧急指针字段是否有效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;（确认序号有效）：&lt;code&gt;表示确认序号字段是否有效。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PSH&lt;/strong&gt;（立即传输）：表示接收方应用程序应该尽快从接收缓冲区读取数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RST&lt;/strong&gt;（连接复位）：用于重置连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SYN&lt;/strong&gt;（同步序号）：&lt;code&gt;用于建立连接。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIN&lt;/strong&gt;（连接终止）：&lt;code&gt;用于释放连接。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;窗口大小（Window Size）&lt;/strong&gt;：占用16个比特，指示发送方期望接收的字节数量，用来控制流量和流量控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和（Checksum）&lt;/strong&gt;：占用16个比特，用于校验TCP头部和数据段完整性，以检测可能的错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;紧急指针（Urgent Pointer）&lt;/strong&gt;：占用16个比特，在URG标志位设置的情况下表明紧急数据的末尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意这里面的序列号都是按照Byte的顺序去划分的,即发送的数据包的开头是总共发送的数据包的第几个字节.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcp的建立和关闭&#34;&gt;TCP的建立和关闭
&lt;/h1&gt;&lt;h2 id=&#34;tcp三次握手四次挥手&#34;&gt;TCP三次握手,四次挥手
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/m0_56649557/article/details/119492899&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;简单理解TCP三次握手四次挥手（看一遍你就懂）-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3次握手&#34;&gt;3次握手:
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一次握手（SYN）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;客户端（Client）首先向服务器（Server）发送一个特殊的TCP包，其中包含一个SYN标志（Syn请求连接）。这个包也包含客户端初始化的序列号，用来启动连接。发送该包后，客户端进入SYN_SENT状态，等待服务器的确认。&lt;/li&gt;
&lt;li&gt;发送(SYN,Sequence=ISN_A,ACK=NA)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次握手（SYN + ACK）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;服务器收到客户端的SYN包之后，会回复一个包，其中第二次握手中同时包含了SYN标志和ACK标志（即确认号ACK加上SYN标志）。这个包表示服务器已接收到客户端的请求，并且对客户端的序列号进行了确认。此时，服务器会生成自己的序列号。发送完这个包后，服务器进入SYN_RECV状态。&lt;/li&gt;
&lt;li&gt;发送(SYN+ACK,Sequence=ISN_B,ACK=ISN+length)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三次握手（ACK）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;最后，客户端收到服务器的确认包后，也会回复一个包作为第三次握手的确认。这个包中只有ACK标志，确认服务器的序列号。在这一步完成后，客户端和服务器之间的连接建立成功，双方都可以开始传输数据。此时，客户端和服务器都进入ESTABLISHED状态。&lt;/li&gt;
&lt;li&gt;发送(ACK,Sequence=ISN_A,ACK=ISN_B+length)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610111432241-8078080.png&#34;
	width=&#34;1358&#34;
	height=&#34;755&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610111432241-8078080_hu_e0b0f71c1d34067d.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610111432241-8078080_hu_fb367c4814f765c4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610111432241&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;431px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;四次挥手
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一次挥手（FIN）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;结束方（通常是客户端或服务器一方）首先向对方发送一个FIN（Finish）消息，表示它不再有数据要发送给对方。发送这个包后，结束方进入FIN_WAIT_1状态，等待对方的确认。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次挥手（ACK）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;接收方收到结束方发送的FIN消息后，会发送一个确认消息（ACK）作为第二次挥手的响应。此时，接收方进入CLOSE_WAIT状态,结束方进入FIN_WAIT_2阶段.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三次挥手（FIN）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;接收方发送完最后的数据后，也会向结束方发送一个FIN消息，表示它同意关闭连接。发送这个FIN消息后，接收方进入LAST_ACK状态.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第四次挥手（ACK）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;最后，结束方收到接收方发送的FIN消息后，会发送一个确认消息（ACK），作为最后的确认。一旦双方都发送了ACK，连接就会完全关闭。在此时，结束方进入TIME_WAIT状态，等待一段时间后才会进入CLOSED状态，连接正式关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112313249-8078080.png&#34;
	width=&#34;937&#34;
	height=&#34;565&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112313249-8078080_hu_115812ce13867d38.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112313249-8078080_hu_5dbcd473e6aa9662.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610112313249&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;398px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;生命周期&#34;&gt;生命周期
&lt;/h3&gt;&lt;h4 id=&#34;客户端&#34;&gt;客户端
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112404419-8078080.png&#34;
	width=&#34;1126&#34;
	height=&#34;803&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112404419-8078080_hu_27bca285156d5c87.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112404419-8078080_hu_a8cdc19a38498a9.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610112404419&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;336px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;服务端&#34;&gt;服务端
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112450437-8078080.png&#34;
	width=&#34;1186&#34;
	height=&#34;792&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112450437-8078080_hu_a81673b50f9bb568.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610112450437-8078080_hu_f432dd94efe76b9c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610112450437&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;359px&#34;
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcp协议传输&#34;&gt;TCP协议传输
&lt;/h1&gt;&lt;h2 id=&#34;可靠传输&#34;&gt;可靠传输
&lt;/h2&gt;&lt;h3 id=&#34;可能发生的错误&#34;&gt;可能发生的错误
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据包损坏(bit errors):
&lt;ul&gt;
&lt;li&gt;TCP 使用校验和(checksum)机制来检测数据包在传输过程中是否发生了错误。&lt;/li&gt;
&lt;li&gt;如果发现数据包已被损坏,TCP 会自动重传该数据包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据包丢失(why?):
&lt;ul&gt;
&lt;li&gt;TCP 使用序列号和确认机制来检测和重传丢失的数据包。&lt;/li&gt;
&lt;li&gt;当发送端没有收到预期的确认,就会重传数据包。&lt;/li&gt;
&lt;li&gt;超时会自动重传&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据包延迟(why?):
&lt;ul&gt;
&lt;li&gt;TCP 使用重传机制和拥塞控制算法来应对网络拥塞导致的延迟问题。&lt;/li&gt;
&lt;li&gt;发送端会跟踪网络状况,并动态调整发送速率,以避免缓存溢出和网络拥塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据包乱序(why?):
&lt;ul&gt;
&lt;li&gt;TCP 使用序列号来重新排序接收到的数据包。&lt;/li&gt;
&lt;li&gt;接收端会缓存乱序到达的数据包,并根据序列号将它们重新排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据包重复(why?):
&lt;ul&gt;
&lt;li&gt;TCP 使用序列号和确认机制来检测和丢弃重复的数据包。&lt;/li&gt;
&lt;li&gt;如果发送端收到重复的确认,就不会重传数据包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;传输方式接收ack&#34;&gt;传输方式(接收ACK)
&lt;/h3&gt;&lt;h4 id=&#34;stop-and-wait&#34;&gt;Stop and Wait
&lt;/h4&gt;&lt;p&gt;每次发送一个请求然后等待ACK,超时重传,相当于发送的窗口为1,接受的窗口为1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240609214612545-8078080.png&#34;
	width=&#34;498&#34;
	height=&#34;152&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240609214612545-8078080_hu_76aa74b08f300bad.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240609214612545-8078080_hu_914244a51daa0c7d.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609214612545&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;327&#34;
		data-flex-basis=&#34;786px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240609214624490-8078080.png&#34;
	width=&#34;375&#34;
	height=&#34;144&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240609214624490-8078080_hu_4f4ced4b79877cea.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240609214624490-8078080_hu_6030ccba580435aa.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609214624490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;260&#34;
		data-flex-basis=&#34;625px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;流水线传输&#34;&gt;流水线传输
&lt;/h4&gt;&lt;p&gt;接连着发送m个数据包,等待这m个ack.&lt;/p&gt;
&lt;p&gt;使用滑动窗口技术&lt;/p&gt;
&lt;p&gt;滑动窗口的工作原理如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发送端维护一个发送窗口,表示可以发送但未被确认的数据包集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收端维护一个接收窗口,表示可以接收的数据包范围。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当接收端确认窗口内的数据包时,发送端就可以将这些数据包从发送窗口中移除,并滑动窗口。&lt;/p&gt;
&lt;p&gt;只有当最左边的数据包被ack以后才能够移动窗口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过动态调整窗口大小,TCP 可以实现流量控制和拥塞控制,提高传输效率和可靠性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种接收的方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GBN&lt;/li&gt;
&lt;li&gt;SR&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gbn协议与sr协议&#34;&gt;GBN协议与SR协议
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_35812205/article/details/108693965&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GBN协议复习_确认分组和确认号-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;gbn&#34;&gt;GBN
&lt;/h3&gt;&lt;h4 id=&#34;对于发送端的重传方式是gbn&#34;&gt;对于发送端的重传方式是GBN:
&lt;/h4&gt;&lt;p&gt;相当于发送方的滑动窗口为n,接收方的滑动窗口为1.&lt;/p&gt;
&lt;p&gt;为整个的发送的窗口建立一个时钟,当最左边的数据包接收到ACK以后,就重置窗口时钟.当超时的时候就将所有窗口中已经发送过的数据包全部重传.&lt;/p&gt;
&lt;h4 id=&#34;对于接受端是accumulate-ack&#34;&gt;对于接受端是Accumulate ACK
&lt;/h4&gt;&lt;p&gt;接收端的滑动窗口只有一个,就是只能够接收一个特定的数据包,当返回ACK(n)的时候,说明该数据帧和之前的所有数据帧都是已经接收.此时发送端应该要发送Sq(n+1).&lt;/p&gt;
&lt;h3 id=&#34;sr&#34;&gt;SR
&lt;/h3&gt;&lt;h4 id=&#34;发送方的发送方式是sr&#34;&gt;发送方的发送方式是SR
&lt;/h4&gt;&lt;p&gt;相当于发送方的滑动窗口为n,接收方的滑动窗口为n&lt;/p&gt;
&lt;p&gt;对于每一个发送的数据包设置一个时钟,当发生超时的时候只重传这单个的数据包;当接收到NACK的时候,也只是重传这个数据包.&lt;/p&gt;
&lt;h4 id=&#34;接收方的接受方式是selective-ack&#34;&gt;接收方的接受方式是Selective ACK
&lt;/h4&gt;&lt;p&gt;接收方的滑动窗口是n.&lt;/p&gt;
&lt;p&gt;对接收到的每一个数据包都发送一个ACK,假如在接收方对于未正确接受的帧发送NACK&lt;/p&gt;
&lt;h2 id=&#34;tcp的快速重传机制&#34;&gt;&lt;strong&gt;TCP的快速重传机制&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/whgtheone/article/details/80983882&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP的快速重传机制_快重传包括第一个-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为想要唤醒重传的机制,需要等待数据包在sender端超时,所以可以使用冗余的3个ack在receiver端提醒sender端进行快速重传.&lt;/p&gt;
&lt;p&gt;条件:3个冗余的ack-&amp;gt;&lt;code&gt;即顺序地接受到4个ack(一个ack是正常的)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在receiver端,维护一个长度为n的滑动窗口,使用类GBN的协议.(也就是在接收到其他的非ACK但是在滑动窗口中的数据包的时候,会将这个数据包进行缓存)&lt;/li&gt;
&lt;li&gt;发送端还是继续发送滑动窗口中的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何确立timeout&#34;&gt;&lt;strong&gt;如何确立timeout&lt;/strong&gt;
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;EstimatedRTT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;EstimatedRTT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;SampleRTT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;C:/Users/24165/Downloads/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deviation= | SampleRTT–EstimatedRTT|&lt;/li&gt;
&lt;li&gt;DevRTT: exponential average of Deviation&lt;/li&gt;
&lt;li&gt;RTO = EstimatedRTT+ 4 x DevRTT&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp流量控制拥塞控制&#34;&gt;TCP流量控制,拥塞控制:
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_42214953/article/details/105832303&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;浅谈TCP拥塞控制：慢启动和拥塞避免、快速重传和快速恢复_tcp慢启动-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;流量控制接收端要考虑的事情&#34;&gt;流量控制:(接收端要考虑的事情)
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_46631497/article/details/137252874&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;什么是TCP流量控制？（解释说明+过程+示例）_计算机网络 流量控制-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#流量控制是由receiver来控制的,因为可能sender发送的数据过多导致超过了receiver的buffer所以需要控制sender的发送速率.&lt;/p&gt;
&lt;p&gt;→AWND&lt;/p&gt;
&lt;h4 id=&#34;接收端&#34;&gt;接收端:
&lt;/h4&gt;&lt;p&gt;每一次接受者返回ACK的时候都会发送一个Advertised Window的值(RWND),这个值应该是receiver的buffer(Window)的边界距离最后一个接受的数据比特的长度&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610144923197-8078080.png&#34;
	width=&#34;1299&#34;
	height=&#34;814&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610144923197-8078080_hu_2780576969e680b0.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610144923197-8078080_hu_454493a05ae44ad4.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610144923197&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;发送端&#34;&gt;发送端
&lt;/h4&gt;&lt;p&gt;发送端能够发送的数据包只能是RWND的范围,即从发送但是没有ACK的第一个字节到加上RWND的范围.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610145157084-8078080.png&#34;
	width=&#34;1223&#34;
	height=&#34;768&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610145157084-8078080_hu_5852914ae86acaa0.png 480w, https://114514yangyi.github.io/huyang/p/%E4%BC%A0%E8%BE%93%E5%B1%82/image-20240610145157084-8078080_hu_3e566450cfdf8ba1.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240610145157084&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;拥塞控制发送端要考虑的事情&#34;&gt;拥塞控制:(发送端要考虑的事情)
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;决定怎么去分配在链路上的不同的终端的流量&lt;/li&gt;
&lt;li&gt;动态分配流量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#根据丢包的数量来决定网络的拥塞状况&lt;/p&gt;
&lt;p&gt;→CWND&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;slow start :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;每一个RTT都将CWND进行double,相当于队每一个ACK都加上1; 直到CWND超过了”slow start threshold”→ssthresh&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“Additive Increase Multiplicative Decrease” (AIMD):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;对于每一个RTT都将CWND加一,对于每一个ACK都将CWDN加&lt;/code&gt;$\frac{1}{CWND}$​;&lt;/p&gt;
&lt;p&gt;丢包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三次冗余的ACK-&amp;gt;$$ssthresh=\frac{CWND}{2};CWND=ssthresh$$&lt;/li&gt;
&lt;li&gt;超时-&amp;gt;$ssthresh =\frac{CWND}{2};CWND=1$;initial slow start ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;能够很好地解决效率和公平性的问题&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;快速恢复&#34;&gt;快速恢复
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;一般和快速重传一起使用&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发送端收到第三个重复确认的报文时，会更新ssthresh的值为$\frac{CWND}{2}$，然后立即重传丢失的报文段，并且设置：cwnd = ssthresh+3*SMSS，进入拥塞避免阶段。&lt;/li&gt;
&lt;li&gt;拥塞避免阶段:当收到一个重复确认的报文时，设置cwnd = cwnd +SMSS。此时发送端可以发送新的TCP报文（如果新的cwnd允许）(发送接下来上次发送的序列号)&lt;/li&gt;
&lt;li&gt;当收到新数据的确认时，设置cwnd=ssthresh。进入拥塞避免阶段,此时的$ssthresh=cwnd=\frac{(旧)cwnd}{2}$;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;其他的tcp拥塞控制协议&#34;&gt;其他的TCP拥塞控制协议:
&lt;/h3&gt;&lt;p&gt;基本的情况:three dupACK and timeout-&amp;gt;ssthresh=$\frac{CWND}{2}$&lt;/p&gt;
&lt;p&gt;• TCP-Tahoe&lt;br&gt;
CWND =1 on 3 dupACKs&lt;/p&gt;
&lt;p&gt;并且只有快速重传,没有快速回复&lt;/p&gt;
&lt;p&gt;• TCP-Reno
CWND =1 on timeout
CWND = CWND/2 on 3 dupACKs&lt;/p&gt;
&lt;p&gt;有快速恢复机制&lt;/p&gt;
&lt;p&gt;• TCP-newReno
TCP-Reno + improved fast recovery Our default  assumption&lt;/p&gt;
&lt;p&gt;• TCP-SACK
Incorporates selective acknowledgements&lt;/p&gt;
&lt;h2 id=&#34;可靠数据传输协议-rdt&#34;&gt;可靠数据传输协议 rdt
&lt;/h2&gt;&lt;h3 id=&#34;完全可信的信道&#34;&gt;完全可信的信道
&lt;/h3&gt;&lt;p&gt;信道:没有差错,速率恒定,按照顺序接受&lt;/p&gt;
&lt;p&gt;使用rdt1.0传输,即&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送方:经过调用就直接传输数据&lt;/li&gt;
&lt;li&gt;接收方:直接接受数据,并且返回给上层&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;具有比特差错的信道&#34;&gt;具有比特差错的信道
&lt;/h3&gt;&lt;p&gt;信道:有比特差错,按照顺序接受&lt;/p&gt;
&lt;p&gt;使用rdt2.0,接收方具有比特差错检验:校验和&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送端:等待上层调用发送数据后,等待ACK或者NACK;加入收到ACK就直接继续等待上层调用,收到NACK,就重新发送并且继续等待.&lt;/li&gt;
&lt;li&gt;接受端:接受数据包,进行比特差错检验,假如正确就直接返回给上层,并且返回ACK;否则就发送NACK,并且丢弃数据包.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;具有比特差错的丢包信道&#34;&gt;具有比特差错的丢包信道
&lt;/h3&gt;&lt;p&gt;信道:具有比特差错,并且会丢包,非顺序接受&lt;/p&gt;
&lt;p&gt;使用rdt3.0,也叫做&lt;code&gt;比特交替协议&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;就是sender端交替发送包序列号为1,0的包;&lt;/p&gt;
&lt;p&gt;receiver端交替接受1,0包并发送ack给sender端&lt;/p&gt;
</description>
        </item>
        <item>
        <title>应用层</title>
        <link>https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
        <description>&lt;h1 id=&#34;应用层&#34;&gt;应用层
&lt;/h1&gt;&lt;p&gt;作用:提供用户或者应用程序访问互联网的接口&lt;/p&gt;
&lt;h2 id=&#34;应用层结构&#34;&gt;应用层结构
&lt;/h2&gt;&lt;h3 id=&#34;客户服务器结构&#34;&gt;客户/服务器结构
&lt;/h3&gt;&lt;h4 id=&#34;客户端client&#34;&gt;客户端（Client）：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动方式&lt;/strong&gt;：根据需要启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;联系服务器方式&lt;/strong&gt;：客户端主动与服务器建立联系，客户端先发起通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态IP地址&lt;/strong&gt;：客户端可能具有动态分配的IP地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;服务器server&#34;&gt;服务器（Server）：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运行方式&lt;/strong&gt;：作为守护进程（始终运行）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供服务方式&lt;/strong&gt;：向客户端提供请求的服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;固定IP地址&lt;/strong&gt;：服务器通常具有固定的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;peer-to-peer结构&#34;&gt;peer-to-peer结构
&lt;/h3&gt;&lt;h3 id=&#34;核心特点&#34;&gt;核心特点：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无始终在线服务器&lt;/strong&gt;：对等网络中没有始终在线的中央服务器，而是由各个端系统直接相互通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;端系统直接通信&lt;/strong&gt;：对等网络中的节点（对等者）可以互相请求服务，也可以相互提供服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自我可扩展性&lt;/strong&gt;：新的节点加入可以带来新的服务能力，同时也带来新的服务需求，因此网络具有自我扩展的性质。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点连接多变&lt;/strong&gt;：对等节点的连接不稳定，IP地址可能会改变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高度扩展性但管理困难&lt;/strong&gt;：对等网络具有很高的可扩展性，但管理复杂度较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns--domain-name-service-域名解析服务&#34;&gt;DNS : Domain Name Service 域名解析服务
&lt;/h2&gt;&lt;p&gt;将域名解析陈相应的IP地址&lt;/p&gt;
&lt;h3 id=&#34;层次化的域名解析&#34;&gt;层次化的域名解析
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;根域名服务器（Root Name Servers）：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：根域名服务器位于 DNS 层次结构的最顶部，负责管理顶级域的信息，当本地域名服务器无法解析域名时，会联系根域名服务器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：根域名服务器不直接回答 DNS 查询，而是指示本地域名服务器转向哪个顶级域名服务器处理查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;顶级域名服务器（Top-Level Domain Servers）：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：顶级域名服务器负责管理顶级域（TLD）信息，如.com、.org、.net、.edu等，以及各国家顶级域，如.cn、.uk、.fr等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：当本地域名服务器接收到从根域名服务器指示后的查询，会进一步向适当的顶级域名服务器发出查询以获取更详细的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;权威 DNS 服务器（Authoritative DNS Servers）：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：权威 DNS 服务器包含有关特定域的权威信息，负责提供给查询者域名到IP地址的映射。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：当本地域名服务器需要解析特定域的信息时，会向该域的权威 DNS 服务器发送查询请求以获取准确的映射关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;本地域名服务器（Local Name Servers）：&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：本地域名服务器通常由住宅ISP、公司或大学维护，存储已查询过的域名映射关系，提高解析效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：当用户设备发起 DNS 查询时，查询会首先发送到本地域名服务器，如果本地服务器有相应的记录，将直接返回结果；否则，会按照层级结构向更高级的域名服务器继续查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Every server knows the root&lt;/li&gt;
&lt;li&gt;Root server knows about all top-level domains&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;域名解析的顺序&#34;&gt;域名解析的顺序:
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609175307118-8078316.png&#34;
	width=&#34;858&#34;
	height=&#34;827&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609175307118-8078316_hu_36c42035f3b852bd.png 480w, https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609175307118-8078316_hu_75f72f1c812c9d9f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609175307118&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;103&#34;
		data-flex-basis=&#34;248px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;dns记录&#34;&gt;DNS记录
&lt;/h3&gt;&lt;p&gt;DNS （域名系统）记录是存储在 DNS 服务器中的资源记录，用于将域名映射到对应的 IP 地址或其他信息。这些 DNS 记录称为 DNS 资源记录（DNS resource record，RR），其格式通常为（名称，值，类型，生存时间）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;名称&lt;/strong&gt;（Name）：记录的域名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;值&lt;/strong&gt;（Value）：与该域名相关联的内容，比如 IP 地址或其他记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt;（Type）：指明值的类型，表明这条记录的含义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TTL&lt;/strong&gt;（Time to Live）：生存时间，指定该记录在其他 DNS 服务器中可以被缓存的时间长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见的-dns-资源记录类型&#34;&gt;常见的 DNS 资源记录类型：
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;NS（Name Server）&lt;/strong&gt;：指定某个域名使用哪个 DNS 服务器来进行解析。
&lt;ul&gt;
&lt;li&gt;例如：(networkutopia.com, dns1.networkutopia.com, NS, 32768)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MX（Mail Exchanger）&lt;/strong&gt;：指定接收该域名邮件的邮件服务器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A（Address）&lt;/strong&gt;：将主机名解析为 IPv4 地址。
&lt;ul&gt;
&lt;li&gt;例如：(dns1.networkutopia.com, 212.212.212.1, A, 5600)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CNAME（Canonical Name）&lt;/strong&gt;：为一个主机定义一个别名, 常用于重定向网址到另一个域名。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;em--电子邮件&#34;&gt;EM : 电子邮件
&lt;/h2&gt;&lt;h3 id=&#34;组成部分&#34;&gt;组成部分:
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户代理 (User Agent)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：用户代理是用户使用的邮件客户端，用于创建、发送、接收和管理电子邮件。这包括常见的邮件应用程序如Outlook、Gmail、Thunderbird等。用户代理提供用户界面，允许用户编写邮件、添加附件、设定接收人等操作，同时负责显示收到的邮件内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邮件服务器 (Mail Server)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：邮件服务器是专门用于接收、存储和转发电子邮件的服务器。它扮演着邮件的中转站和存储设备的角色。邮件服务器可以分为两种类型：SMTP服务器（发送邮件）和POP3/IMAP服务器（接收邮件）。SMTP服务器用于通过SMTP协议发送邮件，而POP3和IMAP服务器用于接收用户的邮件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SMTP (Simple Mail Transfer Protocol)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：SMTP是用于在网络上传输电子邮件的标准协议。它负责将在用户代理中创建的电子邮件从发送方传输到接收方的邮件服务器。SMTP是电子邮件系统中的“信使”，负责将邮件从一个邮件服务器转发到另一个邮件服务器，途径中可能需要经过多个中间服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;发送电子邮件的过程&#34;&gt;发送电子邮件的过程
&lt;/h3&gt;&lt;p&gt;电子邮件传递通常涉及三个阶段，从发送到接收的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地用户代理发送邮件到本地 SMTP 服务器&lt;/p&gt;
&lt;p&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户代理充当 SMTP 客户端，将邮件传递给本地 SMTP 服务器。&lt;/li&gt;
&lt;li&gt;本地 SMTP 服务器充当 SMTP 服务器，接收来自用户代理的邮件并负责进一步处理该邮件。&lt;/li&gt;
&lt;li&gt;可以使用HTTP协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地服务器将邮件中继到远程 SMTP 服务器&lt;/p&gt;
&lt;p&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地 SMTP 服务器变成了 SMTP 客户端，通过与远程 SMTP 服务器进行通信，将邮件中继到目标邮件服务器。&lt;/li&gt;
&lt;li&gt;在这个阶段，本地服务器起到了中继作用，将邮件传递到应该接收该邮件的远程服务器上，以便最终交付给收件人。&lt;/li&gt;
&lt;li&gt;开启TCP连接,使用remoteSMTP协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;远程用户代理通过邮件访问协议访问远程服务器上的邮箱&lt;/p&gt;
&lt;p&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程用户代理使用诸如 POP3（邮局协议3）或 IMAP4（互联网消息访问协议4）这样的邮件访问协议，从远程服务器上的邮箱中获取已发送的邮件。&lt;/li&gt;
&lt;li&gt;这个阶段涉及接收邮件的用户在其设备上使用邮件客户端并通过邮件访问协议与远程服务器进行通信，从而检索收到的电子邮件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;协议&#34;&gt;协议
&lt;/h3&gt;&lt;h4 id=&#34;发送邮件的协议&#34;&gt;发送邮件的协议
&lt;/h4&gt;&lt;h5 id=&#34;user-agent传递邮件&#34;&gt;User Agent传递邮件
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTP和网页邮件服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;：除了传统的邮件访问协议外，一些 Web 邮件服务（如 Gmail、Hotmail、Yahoo! 等）也使用 HTTP 协议来提供电子邮件服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;工作方式&lt;/strong&gt;：用户通过浏览器访问邮件服务提供商的网站，并使用基于 Web 的界面来阅读、发送和管理电子邮件。这种方式在移动设备和公共计算机上非常方便，而且不需要配置特定的邮件客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;smtp-服务器之间传递邮件&#34;&gt;SMTP 服务器之间传递邮件
&lt;/h5&gt;&lt;p&gt;SMTP:Simple Message Transport Prtocol&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;握手&lt;/li&gt;
&lt;li&gt;将邮件数据传输&lt;/li&gt;
&lt;li&gt;关闭连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;接受邮件的协议&#34;&gt;接受邮件的协议
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;POP（Post Office Protocol）&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;是一种&lt;code&gt;无状态&lt;/code&gt;的连接协议&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：POP 是一种简单的邮件访问协议，用于授权用户与服务器之间的通信，并下载用户的电子邮件到本地设备中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作方式&lt;/strong&gt;：用户代理（客户端）通过 POP 协议与邮件服务器进行交互，凭借授权信息下载邮件。邮件通常被下载到本地设备上，从服务器上移除。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IMAP（Internet Mail Access Protocol）&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;是一种&lt;code&gt;有状态&lt;/code&gt;的连接协议&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：IMAP 是更高级的邮件访问协议，相较于 POP，提供了更多功能，允许用户对服务器上存储的电子邮件进行管理和操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作方式&lt;/strong&gt;：用户代理通过 IMAP 与服务器通信，可以在服务器上管理邮件，如创建、移动、删除邮件等操作。&lt;code&gt;邮件仍然存储在服务器上&lt;/code&gt;，用户可以通过不同设备访问并保持同步。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;邮件扩展&#34;&gt;邮件扩展
&lt;/h4&gt;&lt;p&gt;协议:MIME（Multipurpose Internet Mail Extensions）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609200257496-8078316.png&#34;
	width=&#34;1672&#34;
	height=&#34;707&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609200257496-8078316_hu_ff76c38b58fdf391.png 480w, https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609200257496-8078316_hu_cb092433fae7a671.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609200257496&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;236&#34;
		data-flex-basis=&#34;567px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609200348220-8078316.png&#34;
	width=&#34;1406&#34;
	height=&#34;806&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609200348220-8078316_hu_7166c03a97ef3280.png 480w, https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609200348220-8078316_hu_3ede0f4b407e861b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609200348220&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;ftp协议-file-transfer-protocol&#34;&gt;FTP协议: File Transfer Protocol
&lt;/h2&gt;&lt;p&gt;FTP会保持用户的连接&lt;/p&gt;
&lt;h3 id=&#34;传输文件&#34;&gt;传输文件
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;建立连接：客户端与FTP服务器建立连接。这通常通过TCP协议完成，使用端口号21作为FTP控制端口。&lt;/li&gt;
&lt;li&gt;身份验证：客户端向服务器发送用户名和密码进行身份验证。服务器验证用户提供的凭据，如果凭据有效，则允许用户访问FTP服务器上的资源。&lt;/li&gt;
&lt;li&gt;登录成功：一旦身份验证成功，客户端和服务器之间的会话就会开始。此时，客户端可以浏览FTP服务器的文件和目录列表。&lt;/li&gt;
&lt;li&gt;文件传输：客户端可以向服务器上传文件或从服务器下载文件。对于下载操作，客户端会发送一个请求给服务器，告诉它要下载的文件名和路径。对于上传操作，客户端会将文件发送到服务器，并在控制连接上发送相关指令告诉服务器如何处理该文件。&lt;/li&gt;
&lt;li&gt;传输数据：服务器接收请求后，会建立一个数据连接以传输文件。&lt;code&gt;数据连接是独立于控制连接的另一个TCP连接，用于实际的数据传输。&lt;/code&gt;在传输过程中，FTP使用不同的端口号来区分控制数据和实际数据。。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http协议&#34;&gt;HTTP协议
&lt;/h2&gt;&lt;h3 id=&#34;url&#34;&gt;URL
&lt;/h3&gt;&lt;p&gt;URL（Uniform Resource Locator）是WWW（World Wide Web）上对象的唯一标识符。它的格式通常如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求的服务器IP地址&lt;/li&gt;
&lt;li&gt;存放在服务器上面的资源路径&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;protocol&amp;gt;://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;path&amp;gt;?query_string
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;各个部分的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Protocol（协议）&lt;/strong&gt;：用于传输或解释对象的协议，例如http、ftp、Gopher等。这是告诉浏览器或客户端如何访问该资源的方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Host（主机）&lt;/strong&gt;：对象所在的主机的DNS名称或IP地址。这是指明资源在哪个服务器上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Port（端口）&lt;/strong&gt;：可选的，指定服务器上的特定端口号。如果不指定端口号，则使用协议的默认端口，例如http的默认端口是80。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path（路径）&lt;/strong&gt;：包含对象的文件的路径名。这是服务器上的具体位置，指明服务器上哪里可以找到该资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Query_string（查询字符串）&lt;/strong&gt;：发送到服务器应用程序的名称/值对。这是用于传递参数或设置给服务器的一种方式，服务器根据这些参数或设置来返回特定的资源或执行特定的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-hyper-text-transfer-protocol&#34;&gt;HTTP: Hyper Text Transfer Protocol
&lt;/h3&gt;&lt;p&gt;使用client/server模型,运行在80端口的无状态的协议&lt;/p&gt;
&lt;h4 id=&#34;客户端发送&#34;&gt;客户端发送:
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609201540752-8078316.png&#34;
	width=&#34;1453&#34;
	height=&#34;728&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609201540752-8078316_hu_672020c4750903b1.png 480w, https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609201540752-8078316_hu_633e400e2e815227.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609201540752&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;479px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;服务器端发送&#34;&gt;服务器端发送
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609201606893-8078316.png&#34;
	width=&#34;1435&#34;
	height=&#34;723&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609201606893-8078316_hu_7e00a50f2a5cc1cc.png 480w, https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609201606893-8078316_hu_89e8bf461773a858.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609201606893&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;476px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;存储状态&#34;&gt;存储状态
&lt;/h3&gt;&lt;p&gt;使用cookies&lt;/p&gt;
&lt;p&gt;Cookies是一种服务器发送到用户浏览器并保存在本地的数据片段。它们可以用来实现多种功能，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;授权（Authorization）：通过cookies，网站可以保存用户的登录状态。当用户首次登录时，服务器会创建一个包含用户ID的cookie并发送到用户的浏览器。之后的请求将携带此cookie，允许用户无需再次登录即可访问受限页面或功能。&lt;/li&gt;
&lt;li&gt;购物车（Shopping carts）：在在线购物网站中，cookies用于跟踪用户的购物选择。当用户添加商品到购物车时，相关的产品信息会存储在cookie中。这使得用户在不同页面间跳转或在之后再次访问网站时，可以保持其购物状态。&lt;/li&gt;
&lt;li&gt;推荐（Recommendations）：许多网站使用cookies来分析用户的浏览历史和偏好，从而为他们提供个性化的推荐内容或服务。&lt;/li&gt;
&lt;li&gt;用户会话状态（User session state）：这是Cookies的另一个关键用途，它可以确保用户的浏览会话状态得到保持。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接收方式&#34;&gt;接收方式
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;非持续性连接:每一个item都要开启一次TCP(增加一个RTT)&lt;/li&gt;
&lt;li&gt;并行请求:同时请求多个item(开启多个TCP连接)&lt;/li&gt;
&lt;li&gt;持续性连接:只开启依次TCP连接(握手),之后传输所有的item&lt;/li&gt;
&lt;li&gt;流水线请求:接连着请求n个item&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;这里是对获取-n-个小型对象的不同方法的总结&#34;&gt;这里是对获取 n 个小型对象的不同方法的总结:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;One-at-a-time&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;时间主要由延迟(RTT)决定&lt;/li&gt;
&lt;li&gt;需要约 2n 个 RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;m 个并发&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;需要约 2[n/m] 个 RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久连接&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;需要约 (n+1) 个 RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流水线&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;需要约 2 个 RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流水线 + 持久连接&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;首次需要 2 个 RTT&lt;/li&gt;
&lt;li&gt;后续每次需要 1 个 RTT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;对于获取-n-个大型对象每个大小为-f的情况总结如下&#34;&gt;对于获取 n 个大型对象(每个大小为 F)的情况,总结如下:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;One-at-a-time&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;时间主要由带宽(B)决定&lt;/li&gt;
&lt;li&gt;需要约 nF/B 的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;m 个并发&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;需要约 [n/m] F/B 的时间&lt;/li&gt;
&lt;li&gt;这种情况下假设带宽在大量用户之间共享,每个 TCP 连接获得相同的带宽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流水线和/或持久连接&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;需要约 nF/B 的时间&lt;/li&gt;
&lt;li&gt;这种情况下,唯一能帮助的就是获得更高的带宽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存&#34;&gt;缓存
&lt;/h3&gt;&lt;h4 id=&#34;客户端&#34;&gt;客户端
&lt;/h4&gt;&lt;p&gt;使用:if-modified-since&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GET /somedir/page.html HTTP/1.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host: www.someschool.edu
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;User-agent: Mozilla/4.0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;If-modified-since: Wed, 18 Jan 2017 10:25:50 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;(blank line)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;服务器端&#34;&gt;服务器端
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;客户端发送带有 &amp;ldquo;If-Modified-Since&amp;rdquo; 修饰符的 GET 请求&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;客户端在请求中包含一个 &amp;ldquo;If-Modified-Since&amp;rdquo; 头,指定一个日期时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器比较资源的最后修改时间&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;服务器检查请求中的 &amp;ldquo;If-Modified-Since&amp;rdquo; 时间与资源的实际最后修改时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器返回响应&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如果资源自上次请求后未修改过,服务器返回 &amp;ldquo;304 Not Modified&amp;rdquo; 状态码&lt;/li&gt;
&lt;li&gt;如果资源已经修改过,服务器返回 &amp;ldquo;200 OK&amp;rdquo; 状态码,连同最新的资源内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;代理&#34;&gt;代理
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;客户端缓存(浏览器缓存)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;客户端(如浏览器)保存之前访问过的资源副本,以便下次直接从本地缓存中获取,减少网络请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前向代理(Forward Proxy)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;前向代理位于&lt;code&gt;客户端所在的ISP&lt;/code&gt;中,代表&lt;code&gt;客户端向服务器发起请求&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;前向代理可以缓存常用资源,减少网络流量和延迟。&lt;/li&gt;
&lt;li&gt;前向代理还可以执行内容过滤、安全检查等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向代理(Reverse Proxy)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;反向代理位于&lt;code&gt;服务器旁&lt;/code&gt;,代表&lt;code&gt;服务器向客户端提供内容&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;反向代理可以缓存常用资源,并提供负载均衡、SSL/TLS终止等功能。&lt;/li&gt;
&lt;li&gt;反向代理通常部署在服务提供商的基础设施中,隐藏了真实的服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容分发网络(CDN)&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;CDN是一个分布式的反向代理网络,将内容缓存在全球各地的服务器上。&lt;/li&gt;
&lt;li&gt;当用户请求内容时,CDN会自动将请求路由到最近的缓存服务器,减少延迟和带宽消耗。&lt;/li&gt;
&lt;li&gt;CDN适用于分发大量静态内容,如图片、视频、CSS/JS文件等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;cdn-content-distribution-network&#34;&gt;CDN: Content Distribution Network
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;内容托管和复制:
&lt;ul&gt;
&lt;li&gt;内容所有者(如网站)将其静态资源(如图片、视频、CSS、JS等)上传到CDN提供商的服务器。&lt;/li&gt;
&lt;li&gt;CDN提供商会将这些内容复制到分布在全球各地的多个边缘节点服务器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;请求路由:
&lt;ul&gt;
&lt;li&gt;当用户请求某个CDN托管的资源时,CDN的DNS服务器会根据用户的地理位置、网络状况等因素,将请求定向到最近且负载较低的边缘节点服务器。&lt;/li&gt;
&lt;li&gt;这个路由过程是自动化的,用户无需感知。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内容分发:
&lt;ul&gt;
&lt;li&gt;用户的请求被&lt;code&gt;路由到最近的边缘节点后&lt;/code&gt;,该节点服务器会迅速响应并提供所请求的内容。&lt;/li&gt;
&lt;li&gt;边缘节点服务器上都缓存有该内容的副本,因此可以快速响应用户请求,减少延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存刷新:
&lt;ul&gt;
&lt;li&gt;当内容所有者更新了资源,CDN会检测到变化并自动将最新版本的内容同步到各个边缘节点。&lt;/li&gt;
&lt;li&gt;这样可以确保用户始终获取到最新的内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609204153383-8078316.png&#34;
	width=&#34;1596&#34;
	height=&#34;688&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609204153383-8078316_hu_d42c80e34ebb62df.png 480w, https://114514yangyi.github.io/huyang/p/%E5%BA%94%E7%94%A8%E5%B1%82/image-20240609204153383-8078316_hu_c062cc4ca9e4a81c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240609204153383&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;231&#34;
		data-flex-basis=&#34;556px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>无线网络与移动网络</title>
        <link>https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/</guid>
        <description>&lt;h1 id=&#34;无线网络和移动网络&#34;&gt;无线网络和移动网络
&lt;/h1&gt;&lt;h2 id=&#34;组成&#34;&gt;组成
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无线主机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行应用程序的端系统设备&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无线链路&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;主机通过无线链路连接到基站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基站&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;连接方式&#34;&gt;连接方式:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;自组织:
没有基站,使用其他的主机节点来传播消息&lt;/li&gt;
&lt;li&gt;基站模式:
有基站,是可以在基站间移交的(设备可以移动)&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;image-20240601145540671.png&#34; alt=&#34;image-20240601145540671&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h2 id=&#34;无线&#34;&gt;无线:
&lt;/h2&gt;&lt;h3 id=&#34;缺点&#34;&gt;缺点:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在传播的过程中有损耗,和频率,距离成正比;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有多重路径的问题,可以通过反射导致接收到同样的数据在不同的时间-&amp;gt;具有时间的一致性,每一次传播的波在一定的时间内是一致的,没有重叠.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;噪声:SNR(信噪比),即信息量和噪声的比值,越大越好.BER(bit差错率),比特位错误的概率,越小越好.传播的速率越大,比特差错率越大,或者信噪比越小;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611114732494.png&#34;
	width=&#34;778&#34;
	height=&#34;771&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611114732494_hu_b68d23457d5322d3.png 480w, https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611114732494_hu_e2dd09a67776fe21.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611114732494&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;242px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;节点相互不可见:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;隐藏终端:由于遮挡物的影响,两个节点不知道彼此的存在:
&lt;img src=&#34;image-20240601150448272.png&#34; alt=&#34;image-20240601150448272&#34; style=&#34;zoom:33%;&#34; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;衰减:两个节点听不到彼此的存在:&lt;/p&gt;
&lt;img src=&#34;image-20240601150552516.png&#34; alt=&#34;image-20240601150552516&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cdma码分复用code-division-multiple-access&#34;&gt;CDMA:码分复用:Code Division Multiple Access
&lt;/h3&gt;&lt;p&gt;使用不同的正交(相乘相加为0)的码对要传输的多路节点数据包进行编码相加,在接收端进行根据码的解码,实现多路复用(同频率同时隙传输).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611150328714.png&#34;
	width=&#34;1056&#34;
	height=&#34;483&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611150328714_hu_23bf3e3c157aab5c.png 480w, https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611150328714_hu_352db2518c9f56ba.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611150328714&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;524px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于sender_i (有M个sender)有单个位的数据$d_i$,8位的码(由正一和负一组成)$c_i$,则最终的$Z_i=d_i\times c_i$,对于每一个sender,都形成这样的Z,最终将Z相加并发送给receiver:$Z^{*}=\sum_{0}^{M}{Zi}$.&lt;/li&gt;
&lt;li&gt;对于receiver想要解析出sender_i的信息,则$d_{i}=\frac{\sum_{m=1}^{M}Z^{*}\times c_{i}}{M}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;wifi80211&#34;&gt;WIFI:802.11
&lt;/h3&gt;&lt;p&gt;将频率划分为11个信道(没有重叠)&lt;/p&gt;
&lt;p&gt;基础结构(基础服务集):1.一个接入点(基站) 2.一些列的无线主机&lt;/p&gt;
&lt;p&gt;运行在同一个信道的APs会有碰撞的可能的,所有需要运行CSMA/CA&lt;/p&gt;
&lt;p&gt;802.11连接:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;到来的主机首先扫描每一个信道,监听信标帧(里面包含着接入点的名称(SSID),MAC地址)&lt;/li&gt;
&lt;li&gt;选择一个AP去连接&lt;/li&gt;
&lt;li&gt;开始认证&lt;/li&gt;
&lt;li&gt;运行DHCP分配IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扫描的过程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;被动扫描:
APs向主机发送信标帧,主机选择一个向AP发送关联请求帧,选择的AP向主机发送关联响应帧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主动扫描:&lt;/p&gt;
&lt;p&gt;主机广播探测请求帧,APs发送探测响应帧,主机向选择的AP发送关联请求帧,AP向主机发送关联相应帧&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用协议csmaca碰撞避免carrier-sense-multiple-accesscollision-avoidance&#34;&gt;使用协议CSMA/CA:碰撞避免:Carrier Sense Multiple Access/Collision Avoidance
&lt;/h4&gt;&lt;p&gt;为什么802.11要使用CSMA/CA的方式:&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;隐藏节点和暴露节点问题&lt;/strong&gt;：
在无线网络中，存在隐藏节点和暴露节点的问题。节点之间无法直接检测到冲突，因此无法像有线网络那样依靠冲突检测来解决冲突问题。CSMA/CA通过采用持续监听的方式来尽量减少这些问题的影响，而CSMA/CD无法有效处理这种情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;碰撞的后果&lt;/strong&gt;：
在无线网络中，碰撞的后果是严重的，因为当多个节点同时发送数据时，发生碰撞主机检测不出来,会一直将整个的数据包传输，降低了网络性能。CSMA/CA通过避免碰撞的方式来减少重传，提高了效率。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;具体原理&#34;&gt;具体原理
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611152046494.png&#34;
	width=&#34;941&#34;
	height=&#34;450&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611152046494_hu_3f00346a0249a668.png 480w, https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611152046494_hu_d8c7860305734d30.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611152046494&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;501px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先监听信道空闲DIFS(96bits)时间,假如空闲则发送给receiver一个RTS(request to send);假如信道忙就进行$2^{2+i}$的指数回避;&lt;/li&gt;
&lt;li&gt;receiver 接收到了RTS以后就等待一个SIFS的时间以后,发送给sender一个CTS(clear to send),说明允许发送.&lt;/li&gt;
&lt;li&gt;sender接收到了CTS,等待一个SIFS时间以后,就开始发送帧,并且预约信道(其他的sender发现了CTS就回抑制发送)&lt;/li&gt;
&lt;li&gt;receiver接收到了就使用CRC检验帧,等待SIFS的时间,正确则发送ACK&lt;/li&gt;
&lt;li&gt;假如sender接收到了ACK就重复上面的阶段,开始进行等待DIFS,否则就进行指数级回退.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;80211-frame&#34;&gt;802.11 frame
&lt;/h4&gt;&lt;img src=&#34;image-20240601154904257.png&#34; alt=&#34;image-20240601154904257&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;帧控制字段（Frame Control Field）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;长度为2个字节，包含了数据帧的类型（数据帧、管理帧、控制帧）、子类型（具体数据帧类型）、帧的方向（发送或接收）等控制信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;目标地址（Destination Address）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;长度为6个字节，指定了数据帧的接收方的MAC地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;源地址（Source Address）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;长度为6个字节，表示数据帧的发送方的MAC地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;接入点地址（BSSID，Basic Service Set Identifier）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;长度为6个字节，用于标识接入点（Access Point）的MAC地址，适用于基础服务集（BSS）模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;序列控制字段（Sequence Control Field）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;长度为2个字节，包含了帧的序列编号，用于管理帧的传输顺序和可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;帧体（Frame Body）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;包含了实际的数据负载，如IP数据报等。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;&lt;strong&gt;校验序列（FCS，Frame Check Sequence）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;长度为4个字节，用于检测数据帧在传输过程中是否发生损坏，确保数据的完整性。通常使用CRC校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;速率更改&#34;&gt;速率更改
&lt;/h4&gt;&lt;p&gt;当主机远离AP的时候:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SNR降低,BER上升.&lt;/li&gt;
&lt;li&gt;当BER过高的时候,使用更低的传输速率&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;电源管理&#34;&gt;电源管理:
&lt;/h4&gt;&lt;p&gt;主机会陷入睡眠中,并且每隔一段时间就苏醒接受消息,并且告诉AP自己要陷入睡眠中&lt;/p&gt;
&lt;h3 id=&#34;蜂窝网络&#34;&gt;蜂窝网络:
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;移动设备:
使用存储在SIM卡中的IMSI信息(64bite)&lt;/li&gt;
&lt;li&gt;基站:
在网络的边沿,和周围的基站进行合作&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用正交频分复用fdmatdma&#34;&gt;使用正交频分复用:(FDMA+TDMA)
&lt;/h4&gt;&lt;p&gt;按照频率和时间将其划分为PRB(物理资源块)
&lt;img src=&#34;image-20240601160633402.png&#34; alt=&#34;image-20240601160633402&#34; style=&#34;zoom:33%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;将每一个PRB分为不同的用户&lt;/p&gt;
&lt;h4 id=&#34;lte架构&#34;&gt;LTE架构:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;HSS : Home Subscriber Service&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;存储着用户的信息,和MME一起进行用户的认证&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Serving Gateway (S-GW)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;S-GW位于移动设备与互联网之间的数据路径上。&lt;/li&gt;
&lt;li&gt;主要功能是&lt;code&gt;连接用户设备与移动核心网络&lt;/code&gt;，并负责用户数据的传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Packet Data Network Gateway (P-GW)&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;P-GW是通往移动蜂窝网络的网关。&lt;/li&gt;
&lt;li&gt;它类似于其他互联网网关路由器，是&lt;code&gt;连接移动网络与外部互联网的关键节点。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;P-GW提供网络地址转换（NAT）服务，管理移动用户的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MME:Mobility Management Entity:&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备认证&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动设备管理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;手持设备在不同蜂窝区域之间的移动，在实现无缝覆盖的同时应对设备的切换（handover）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径设置（隧道）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;从移动设备到Packet Data Network Gateway（P-GW）之间的路径（tunneling）建立.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;lte&#34;&gt;LTE:
&lt;/h4&gt;&lt;p&gt;控制平面:&lt;/p&gt;
&lt;img src=&#34;image-20240601161534482.png&#34; alt=&#34;image-20240601161534482&#34;  /&gt;
&lt;p&gt;数据平面:(使用隧道技术)&lt;/p&gt;
&lt;img src=&#34;image-20240601161557797.png&#34; alt=&#34;image-20240601161557797&#34;  /&gt;
&lt;h4 id=&#34;协议&#34;&gt;协议:
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无线主机和基站进行连接&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;信令信号广播&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;基站每隔5毫秒在所有频率上广播主同步信号（Primary Synchronization Signal）。&lt;/li&gt;
&lt;li&gt;多个载波的基站可能同时广播同步信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动设备定位与信息获取&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;移动设备首先搜索到主同步信号，然后在这个频率上找到第二同步信号。&lt;/li&gt;
&lt;li&gt;移动设备接收基站广播的信息，包括信道带宽、配置信息，以及基站所属的蜂窝网络信息。&lt;/li&gt;
&lt;li&gt;移动设备可能同时从多个基站以及多个蜂窝网络获取信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基站关联选择&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;移动设备选择要关联的基站，通常会优先选择归属的“家庭载波”（home carrier）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认证、建立状态、设置数据平面&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;完成基站关联后，还需要进行后续步骤，如认证移动设备的身份、建立通信状态和设置数据传输通道等操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将数据从无线主机发送到基站:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;链路层协议:&lt;/p&gt;
&lt;p&gt;使用Package Data Convergence(压缩IP头和加密),Radio Link Control(包分段和重装),Medium Access(OFDM)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将数据从基站传输到P-GW&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用层协议:GTP-U&lt;/p&gt;
&lt;p&gt;使用GTP协议(应用层协议)将应用数据封装(在基站中),然后发送给S-GW,S-GW再重新隧道发送给P-GW,在设备移动的时候,只有隧道的终点改变&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;睡眠模式&#34;&gt;睡眠模式
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轻度睡眠（Light Sleep）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在设备长时间（数百毫秒）无活动后进入轻度睡眠状态。&lt;/li&gt;
&lt;li&gt;设备定期（数百毫秒）唤醒来检查是否有下行传输任务需要处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;深度睡眠（Deep Sleep）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在设备长时间（5-10秒）无活动后进入深度睡眠状态。&lt;/li&gt;
&lt;li&gt;移动设备可能在深度睡眠时更换蜂窝区域（cells），这样需要重新建立与新基站的关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;移动性&#34;&gt;移动性
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在不同的网络提供商中的网络间移动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先主机向访问网络发送信息联系,然后被访问网络的MME向主机的SHH注册主机在哪里&lt;/p&gt;
&lt;h3 id=&#34;直接路由&#34;&gt;直接路由
&lt;/h3&gt;&lt;img src=&#34;image-20240601163103390.png&#34; alt=&#34;image-20240601163103390&#34;  /&gt;
&lt;h3 id=&#34;间接路由&#34;&gt;间接路由
&lt;/h3&gt;&lt;img src=&#34;image-20240601163012097.png&#34; alt=&#34;image-20240601163012097&#34;  /&gt;
&lt;h3 id=&#34;连接到不同的访问网络&#34;&gt;连接到不同的访问网络
&lt;/h3&gt;&lt;p&gt;基站关联是移动通信网络中的重要步骤，包括以下主要阶段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611163806348.png&#34;
	width=&#34;1101&#34;
	height=&#34;489&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611163806348_hu_d2bdff4b1befae44.png 480w, https://114514yangyi.github.io/huyang/p/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/image-20240611163806348_hu_ad76198337e532cd.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611163806348&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;540px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基站关联&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;移动设备向基站提供国际移动用户识别码（IMSI），以便识别自身和归属网络。&lt;/li&gt;
&lt;li&gt;通过这一步骤，移动设备与基站建立关联，选择归属的基站进行通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制平面配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;移动管理实体（MME）和归属家庭子系统（Home Subscriber Server，HSS）建立控制平面状态，告诉HHS这个无线主机在这里.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据传输配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;MME为移动设备配置转发隧道，以便在网络中传输数据。&lt;/li&gt;
&lt;li&gt;访问网络和归属网络建立从归属分组数据网关（P-GW）到移动设备的数据传输隧道。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;移动切换&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;移动设备改变其连接点，即改变所访问网络的位置，实现移动切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;基站转换&#34;&gt;基站转换
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当前基站选择目标基站&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当前基站选择目标基站，并向目标基站发送Handover Request消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标基站预分配射频时隙&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;目标基站为手持设备预分配无线电时间插槽，并以HR ACK响应，携带所需要的信息传输给手持设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当前基站通知手持设备新基站信息&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当前基站通知手持设备已切换到新基站，手持设备现在可以通过新基站发送数据，这样就完成了切换过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当前基站停止向手持设备发送数据包&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当前基站停止直接向手持设备发送数据包，并开始把数据包转发给新基站（新基站再通过无线通道发送给手持设备）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标基站通知MME&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;目标基站通知移动管理实体（MME）它是新的基站，MME指示服务网关（S-GW）改变隧道的终点为目标基站。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标基站回复当前基站&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;目标基站向当前基站发送确认（ACK）：切换已完成，当前基站可以释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手持设备数据包经新隧道流向S-GW&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;手持设备的数据包现在通过新的隧道从目标基站流向服务网关（S-GW）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&#34;image-20240601163826095.png&#34; alt=&#34;image-20240601163826095&#34;  /&gt;
&lt;img src=&#34;image-20240601163837841.png&#34; alt=&#34;image-20240601163837841&#34;  /&gt;
&lt;img src=&#34;image-20240601163826095.png&#34; alt=&#34;image-20240601163826095&#34;  /&gt;
&lt;img src=&#34;image-20240601163837841.png&#34; alt=&#34;image-20240601163837841&#34;  /&gt;
</description>
        </item>
        <item>
        <title>链路层</title>
        <link>https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
        <pubDate>Tue, 20 May 2025 11:54:10 +0800</pubDate>
        
        <guid>https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
        <description>&lt;h1 id=&#34;链路层协议&#34;&gt;链路层协议
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;节点&lt;/strong&gt;:运行链路层协议的任何设备&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链路&lt;/strong&gt;:连接两个节点的通信信道&lt;/li&gt;
&lt;li&gt;点对点传输&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;流量控制就是限制发送方的传输速率，以免超过接受方的接受能力，造成帧丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在OSI体系中链路层是有流量控制的，而在TCP/IP体系中流量控制在传输层实现。&lt;/p&gt;
&lt;h2 id=&#34;链路层提供的服务&#34;&gt;链路层提供的服务
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;成帧&lt;/li&gt;
&lt;li&gt;链路接入&lt;/li&gt;
&lt;li&gt;可靠交付&lt;/li&gt;
&lt;li&gt;比特差错检验和纠正&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;链路层在何处实现&#34;&gt;链路层在何处实现
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;是在网络适配器的芯片上实现的,结合了软件硬件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;唯一标识每一个接口:MAC地址&lt;/p&gt;
&lt;p&gt;&lt;code&gt;链路层协议包括比特错误的检测和纠正,流量控制&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半双工通道:可以支持端点相互传输数据,但是同时只能够有一个端点在传送消息&lt;/li&gt;
&lt;li&gt;全双工通道:能够有两端同时向对方传输信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;错误检查和纠正&#34;&gt;错误检查和纠正
&lt;/h2&gt;&lt;p&gt;错误分为位错（帧中的几个数据位出现错误）和帧错（帧丢失，顺序错误，帧重复）&lt;/p&gt;
&lt;p&gt;（在OSI中认为链路层应该提供可靠的传输，所以提供了原本应该是传输层的作用：帧的重传，确认，标号）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用奇偶校验:&lt;/p&gt;
&lt;p&gt;对于n位的数据位来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;奇检验码是在数据位后面添一个位数使得所有位数中“1”的个数为奇数；&lt;/li&gt;
&lt;li&gt;偶检验码是在数据位后面添加一个位数使得所有位数中“1”的个数为偶数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一维的奇偶校验,只能够检测出一位的错误,但是不能纠正错误,需要1bit冗余
二维的奇偶校验,可以检测一位的错误,可以纠正一位的错误,需要2n bit的冗余&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用校验和:
将每16位相加最终结果取反&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用循环冗余校验法:
先决定R位的冗余位,再确定生成的G(R+1位)生成码,使用数据$D\times 2^R$（在D的后面添加R个0）来异或除G,最终得到R位的异或余数,为最终的冗余位.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20250525175654360.png&#34;
	width=&#34;1902&#34;
	height=&#34;1062&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20250525175654360_hu_49603698b93f65b6.png 480w, https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20250525175654360_hu_d6a00d3d1235685f.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250525175654360&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;429px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多路访问链路multiple-access-links&#34;&gt;多路访问链路(Multiple access links)
&lt;/h2&gt;&lt;p&gt;类型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端到端&lt;/li&gt;
&lt;li&gt;广播&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解释:多个端同时地发送数据,可能会相互干扰而导致碰撞&lt;/p&gt;
&lt;p&gt;&lt;code&gt;是否会产生碰撞主要看节点在传输帧的时候,会不会接收到其他节点传输的帧&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即:$d_{prop}&amp;lt;\frac{L}{R}$&lt;/p&gt;
&lt;p&gt;方式:&lt;/p&gt;
&lt;h4 id=&#34;按照频率和时间片来划分&#34;&gt;&lt;strong&gt;按照频率和时间片来划分&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;TDMA:时分复用
将时间划分为同等长度的时隙,每次每一个时隙都划分给一个端,每一个时隙都可以传输一个帧&lt;/li&gt;
&lt;li&gt;FDMA:频分复用
将频率划分为不同的部分,给端使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TDM比FDM的优点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发生拥塞等网络问题时，&lt;code&gt;TDM中的数据丢失可能只会是一部分，而FDM中就可能&lt;/code&gt;
&lt;code&gt;是大部分或全部。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TDM适合数字信号传输&lt;/code&gt;，而FDM适合模拟信号传输，因为现在通信网络多是传输数
字信号，所以TDM比FDM好。&lt;/li&gt;
&lt;li&gt;因为频分复用连接建立后，当中途没有数据传输时，他所占有的频段带宽不能被其
他连接使用，故可能存在空置，而在时分复用的统计时分模式下，连接建立后，当某
个连接暂时不用传输数据时可以少分时间片或者不分，即其&lt;code&gt;时隙的分配时“按需分&lt;/code&gt;
&lt;code&gt;配”&lt;/code&gt;，这样就让出了相应的传输时间给其他连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;随机发送协议&#34;&gt;&lt;strong&gt;随机发送协议&lt;/strong&gt;
&lt;/h4&gt;&lt;h5 id=&#34;slotted-aloha&#34;&gt;Slotted ALOHA
&lt;/h5&gt;&lt;p&gt;每一个端想要传输信息就直接传输,使用两种协议来处理碰撞,同样将每一个时间段都划分成ALOHA时隙,假如传输没有碰撞则当前节点继续在下一个时隙传输,否则就在下面的每一个时隙中以概率p传输.-&amp;gt;最大的传输效率是$\frac{1}{e}$​&lt;/p&gt;
&lt;h5 id=&#34;csma&#34;&gt;CSMA
&lt;/h5&gt;&lt;p&gt;CSMA:carrier sense multiple access
​			在发送之前先听信道中是否空闲,加入空闲则传输,否则就抑制传输,直到信道空闲&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSMA/CD:碰撞检测-&amp;gt;在Ethernet中使用
&lt;ul&gt;
&lt;li&gt;假如当前的信道空闲则监听96bit时间后发送信息
否则一直抑制传输,直到信道空闲&lt;/li&gt;
&lt;li&gt;在传输中监听到了碰撞,则立刻停止传输,并且持续发送48bit时间的干扰信号(jamming Signal).发送完以后就开始选取随机的退避时间(指数回退),在第m次的碰撞中,从{$0,1,2,3,,,,2^{m}-1$}中随机选择一个k,则回避512bit$\times$k的比特时间,重新开始监听信道并且准备重新发送帧.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CSMA/CA:碰撞避免-&amp;gt;在802.11中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;轮流方式&#34;&gt;&lt;strong&gt;轮流方式&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;中心的服务器让每一个主机都轮流地发送帧
缺点:轮询的消耗,延迟,单点错误&lt;/li&gt;
&lt;li&gt;分布式:每一个拿到票的主机可以发送帧,当发送完以后可以交给下一个主机.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;上行流量使用随机访问,有的使用时分复用;下行流量使用频分复用&lt;/p&gt;
&lt;h2 id=&#34;局域网lans&#34;&gt;局域网(LANs)
&lt;/h2&gt;&lt;h4 id=&#34;mac地址&#34;&gt;MAC地址:
&lt;/h4&gt;&lt;p&gt;​	48-bits的地址,用于唯一标识每一个接口-&amp;gt;主机和路由器都有MAC地址,但是交换机没有&lt;/p&gt;
&lt;h4 id=&#34;arp包&#34;&gt;ARP包:
&lt;/h4&gt;&lt;p&gt;​	ARP table是将IP映射到相应的MAC地址,结构为&amp;lt;IP,MAC,ttl&amp;gt;&lt;/p&gt;
&lt;p&gt;过程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;询问的主机发送一个ARP包,里面的destIP和srcIP是自己的和查询对方的,srcMAC是自己接口的,而destMAC是广播地址&lt;/li&gt;
&lt;li&gt;等到接受主机接收到了ARP包以后发现destIP是自己的,所以会将自己接口的MAC地址填入到srcMAC中,构造reply-MAC的ARP包发送给查询主机&lt;/li&gt;
&lt;li&gt;查询主机收到了返回的ARP包以后会将条目添加进ARP table中.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;lan的物理结构&#34;&gt;LAN的物理结构:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用总线&lt;/li&gt;
&lt;li&gt;使用交换机&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;以太网的帧形式8021&#34;&gt;以太网的帧形式:802.1
&lt;/h4&gt;&lt;img src=&#34;image-20240530093040451.png&#34; alt=&#34;image-20240530093040451&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Preamble（前导码）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;长度为7个字节，由连续交替的1和0组成，用于在接收端同步时钟，并标识帧的开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Start Frame Delimiter（帧起始符）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;一个字节的特殊字段，标志着帧的开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Destination MAC Address（目的MAC地址）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;长度为6个字节，指定了帧要送达的目标设备的MAC地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Source MAC Address（源MAC地址）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;长度为6个字节，指示发送该帧的设备的MAC地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type / Length（类型/长度字段）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;通常占两个字节，用于表示数据帧中数据部分的类型（如IP、ARP等）或者指定数据字段的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Payload（有效载荷）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;包含了实际的数据内容，可以是上层协议的数据部分，如IP数据报。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FCS（Frame Check Sequence，帧校验序列）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;长度为4个字节，用于检测前面字段（包括目的MAC地址、源MAC地址、类型/长度字段和有效载荷）是否在传输中发生了错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注意事项&#34;&gt;注意事项：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以太网头部信息的总长度为至少14个字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的MAC地址和源MAC地址是唯一标识网络设备的物理地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太网帧头部信息的结构在不同的以太网标准（如Ethernet II、IEEE 802.3等）中可能略有不同，但通常遵循以上基本的字段结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无状态的,无连接的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有ACK等可靠机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用CSMA机制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;交换机&#34;&gt;交换机:
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于其他的主机是透明的&lt;/li&gt;
&lt;li&gt;即插即用,使用自学习&lt;/li&gt;
&lt;li&gt;传输的时候是全双工,无碰撞的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把每一个相应的srcMAC和srcport记录在转发表中;&lt;/li&gt;
&lt;li&gt;假如转发表中有destMAC,则按照转发表进行转发;否则就泛洪到其他的所有端口.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与路由器的异同点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;功能差异：&lt;/strong&gt; 路由器连接多个网络，负责在不同网络之间传输数据包，而交换机连接局域网内的设备，实现设备之间的数据交换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作层级：&lt;/strong&gt; 路由器工作在网络层（第三层），根据 IP 地址进行路由和转发；交换机工作在数据链路层（第二层），通过 MAC 地址进行数据交换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据处理方式：&lt;/strong&gt; 路由器是基于 IP 地址进行数据转发的，可以跨网段传输数据；交换机是通过 MAC 地址进行数据帧转发，只能在局域网内传输数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全功能：&lt;/strong&gt; 路由器通常具有防火墙功能，可以过滤网络流量，提供一定程度的网络安全保护；交换机对网络安全方面的功能相对较弱。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;vlan虚拟局域网&#34;&gt;VLAN:虚拟局域网:
&lt;/h4&gt;&lt;p&gt;LAN的问题:规模问题,安全隐私问题;管理问题;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;port-based VLANs:
在一个交换机中按照不同的端口划分为不同的局域网,互不干涉
流量隔离;动态的成员划分;在不同的虚拟局域网中使用路由器转发&lt;/li&gt;
&lt;li&gt;在多个交换机中建立多个虚拟局域网:
使用干线端口:使用两个端口将两个交换机相连成为一个交换机,而在Etnernet头中添加一个关于VLAN ID的值,标识每一个VLAN&lt;code&gt;,在802.1中不能这样做,因为没有VLAN ID,但是在802.1q中添加了关于VLAN ID的信息.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EVPNs:Ethernet VPNs:
跨路由器的将两个交换机的干线端口相连,是将Ethernet包裹在IPHeader中,使用隧道技术.&lt;/p&gt;
&lt;h4 id=&#34;mpls-multiprotocol-label-switch&#34;&gt;MPLS :Multiprotocol Label Switch
&lt;/h4&gt;&lt;p&gt;在Ethernet Header和IP Header 之间添加一个MPLS Header 用于使用一个定长的标签,使支持MLPS的路由器可以只根据Label的值来进行转发.这个协议是路由转发数据报的协议,用于路由器中.&lt;/p&gt;
&lt;p&gt;可以实现负载均衡,数据包的任意的转发配置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611104200433.png&#34;
	width=&#34;1139&#34;
	height=&#34;799&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611104200433_hu_ee766c9bd4af7454.png 480w, https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611104200433_hu_3c12def0b0444354.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611104200433&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;342px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP router:只关心终点的IP地址&lt;/li&gt;
&lt;li&gt;MPLS router:关心起点和终点的IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MPLSrouter使用转发表的结构:&amp;lt;in label, out label, dest, out interface&amp;gt;,一个router知道了A,可以将A的存在广播给自己的邻居,使用RSVP-TE协议,同时设置in label ,out label.&lt;/p&gt;
&lt;h4 id=&#34;dcn--data-center-network&#34;&gt;DCN : Data Center Network:
&lt;/h4&gt;&lt;p&gt;等级拓扑:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;边界路由器&lt;/li&gt;
&lt;li&gt;接入路由器&lt;/li&gt;
&lt;li&gt;负载均衡器&lt;/li&gt;
&lt;li&gt;第一层交换机&lt;/li&gt;
&lt;li&gt;第二层交换机&lt;/li&gt;
&lt;li&gt;TOR交换机&lt;/li&gt;
&lt;li&gt;服务器架构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611110350092.png&#34;
	width=&#34;1750&#34;
	height=&#34;754&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611110350092_hu_74d9e857b3e9b1c6.png 480w, https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611110350092_hu_f77cc94d2840d081.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611110350092&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;557px&#34;
	
&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;TOR交换机&lt;/li&gt;
&lt;li&gt;服务器架构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611110350092.png&#34;
	width=&#34;1750&#34;
	height=&#34;754&#34;
	srcset=&#34;https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611110350092_hu_74d9e857b3e9b1c6.png 480w, https://114514yangyi.github.io/huyang/p/%E9%93%BE%E8%B7%AF%E5%B1%82/image-20240611110350092_hu_f77cc94d2840d081.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20240611110350092&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;557px&#34;
	
&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
